<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>study</title>
    <link href="/2025/08/21/study/"/>
    <url>/2025/08/21/study/</url>
    
    <content type="html"><![CDATA[<h1 id="RAGFLOW"><a href="#RAGFLOW" class="headerlink" title="RAGFLOW"></a>RAGFLOW</h1><h2 id="什么是RAGFLOW"><a href="#什么是RAGFLOW" class="headerlink" title="什么是RAGFLOW"></a>什么是RAGFLOW</h2><p><a href="https://ragflow.io/">RAGFlow</a> 是一个基于深度文档理解的开源 RAG（检索增强生成）引擎。它为任何规模的企业提供了简化的 RAG 工作流程，结合了 LLM（大型语言模型）提供真实的问答功能，并以来自各种复杂格式的有根据的引文为后盾。</p><p><strong>SDK</strong> 是 <strong>Software Development Kit</strong>（<strong>软件开发工具包</strong>）的缩写，中文通常称“开发工具包”，用于开发特定平台或软件应用的工具集合。</p><h3 id="Integrations"><a href="#Integrations" class="headerlink" title="Integrations"></a>Integrations</h3><blockquote><p><code>integrations</code> 目录中 RAGFlow 与 ChatGPT-on-WeChat 对接。</p></blockquote><h3 id="NLTK"><a href="#NLTK" class="headerlink" title="NLTK"></a>NLTK</h3><blockquote><p>NLTK 是 Natural Language Toolkit（自然语言处理工具包）</p></blockquote><ul><li><strong>文本分词</strong>（tokenization）</li><li><strong>词性标注</strong>（POS tagging）</li><li><strong>命名实体识别</strong>（NER）</li><li><strong>句法分析</strong>（parsing）</li></ul><h3 id="uv-lock-Python项目的依赖组件"><a href="#uv-lock-Python项目的依赖组件" class="headerlink" title="uv.lock Python项目的依赖组件"></a>uv.lock Python项目的依赖组件</h3><p><a href="https://zhuanlan.zhihu.com/p/1893299536002261393%20%20ragFlow">https://zhuanlan.zhihu.com/p/1893299536002261393 RAGFlow</a> 项目结构</p><p><strong>Werkzeug</strong>：Werkzeug 是一个纯 Python 编写的 WSGI 工具库，由 Flask 的核心开发者（Pallets 团队）维护。它的定位是：“HTTP 和 WSGI 的瑞士军刀”，提供构建 Web 框架&#x2F;服务器所需的各种底层功能，但本身不是一个完整的 Web 框架。</p><p>SIGINT：信息获取，SIGTERM：关闭。</p><p>WSGI：的全称是 <strong>Web Server Gateway Interface</strong>（Web 服务器网关接口）。一句话概括：<strong>它是 Python Web 应用（或框架）与 Web 服务器之间的“通用翻译官”</strong>。</p><p><strong>Node.js（简称 node）</strong> 是让你在浏览器之外也能运行 JavaScript 的“发动机”。运行 JavaScript 代码不用浏览器，直接在命令行。</p><p><strong>JavaScript</strong> 是让网页从“静态海报”变成“交互应用”的魔法语言，现在更是前后端通吃的万能胶水。</p><p><strong>构造函数</strong>：在 Python 中，构造函数的名字总是 <code>__init__</code>，是<strong>在创建对象时自动调用的特殊方法</strong>，用于初始化对象的状态（属性）。</p><p><code>dir()</code> 是 Python 的一个内置函数，作用是<strong>列出对象的属性和方法名称</strong>。</p><p><code>setattr</code> 是 Python 内置函数，用于<strong>给对象动态地设置属性值</strong>。<code>setattr(object, name, value)</code></p><p><code>__dict__</code>：实例属性，你创建一个类的实例后，实例的属性就会被存放在 <code>__dict__</code> 中。</p><p><strong>双下划线</strong>（dunder，double underscore）的函数，在 Python 里统称为**“魔术方法 &#x2F; 特殊方法”**。它们不让你直接调用，而是由 <strong>Python 解释器在特定场景下自动触发</strong>，用来定义对象的核心行为。</p><p><strong>三引号</strong>：就是“多行字符串”，至于拿来干什么，取决于它放在哪里。</p><ul><li><strong>当放在模块、类、函数或方法的第一行</strong> —— 它就是文档字符串（docstring），通过 <code>help(func)</code> 或 <code>func.__doc__</code> 能拿到这段说明。</li><li><strong>当放在赋值语句右边</strong> —— 它就是普通字符串，只是跨行写起来更方便。</li><li><strong>当放在代码里但既不赋值也不当 docstring</strong> —— 它就只是被忽略的字符串常量。</li></ul><hr><h2 id="JSON-处理"><a href="#JSON-处理" class="headerlink" title="JSON 处理"></a>JSON 处理</h2><p>✅ <code>json.dumps(obj)</code>：<strong>Python → JSON 字符串</strong><br>✅ <code>json.loads(json_str)</code>：<strong>JSON 字符串 → Python 对象（通常是字典）</strong>。</p><hr><h2 id="Python-命名约定"><a href="#Python-命名约定" class="headerlink" title="Python 命名约定"></a>Python 命名约定</h2><p>在 Python 中，变量名前加下划线（例如 <code>_param</code>）<strong>是一种约定，表示这是一个“内部变量”或“私有属性”</strong>。</p><p>Python 函数在调用时必须已经先定义在调用上方，函数内调用不分先后。</p><hr><h2 id="集合与生成器"><a href="#集合与生成器" class="headerlink" title="集合与生成器"></a>集合与生成器</h2><p>🟢 <code>set([])</code> 是什么意思？创建空集合。</p><p><code>yield</code> 是一个用于**生成器函数（generator function）**的关键字，可以让函数一次返回一个值，同时记住上次执行的位置。边执行边产出。“暂停一下，先给你一条消息，等你处理完了我再继续往下走。”</p><h3 id="🧠-yield-与-return-的区别"><a href="#🧠-yield-与-return-的区别" class="headerlink" title="🧠 yield 与 return 的区别"></a>🧠 yield 与 return 的区别</h3><table><thead><tr><th><strong>比较项</strong></th><th><strong>return</strong></th><th><strong>yield</strong></th></tr></thead><tbody><tr><td>函数类型</td><td>普通函数</td><td>生成器函数（返回生成器对象）</td></tr><tr><td>返回行为</td><td>一次性返回，函数结束</td><td>暂停函数，保留状态，下次继续</td></tr><tr><td>可多次输出？</td><td>否，一次</td><td>是，多次（使用 for 或 next()）</td></tr><tr><td>内存效率</td><td>不高（返回整个列表等）</td><td>高效（按需生成，每次一个值）</td></tr></tbody></table><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>✅ 一句话解释：<code>try-except-raise</code> 用于：</p><ul><li><strong>捕获异常</strong>（<code>try</code>）：可能出错的代码</li><li><strong>做出处理</strong>（<code>except</code>）：先处理一下，比如打印日志</li><li><strong>重新抛出异常</strong>（<code>raise</code>），让它传给外部或中止程序</li></ul><hr><h2 id="切片与装饰器"><a href="#切片与装饰器" class="headerlink" title="切片与装饰器"></a>切片与装饰器</h2><ul><li><code>[::-1]</code> 是 Python 的切片语法，用于反转序列：<ul><li>第一个 <code>:</code> 表示从开始到结束</li><li>第二个 <code>:</code> 后是步长（step），<code>-1</code> 表示从后向前遍历</li></ul></li></ul><p><code>@property</code> 装饰器将方法伪装成属性。用户像操作属性一样使用（无需显式调用方法）。</p><p><code>@</code> 是<strong>装饰器（Decorator）语法</strong>的标志，用于<strong>包装函数、方法或类</strong>，在不改变其原始定义的前提下，增强或修改其行为。</p><pre><code class="language-python">@decoratordef func():    pass等价于：pythondef func():    passfunc = decorator(func)装饰器（Decorator）就是一个“包装函数”，在不修改原函数代码的前提下，给它加功能。✅ 举个生活例子：你点了一杯奶茶，店员在封口前又给你加了层奶盖 —— 这就是“装饰”：奶茶（原函数）没变，但多了奶盖（新功能）。pythondef login_required(func):    def wrapper(*args, **kwargs):        if session.get(&#39;username&#39;):            return func(*args, **kwargs)  # 用户已登录，正常执行原函数        else:            return &#39;请先登录！&#39;  # 未登录，拦截请求    return wrapper@app.route(&#39;/profile&#39;)@login_required  # 👈 装饰器：给 /profile 加“登录检查”功能def profile():    return &#39;个人中心页面&#39;req = request.json 是 Flask 中获取请求体中的 JSON 数据的一种方式。nonlocal 是 Python 中的一个关键字，用于在嵌套函数中声明一个变量不是局部变量，而是来自外层（非全局）作用域的变量。后端路由定位根据 URL 定位后端路由：框架搜索关键词示例路由定义示例Spring Boot@PostMapping(&quot;/v1/chunk/list&quot;) 或 @RequestMapping@PostMapping(&quot;/v1/chunk/list&quot;)数据库索引KEY devparamtemplate_create_time (create_time)：这些语句是给表里的字段加普通索引（KEY），作用是为了提高查询速度，但不会限制字段值唯一。类型作用是否防重复KEY 或 INDEX提升查询性能❌ 不限制重复UNIQUE KEY防重复值 + 提升查询性能✅ 限制重复ORM 模型示例pythonclass DevParamTemplate(DataBaseModel):    id = CharField(max_length=32, primary_key=True)    name = CharField(max_length=100, null=False, help_text=&quot;模板名称&quot;, index=True)    agent_id = CharField(max_length=64, null=True, help_text=&quot;关联的agentID&quot;, index=True)    auth = CharField(max_length=255, null=True, help_text=&quot;授权信息&quot;)    template = TextField(null=True, help_text=&quot;参数模板内容&quot;, default=list)    status = CharField(max_length=1, null=True, default=&quot;1&quot;, help_text=&quot;状态 1是开启 0是关闭&quot;, index=True)    class Meta:        db_table = &quot;dev_param_template&quot;Index=True 表示为这个字段创建普通索引（提高查询速度，但不会防止重复值）。接口设计与错误码改一下接口 create_paramtemplate 加一步“唯一性校验”，否则当用户传入重复的 name 时，数据库会抛出 IntegrityError，前端只会收到 500（HTTP 状态码，表示服务器内部错误）。场景HTTP 状态码业务返回码（示例）请求成功200code=0参数错误400code=100权限不足200（或 403）code=401服务器异常500code=500分层架构Service 层：Controller 只负责接收参数、调用服务、返回结果，不做业务逻辑。Controller（控制器）层像前台接待员：只负责“收快递”（接收 HTTP 请求参数）把快递交给后台仓库（Service 层）再把仓库返回的结果打包发回给客人（返回 JSON 给前端）一句话：不处理业务逻辑，只做“收、转、返”。Service（业务）层像后台仓库：真正拆包裹、检查货物（参数校验、业务规则）决定能不能入库（判断名称是否重复）把最终入库单交给工人（DAO / ORM）去落库一句话：所有“能不能做、该怎么做”的判断都在这里。MVC / 分层结构就是把代码按职责切成三层（或更多层）：M Model（数据模型，对应数据库表）V View（前端页面 / JSON 视图）C Controller（上面说的前台接待员）S Service（后台仓库）好处：各层互不干扰，代码好维护、好测试、好复用。Jenkins 与 CI/CDJenkins：Jenkins 是一个开源的、提供友好操作界面的持续集成（CI）工具，起源于 Hudson，主要用于持续、自动的构建/测试软件项目。CI/CD 是什么？CI（Continuous Integration，持续集成）：一种软件开发实践。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。CD（Continuous Delivery，持续交付）：是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境（类生产环境）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。Tomcat功能说明接收浏览器请求别人输入网址，Tomcat 听见“有人敲门”把你的代码跑起来它帮你把 Java 代码变成网页，回给浏览器管理“网站生命”网站启动、关闭、重启，都由 Tomcat 管npm 命令npm run build = 把“开发时的源代码”变成“用户真正看到的网页”，就像把厨房半成品变成端上桌的硬菜。npm run dev = 开发专用“实时预览 + 调试”模式，菜还没正式上桌，但厨师可以随时尝咸淡。线程池🧠 基本概念概念含义线程池（ThreadPool）提前准备好的几个“工作线程”任务（Task）你要执行的函数，比如 get_data()Future表示“将来”会返回结果的对象，你可以等待它完成submit()提交一个任务给线程池map()批量处理多个任务，像 map() 函数一样with … as自动关闭线程池资源的推荐写法🧪 示例代码（带中文注释）pythonimport timefrom concurrent.futures import ThreadPoolExecutor, as_completed# 假设这是你要并行执行的函数def fetch_data(name, wait=1):    print(f&quot;[&#123;name&#125;] 开始执行任务，预计耗时 &#123;wait&#125; 秒&quot;)    time.sleep(wait)  # 模拟 I/O 操作（比如请求网页）    print(f&quot;[&#123;name&#125;] 完成任务&quot;)    return f&quot;&#123;name&#125; 的数据&quot;# 主程序开始if __name__ == &quot;__main__&quot;:    # 创建一个线程池，最多同时执行 3 个任务    with ThreadPoolExecutor(max_workers=3) as executor:        # 提交多个任务给线程池执行        futures = []        for i in range(5):            # submit(函数, 参数1, 参数2, ...)            future = executor.submit(fetch_data, f&quot;任务&#123;i+1&#125;&quot;, wait=i % 3 + 1)            futures.append(future)        # 等待所有任务完成（异步）        for future in as_completed(futures):            result = future.result()  # 获取返回值（阻塞直到完成）            print(f&quot;[主程序] 收到结果：&#123;result&#125;&quot;)🧠 学习小笔记（建议记下来）点说明✅ ThreadPoolExecutor(max_workers=N)N 是最多同时运行几个任务（线程数）✅ submit(func, *args)异步执行函数，立即返回 Future✅ as_completed(futures)按任务完成顺序返回结果✅ .result()获取函数运行完后的返回值❗ 适合 I/O 密集型任务比如网络请求、数据库查询、文件操作❌ 不适合 CPU 密集型如训练模型、数学计算 → 请用多进程正则表达式常用元字符字符描述实例试一试[]一组字符&quot;[a-m]&quot;\示意特殊序列（也可用于转义特殊字符）&quot;\d&quot;.任何字符（换行符除外）&quot;he..o&quot;^起始于&quot;^hello&quot;$结束于&quot;world$&quot;*零次或多次出现&quot;aix*&quot;+一次或多次出现&quot;aix+&quot;&#123;&#125;确切地指定的出现次数&quot;al&#123;2&#125;&quot;``两者任一`&quot;fallsstays&quot;`特殊序列字符描述实例\A如果指定的字符位于字符串的开头，则返回匹配项&quot;\AThe&quot;\b返回指定字符位于单词的开头或末尾的匹配项r&quot;\bain&quot;, r&quot;ain\b&quot;\B返回指定字符存在的匹配项，但不在单词的开头（或结尾处）r&quot;\Bain&quot;, r&quot;ain\B&quot;\d返回字符串包含数字的匹配项（数字 0-9）&quot;\d&quot;\D返回字符串不包含数字的匹配项&quot;\D&quot;\s返回字符串包含空白字符的匹配项&quot;\s&quot;\S返回字符串不包含空白字符的匹配项&quot;\S&quot;\w返回一个匹配项，其中字符串包含任何单词字符（a-z, A-Z, 0-9, _）&quot;\w&quot;\W返回一个匹配项，其中字符串不包含任何单词字符&quot;\W&quot;\Z如果指定的字符位于字符串的末尾，则返回匹配项&quot;Spain\Z&quot;集合表达式描述[arn]返回一个匹配项，其中存在指定字符（a, r 或 n）之一[a-n]返回字母顺序 a 和 n 之间的任意小写字符匹配项[^arn]返回除 a、r 和 n 之外的任意字符的匹配项[0123]返回存在任何指定数字（0、1、2 或 3）的匹配项[0-9]返回 0 与 9 之间任意数字的匹配[0-5][0-9]返回介于 0 到 9 之间的任何数字的匹配项[a-zA-Z]返回字母顺序 a 和 z 之间的任何字符的匹配，小写或大写[+]在集合中，+, *, ., `, (), $, &#123;&#125;没有特殊含义，因此[+]表示返回字符串中任何+` 字符的匹配项正则函数findall() 函数返回包含所有匹配项的列表。search() 函数搜索字符串中的匹配项，如果存在匹配则返回 Match 对象。如果有多个匹配，则仅返回首个匹配项。sub() 函数把匹配替换为您选择的文本。模块与脚本✅ 模块（module）和脚本（script）的区别特性模块（Module）脚本（Script）定义一个可以被导入和复用的 Python 文件一个可以直接运行的 Python 文件用途提供功能、函数、类供其他代码调用执行某个特定任务或程序流程入口点没有主入口，供其他文件使用通常有 if __name__ == &#39;__main__&#39;导入方式import mymodule不能被别的脚本导入（如果它只是用来执行）重复使用性高，可复用通常低，更专注执行任务举例math.py, utils.py（定义函数供别人用）Peewee ORM 示例模型转字典pythonclass BaseModel(Model):    def to_dict(self):        return self.__dict__[&#39;__data__&#39;]  # 直接访问对象内部字典属性    def to_human_model_dict(self, only_primary_with: list = None):        model_dict = self.__dict__[&#39;__data__&#39;]        if not only_primary_with:            return &#123;remove_field_name_prefix(k): v for k, v in model_dict.items()&#125;        human_model_dict = &#123;&#125;        for k in self._meta.primary_key.field_names:            human_model_dict[remove_field_name_prefix(k)] = model_dict[k]        for k in only_primary_with:            human_model_dict[k] = model_dict[f&#39;f_&#123;k&#125;&#39;]        return human_model_dict    @property    def meta(self) -&gt; Metadata:        return self._meta    @classmethod    def get_primary_keys_name(cls):        return cls._meta.primary_key.field_names if isinstance(cls._meta.primary_key, CompositeKey) else [cls._meta.primary_key.name]    @classmethod    def getter_by(cls, attr):        return operator.attrgetter(attr)(cls)    @classmethod    def query(cls, reverse=None, order_by=None, **kwargs):        filters = []        for f_n, f_v in kwargs.items():            attr_name = &#39;%s&#39; % f_n            if not hasattr(cls, attr_name) or f_v is None:                continue            if type(f_v) in &#123;list, set&#125;:                f_v = list(f_v)                if is_continuous_field(type(getattr(cls, attr_name))):                    if len(f_v) == 2:                        for i, v in enumerate(f_v):                            if isinstance(v, str) and f_n in auto_date_timestamp_field():                                f_v[i] = utils.date_string_to_timestamp(v)                        lt_value = f_v[0]                        gt_value = f_v[1]                        if lt_value is not None and gt_value is not None:                            filters.append(cls.getter_by(attr_name).between(lt_value, gt_value))                        elif lt_value is not None:                            filters.append(operator.attrgetter(attr_name)(cls) &gt;= lt_value)                        elif gt_value is not None:                            filters.append(operator.attrgetter(attr_name)(cls) &lt;= gt_value)                else:                    filters.append(operator.attrgetter(attr_name)(cls) &lt;&lt; f_v)            else:                filters.append(operator.attrgetter(attr_name)(cls) == f_v)        if filters:            query_records = cls.select().where(*filters)            if reverse is not None:                if not order_by or not hasattr(cls, f&quot;&#123;order_by&#125;&quot;):                    order_by = &quot;create_time&quot;                if reverse is True:                    query_records = query_records.order_by(cls.getter_by(f&quot;&#123;order_by&#125;&quot;).desc())                elif reverse is False:                    query_records = query_records.order_by(cls.getter_by(f&quot;&#123;order_by&#125;&quot;).asc())            return [query_record for query_record in query_records]        else:            return []Peewee 基础Peewee 是一个轻量级的 ORM（对象关系映射）框架，ORM 的核心思想就是用 Python 类来表示数据库表。在定义模型类时，Meta 就是 Peewee 提供的一种机制，告诉 ORM 框架这个类在数据库中应该怎么表现。过滤器.startswith(prefix)：搜索以前缀开头的值.endswith(suffix)：搜索以后缀结尾的值.regexp(exp)：正则表达式匹配（区分大小写）.iregexp(exp)：正则表达式匹配（不区分大小写）.cast(type)：将列的值转换为给定类型Utils 工具目录在一个项目里，utils（utilities） 文件或目录并不是官方规范，而是约定俗成的“工具箱”。它的核心定位是：放置那些与业务逻辑解耦、可在多处复用、与框架/库无关的通用代码。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成器</title>
    <link href="/2025/08/13/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2025/08/13/%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="生成器函数和生成器对象的区别"><a href="#生成器函数和生成器对象的区别" class="headerlink" title="生成器函数和生成器对象的区别"></a>生成器函数和生成器对象的区别</h2><p>生成器函数被调用时，并不会立即执行函数体，而是返回一个生成器对象。只有在<strong>迭代生成器对象</strong>时，代码才会一步步执行。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator started&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yielded 1, continue...&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yielded 2, finish&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling gen()...&quot;</span>)<br>g = gen()  <span class="hljs-comment"># 创建生成器对象，不执行函数体</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator object created:&quot;</span>, g)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g)...&quot;</span>)<br>val1 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行到第一个 yield</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received:&quot;</span>, val1)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g) again...&quot;</span>)<br>val2 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行到第二个 yield</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received:&quot;</span>, val2)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g) final time...&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    val3 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行剩余代码，结束</span><br><span class="hljs-keyword">except</span> StopIteration:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator exhausted&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done.&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行结果<br>Calling gen()…<br>Generator object created: &lt;generator object gen at 0x…&gt;<br>Calling next(g)…<br>Generator started<br>Received: 1<br>Calling next(g) again…<br>Yielded 1, continue…<br>Received: 2<br>Calling next(g) final time…<br>Yielded 2, finish<br>Generator exhausted<br>Done.</p><p>术语解释<br>迭代器驱动<br>迭代器不会自己执行，需要外部调用 next() 或使用 for 循环来“驱动”它。</p><p>每次调用 next()，代码会从上一次 yield 后的位置继续运行，直到遇到下一个 yield 或结束。</p><p>next()<br>Python 内置函数，等价于调用迭代器的 <strong>next</strong>() 方法。</p><p>功能：运行生成器到下一个 yield，返回其后的值。</p><p>当没有更多值时，会抛出 StopIteration 异常。</p><p>callable(obj)<br>Python 内置函数，用于判断对象 obj 是否可调用。</p><p>可调用对象包括：函数、方法，或者实现了 <strong>call</strong>() 方法的类实例。</p><p>callable(res) 的应用场景<br>在某些代码（如 res &#x3D; self._run()）中：<br>场景res 类型callable(res)处理方式<br>普通组件字符串、字典、DataFrame…False直接记录耗时<br>流式组件生成器函数、functools.partialTrue再调用一次获取生成器，开始迭代</p><p>为什么不能立即记录耗时？<br>如果 res 是生成器函数，还没开始迭代就记录结束时间，会导致耗时被严重低估，无法反映真实执行时间。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/./%E5%A3%81%E7%BA%B8.jpg" alt="壁纸"></p><img src="/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E5%A3%81%E7%BA%B8.jpg" class="">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/01/hello-world/"/>
    <url>/2025/08/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>爬虫</title>
    <link href="/2025/08/01/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0_hexo/"/>
    <url>/2025/08/01/%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0_hexo/</url>
    
    <content type="html"><![CDATA[<p><em><strong>爬虫</strong></em>*<br>发送 HTTP 请求：爬虫通过 HTTP 请求从目标网站获取 HTML 页面，常用的库包括 requests。<br>解析 HTML 内容：获取 HTML 页面后，爬虫需要解析内容并提取数据，常用的库有 BeautifulSoup、lxml、Scrapy 等。<br>提取数据：通过定位 HTML 元素（如标签、属性、类名等）来提取所需的数据。<br>存储数据：将提取的数据存储到数据库、CSV 文件、JSON 文件等格式中，以便后续使用或分析。</p><p>from bs4 import BeautifulSoup<br>    # 读取示例 HTML 文件<br>html &#x3D; “””</p><html>    <head>        <title>Example Page</title>    </head>    <body>        <h1>Hello, World!</h1>    </body></html>"""    # 创建 BeautifulSoup 对象，并指定解析器为 lxmlsoup = BeautifulSoup(html, 'lxml')    # 找到第一个 h1 标签，并输出其文本内容h1 = soup.find('h1')print(h1.text)<h3 id="可以使用-BeautifulSoup-对象-soup-来提取其中的数据。例如，要获取文档标题，可以使用-title-属性"><a href="#可以使用-BeautifulSoup-对象-soup-来提取其中的数据。例如，要获取文档标题，可以使用-title-属性" class="headerlink" title="可以使用 BeautifulSoup 对象 soup 来提取其中的数据。例如，要获取文档标题，可以使用 title 属性"></a>可以使用 BeautifulSoup 对象 soup 来提取其中的数据。例如，要获取文档标题，可以使用 title 属性</h3><p>print(soup.title)<br>    # <title>Example Page</title>   </p><h3 id="要获取标签的文本内容，可以使用-text-属性或-string-属性："><a href="#要获取标签的文本内容，可以使用-text-属性或-string-属性：" class="headerlink" title="要获取标签的文本内容，可以使用 text 属性或 string 属性："></a>要获取标签的文本内容，可以使用 text 属性或 string 属性：</h3><p>print(soup.h1.text)</p><h3 id="要获取标签的属性，可以使用-attrs-属性："><a href="#要获取标签的属性，可以使用-attrs-属性：" class="headerlink" title="要获取标签的属性，可以使用 attrs 属性："></a>要获取标签的属性，可以使用 attrs 属性：</h3><p>print(soup.a.attrs[‘href’])</p><h3 id="要获取所有符合条件的标签，可以使用-find-all-方法："><a href="#要获取所有符合条件的标签，可以使用-find-all-方法：" class="headerlink" title="要获取所有符合条件的标签，可以使用 find_all 方法："></a>要获取所有符合条件的标签，可以使用 find_all 方法：</h3><h1 id="获取所有-p-标签"><a href="#获取所有-p-标签" class="headerlink" title="获取所有 p 标签"></a>获取所有 p 标签</h1><p>ps &#x3D; soup.find_all(‘p’)<br>for p in ps:<br>    print(p.text)<br>    #    This is the first paragraph.<br>    # This is the second paragraph.<br>    # 获取 class 为 “second” 的 p 标签<br>    p &#x3D; soup.find(‘p’, {‘class’: ‘second’})<br>print(p.text)<br>    # This is the second paragraph.</p><h3 id="BeautifulSoup-支持使用-CSS-选择器来查找标签，可以使用-select-方法"><a href="#BeautifulSoup-支持使用-CSS-选择器来查找标签，可以使用-select-方法" class="headerlink" title="BeautifulSoup 支持使用 CSS 选择器来查找标签，可以使用 select 方法"></a>BeautifulSoup 支持使用 CSS 选择器来查找标签，可以使用 select 方法</h3>]]></content>
    
    
    <categories>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask</title>
    <link href="/2025/08/01/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_hexo_cleaned/"/>
    <url>/2025/08/01/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_hexo_cleaned/</url>
    
    <content type="html"><![CDATA[<p><strong>Flask</strong></p><h1 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、 简介"></a>一、 简介</h1><p>Flask是一个非常小的PythonWeb框架，被称为微型框架；只提供了一个稳健的核心，其他功能全部是通过扩展实现的</p><h1 id="二、-概要"><a href="#二、-概要" class="headerlink" title="二、 概要"></a>二、 概要</h1><p>1）安装： pip install flask<br>2）组成：WSGI系统、调试、路由<br>3）模板引擎：Jinja2（由Flask核心开发者人员开发）<br>4）使用到装饰器：以@开头的代码方法</p><h1 id="三、-知识点（附代码）"><a href="#三、-知识点（附代码）" class="headerlink" title="三、 知识点（附代码）"></a>三、 知识点（附代码）</h1><h2 id="1-Flask基础入门"><a href="#1-Flask基础入门" class="headerlink" title="1. Flask基础入门"></a>1. Flask基础入门</h2><h3 id="1）路由route的创建："><a href="#1）路由route的创建：" class="headerlink" title="1）路由route的创建："></a>1）路由route的创建：</h3><p>methods&#x3D;[]支持的请求方式参数设置，不设置默认为GET<br>  @app.route(‘&#x2F;login’, methods&#x3D;[‘GET’, ‘PoSt’])  # 请求参数设置不区分大小写，源码中自动进行了upper<br>  def login():  ✅ 访问 &#x2F;login 这个地址时：<br>🔹 如果是 GET 请求（比如你在浏览器地址栏输入 &#x2F;login）就返回一个 login.html 页面（登录表单页面）<br>      if request.method &#x3D;&#x3D; ‘GET’:<br>          return render_template(‘login.html’)<br>    🔹 如果是 POST 请求（比如你在表单里点“登录”按钮提交）：从表单里取出两个字段：<br>      elif request.method &#x3D;&#x3D; ‘POST’:<br>          username &#x3D; request.form.get(‘username’)<br>          pwd &#x3D; request.form.get(‘pwd’)<br>          🔹如果用户名是 yang 且密码是 123456：<br>          if username &#x3D;&#x3D; ‘yang’ and pwd &#x3D;&#x3D; ‘123456’:<br>          🔹把用户名存到 session（表示用户已登录）<br>              session[‘username’] &#x3D; username<br>              return ‘login successed 200  ok!’<br>          else:<br>             return ‘login failed!!!’</p><p>🔹视图函数：✅ 一句话解释<br>视图函数（view function）就是 Flask 中“处理某个 URL 请求并返回响应”的 Python 函数。它相当于 MVC 里的 C（Controller）+V（View） 的结合体：接收请求 → 做业务逻辑 → 把结果（HTML&#x2F;JSON&#x2F;文本）返回</p><p>url_map.convertersFlask 的转换器注册表，把自己的转换器“挂”进去<br>&lt;re(…)&gt;路由里的尖括号表达式，用来捕获并转换 URL 片段<br>✅ 第 2 步：我们想干啥？让路由支持正则表达式匹配！<br>✅ 第 3 步：写个“手机验证”转换器<br>class RegexConverter(BaseConverter):<br>    def <strong>init</strong>(self, url_map, regex):<br>        super().<strong>init</strong>(url_map)   # 先让父类干活<br>        self.regex &#x3D; regex          # 把我们传的正则保存起来<br>    def to_python(self, value):<br>        print(‘to_python被调用，拿到值：’, value)<br>        return value                # 原样返回即可<br><strong>init</strong>：Flask 会把路由里写的正则自动塞给你（regex 参数）。<br>to_python：Flask 每捕获一次，就调用它，你可以做额外处理（这里只是打印）。<br>✅ 第 4 步：把转换器“挂”到 Flask 上<br>app.url_map.converters[‘re’] &#x3D; RegexConverter    app你创建的 Flask 应用<br>现在可以用 &lt;re(…)&gt; 这种语法了！<br>✅ 第 5 步：用转换器写路由<br>@app.route(“&#x2F;index&#x2F;&lt;re(‘1\d{10}’):value&gt;”)<br>def index(value):<br>    print(‘视图函数收到的 value：’, value)<br>    return “Hello World!<br>‘1\d{10}’ 是正则：以 1 开头、后面 10 位数字 → 11 位手机号。<br>&lt;re(…)&gt; 里的 re 就是刚才注册的转换器。<br>捕获到的字符串会经 to_python 处理后，传给 index(value)。</p><h3 id="2）endpoint的作用"><a href="#2）endpoint的作用" class="headerlink" title="2）endpoint的作用"></a>2）endpoint的作用</h3><p>🔹说明：每个app中都存在一个url_map，这个url_map中包含了url到endpoint的映射；<br>🔹作用：当request请求传来一个url的时候，会在url_map中先通过rule找到endpoint，然后再在view_functions中根据endpoint再找到对应的视图函数view_func</p><p>自定义装饰器装饰多个视图函数时，如果在路由中没有指定唯一的endpoint,<br> 则所有装饰的视图函数返回的都是装饰器中的inner函数，同名因此会报错<br> def decorator(f):<br>    def inner(*args, **kwargs):<br>        return f(*args, **kwargs)<br>    return inner          # ← 所有被装饰的函数最终都叫 inner</p><p>@app.route(‘&#x2F;a’)<br>@decorator<br>def a():                  # 实际注册的是 inner<br>    return ‘a’</p><p>@app.route(‘&#x2F;b’)<br>@decorator<br>def b():                  # 又注册一个 inner → 同名冲突！<br>    return ‘b’</p><h3 id="3）request对象的使用"><a href="#3）request对象的使用" class="headerlink" title="3）request对象的使用"></a>3）request对象的使用</h3><p>render_template()：可以用于呈现一个我们编写的html文件模板</p><h3 id="4）请求钩子before-after-request"><a href="#4）请求钩子before-after-request" class="headerlink" title="4）请求钩子before&#x2F;after_request"></a>4）请求钩子before&#x2F;after_request</h3><p>🔹想要在正常执行的代码的前、中、后时期，强行执行一段我们想要执行的功能代码，便要用到钩子函数——用特定装饰器装饰的函数。<br>1.before_request：在每一次请求之前调用；执行顺序是先绑定的先执行；<br>2.after_request：每一次请求之后都会调用；执行的顺序是先绑定的后执行；</p><h3 id="5）redirect重定向"><a href="#5）redirect重定向" class="headerlink" title="5）redirect重定向"></a>5）redirect重定向</h3><p>🔹在flask 中，重定向是通过flask.redirect(location, code&#x3D;302)这个函数来实现的，location表示需要重定向的url, 应该配合url_for函数来使用， code表示采用哪个重定向，默认是302，即临时性重定向, 可以修改为301来实现永性重定向；</p><h3 id="6）返回json数据给前端"><a href="#6）返回json数据给前端" class="headerlink" title="6）返回json数据给前端"></a>6）返回json数据给前端</h3><p>1.使用：make_response方法和json库共同完成<br>response &#x3D; make_response(json.dumps(data,ensure_ascii&#x3D;False))<br>   response.mimetype &#x3D; ‘application&#x2F;json’<br>   return response<br>2.使用：jsonify库实现，减少代码行数</p><h3 id="7）abort函数的使用"><a href="#7）abort函数的使用" class="headerlink" title="7）abort函数的使用"></a>7）abort函数的使用</h3><p>🔹使用类似于python中的raise函数，可以在需要退出请求的地方抛出错误，并结束该请求；可以使用errorhandler()装饰器来进行异常的捕获与自定义：</p><h3 id="8）url-for实现反转"><a href="#8）url-for实现反转" class="headerlink" title="8）url_for实现反转"></a>8）url_for实现反转</h3><p>🔹视图函数 → \rightarrow →url；</p><h2 id="2-Flask高级视图"><a href="#2-Flask高级视图" class="headerlink" title="2. Flask高级视图"></a>2. Flask高级视图</h2><h3 id="1）add-url-rule的初登场"><a href="#1）add-url-rule的初登场" class="headerlink" title="1）add_url_rule的初登场"></a>1）add_url_rule的初登场</h3><p>实现url与视图函数的绑定，除了使用路由装饰器@app.route,  add_url_rule(rule,endpoint&#x3D;None,view_func&#x3D;None)</p><h3 id="2）类视图的引入"><a href="#2）类视图的引入" class="headerlink" title="2）类视图的引入"></a>2）类视图的引入</h3><p>🔹 定义的视图都是通过函数来实现的,所以称之为视图函数,但其实视图还可以由类来实现，即类视图；<br>🔹标准类视图：<br>        定义时需要继承flask的views.View这一基类;<br>        每个类视图内必须包含一个dispatch_request方法，每当类视图接收到请求时都会执行该方法，返回值的设定和视图函数相同；<br>        视图函数可以通过@app.route和app.add_url_rule来进行注册（映射到url），但类视图只能通过app.add_url_rule来注册，注册时view_func不能直接使用类名，需要调用基类中的as_view方法来为自己取一个“视图函数名”<br>from flask import Flask,render_template,views<br>app &#x3D; Flask(<strong>name</strong>)</p><h1 id="定义父视图类继承基类View"><a href="#定义父视图类继承基类View" class="headerlink" title="定义父视图类继承基类View"></a>定义父视图类继承基类View</h1><p>class Ads(views.View):<br>    def <strong>init</strong>(self):<br>        super(Ads, self).<strong>init</strong>()<br>        # 实例属性<br>        self.context&#x3D;{<br>            ‘ads’:’这是对联广告！’<br>        }</p><h1 id="定义子视图类继承父类并实现工程"><a href="#定义子视图类继承父类并实现工程" class="headerlink" title="定义子视图类继承父类并实现工程"></a>定义子视图类继承父类并实现工程</h1><p>class Index(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;index.html’,**self.context)<br>class Login(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;login.html’,**self.context)<br>class Register(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;register.html’,**self.context)</p><h1 id="注册我们创建的类视图-as-view给类视图起名"><a href="#注册我们创建的类视图-as-view给类视图起名" class="headerlink" title="注册我们创建的类视图,as_view给类视图起名"></a>注册我们创建的类视图,as_view给类视图起名</h1><p>app.add_url_rule(rule&#x3D;’&#x2F;‘,endpoint&#x3D;’index’,view_func&#x3D;Index.as_view(‘index’))<br>app.add_url_rule(rule&#x3D;’&#x2F;login&#x2F;‘,endpoint&#x3D;’login’,view_func&#x3D;Login.as_view(‘login’))<br>app.add_url_rule(rule&#x3D;’&#x2F;register&#x2F;‘,endpoint&#x3D;’register’,view_func&#x3D;Register.as_view(‘register’))</p><p>if <strong>name</strong>&#x3D;&#x3D;’<strong>main</strong>‘:<br>    print(app.view_functions)<br>    app.run(debug&#x3D;True)</p><h3 id="3）装饰器的自定义与使用"><a href="#3）装饰器的自定义与使用" class="headerlink" title="3）装饰器的自定义与使用"></a>3）装饰器的自定义与使用</h3><h3 id="4）蓝图的使用"><a href="#4）蓝图的使用" class="headerlink" title="4）蓝图的使用"></a>4）蓝图的使用</h3><p>当接收到请求时，Flask会遍历Flask对象下（已注册）的各蓝图对象，比对蓝图对象中记录的url，比对成功则映射到该url绑定的视图函数并返回响应<br>📌 举个例子（不用蓝图 vs 用蓝图）<br>❌ 不用蓝图：所有代码写在一个文件<br>from flask import Flask<br>app &#x3D; Flask(<strong>name</strong>)<br>@app.route(‘&#x2F;‘)<br>def home():<br>    return ‘Home’<br>@app.route(‘&#x2F;admin’)<br>def admin():<br>    return ‘Admin’<br>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    app.run()<br>✅ 用蓝图：按模块拆分</p><h1 id="文件：admin-routes-py"><a href="#文件：admin-routes-py" class="headerlink" title="文件：admin&#x2F;routes.py"></a>文件：admin&#x2F;routes.py</h1><p>from flask import Blueprint<br>admin_bp &#x3D; Blueprint(‘admin’, <strong>name</strong>, url_prefix&#x3D;’&#x2F;admin’)</p><p>@admin_bp.route(‘&#x2F;‘)<br>def admin_home():<br>    return ‘Admin Home’</p><h1 id="文件：main-py"><a href="#文件：main-py" class="headerlink" title="文件：main.py"></a>文件：main.py</h1><p>from flask import Flask<br>from admin.routes import admin_bp</p><p>app &#x3D; Flask(<strong>name</strong>)<br>app.register_blueprint(admin_bp)</p><p>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    app.run()</p><h3 id="5）url-prefix设置蓝图前缀"><a href="#5）url-prefix设置蓝图前缀" class="headerlink" title="5）url_prefix设置蓝图前缀"></a>5）url_prefix设置蓝图前缀</h3><p>蓝图对象定义时添加，为当前蓝图下的所有视图函数添加统一的前缀<br>new_list &#x3D; Blueprint(‘news’,<strong>name</strong>,url_prefix&#x3D;’&#x2F;index’)<br>@new_list.route(‘&#x2F;news’)<br>def new():<br>    return ‘这是新闻模块！’<br>此外，在主路由中注册蓝图时也可以为蓝图添加前缀，并且此次添加会覆写蓝图对象创建时添加的前缀；<br>如下例中，注册后的新闻模块的url又变为了”&#x2F;test&#x2F;news”：<br>app.register_blueprint(news.new_list,url_prefix&#x3D;’&#x2F;test’)</p><h3 id="6）subdomain设置蓝图子域名"><a href="#6）subdomain设置蓝图子域名" class="headerlink" title="6）subdomain设置蓝图子域名"></a>6）subdomain设置蓝图子域名</h3><p>通过修改Flask对象的配置,为我们的网站设置域名,用字段为’SERVER_NAME’,为该域名指定端口号：</p><h1 id="当前网站域名设置为example-com，端口号为5000"><a href="#当前网站域名设置为example-com，端口号为5000" class="headerlink" title="当前网站域名设置为example.com，端口号为5000"></a>当前网站域名设置为example.com，端口号为5000</h1><pre><code class="hljs">app.config[&#39;SERVER_NAME&#39;] = &#39;example.com:5000&#39;</code></pre><p>修改位于 C:\Windows\System32\drivers\etc 下的域名重定向文件 hosts<br>📌设置子域名:在蓝图文件admin.py中注册蓝图对象，添加subdomain&#x3D;’admin’即为该蓝图设置子域名admin；<br>再在hosts文件中添加记录：10.240.142.216 admin.example<br>📌再在hosts文件中添加记录：10.240.142.216 admin.example.com后，我们便可以通过域名：<a href="http://admin.example.com:5000/ad%E6%9D%A5%E8%AE%BF%E9%97%AE%E8%AF%A5%E8%93%9D%E5%9B%BE%EF%BC%88%E4%B8%8B%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%9C%A8%E4%B8%8A%E4%B8%80%E7%BA%A7%E5%B7%A6%E4%BE%A7%EF%BC%89%EF%BC%9B">http://admin.example.com:5000/ad来访问该蓝图（下一级域名在上一级左侧）；</a><br>        from flask import Blueprint<br>        bp &#x3D; Blueprint(‘admin’,<strong>name</strong>,subdomain &#x3D; ‘admin’)<br>        @bp.route(‘&#x2F;ad’)<br>        def admin():<br>            return ‘Admin Page’</p><h2 id="3-jinja2模板引擎"><a href="#3-jinja2模板引擎" class="headerlink" title="3.jinja2模板引擎"></a>3.jinja2模板引擎</h2><h3 id="1）模板的导入与使用"><a href="#1）模板的导入与使用" class="headerlink" title="1）模板的导入与使用"></a>1）模板的导入与使用</h3><pre><code class="hljs">Flask通过render_template来实现模板的渲染。要导入from flask     import rander_template，模板中注释需放在中</code></pre><h3 id="2）模板中的控制语句"><a href="#2）模板中的控制语句" class="headerlink" title="2）模板中的控制语句"></a>2）模板中的控制语句</h3><pre><code class="hljs">jinja2模板引擎中也可使用if和for控制语句，但是语句需要放置在&#123;% %&#125;中；if条件判断语句必须包含结束标签&#123;% endif %&#125;，其他部分与python中类似，可以与比较运算符&gt; &gt;= &lt; &lt;= == !=结合使用，或与逻辑运算符and,or,not,()结合使用；</code></pre><h3 id="3）过滤器的使用与自定义"><a href="#3）过滤器的使用与自定义" class="headerlink" title="3）过滤器的使用与自定义"></a>3）过滤器的使用与自定义</h3><p>&lt;— 自定义过滤器 —&gt;<br>def list_step(li):<br>    # 返回列表，步长为2<br>    return li[::2]</p><pre><code class="hljs"># 注册模板过滤器（filter）# 参数1为该过滤器调用的函数参数2为在前端中调用该过滤器使用的名称</code></pre><p>app.add_template_filter(list_step,’li2’)</p><p>可以在前端模板内  <!-- 原为 Jinja2 过滤器语法，已移除过滤器部分 -->的” | “后使用；</p><h2 id="4-Flask数据交互"><a href="#4-Flask数据交互" class="headerlink" title="4.Flask数据交互"></a>4.Flask数据交互</h2><h3 id="4）Cookie的使用"><a href="#4）Cookie的使用" class="headerlink" title="4）Cookie的使用"></a>4）Cookie的使用</h3><p>📌 在网站中，http请求是呈无序状态的<br>无序状态是指协议对于事务处理没有记忆能力，同一个服务器上你新打开的网页和之前打开的网页之间没有任何联系，你的当前请求和上一次请求究竟是不是一个用户发出的，服务器也无从得知；</p><p>Cookie一般通过Response对象的set_cookie()方法来设置<br>    # 前两个参数必须设置，后续参数则为可选参数<br>set_cookie(key,value[,max_age,expires,path,domain,secure,httponly,samesite])<br>key(或name)必需项，规定cookie的名称，字符串<br>value必需项，规定cookie的内容，字符串</p><p>除此之外，我们也可以通过修改响应对象Response的表单头headers来设置cookie：<br>@app.route(‘&#x2F;h’)<br>def set_cookie_h():<br>    resp &#x3D; Response(“设置Cookie！”)<br>    # 通过添加表头的键值对来实现cookie设置<br>    # 第一项为key&#x3D;value，需要同时设置这两个参数，后续项则用分号分隔<br>    resp.headers[‘Set-Cookie’] &#x3D; “ testname &#x3D; lisi; Expires &#x3D; SUN,01-Nov-2021 05:10:12 GMT; Max-Age&#x3D;3600; path&#x3D;&#x2F; “<br>    return resp</p>]]></content>
    
    
    <categories>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
