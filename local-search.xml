<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/08/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/FastApi/"/>
    <url>/2025/08/26/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/FastApi/</url>
    
    <content type="html"><![CDATA[<h1 id="FastAPI"><a href="#FastAPI" class="headerlink" title="FastAPI"></a>FastAPI</h1><p><code>FastAPI 是一个用 Python 写 RESTful API 的“现代化、飞快的框架”，帮你几行代码就搭好一个高性能的 Web 接口。</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br>app = FastAPI()<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">root</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="并发-async-await"><a href="#并发-async-await" class="headerlink" title="并发 async &#x2F; await"></a>并发 async &#x2F; await</h1><ul><li>如果你正在使用第三方库，它们会告诉你使用 await 关键字来调用它们，就像这样：<br><code>results = await some_library()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_results</span>():<br>    results = <span class="hljs-keyword">await</span> some_library()<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><p><strong>你只能在被 async def 创建的函数内使用 await</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>study</title>
    <link href="/2025/08/21/study/"/>
    <url>/2025/08/21/study/</url>
    
    <content type="html"><![CDATA[<h1 id="RAGFLOW"><a href="#RAGFLOW" class="headerlink" title="RAGFLOW"></a>RAGFLOW</h1><h2 id="什么是RAGFLOW"><a href="#什么是RAGFLOW" class="headerlink" title="什么是RAGFLOW"></a>什么是RAGFLOW</h2><p><a href="https://ragflow.io/">RAGFlow</a> 是一个基于深度文档理解的开源 RAG（检索增强生成）引擎。它为任何规模的企业提供了简化的 RAG 工作流程，结合了 LLM（大型语言模型）提供真实的问答功能，并以来自各种复杂格式的有根据的引文为后盾。</p><p><strong>SDK</strong> 是 <strong>Software Development Kit</strong>（<strong>软件开发工具包</strong>）的缩写，中文通常称“开发工具包”，用于开发特定平台或软件应用的工具集合。</p><h3 id="Integrations"><a href="#Integrations" class="headerlink" title="Integrations"></a>Integrations</h3><blockquote><p><code>integrations</code> 目录中 RAGFlow 与 ChatGPT-on-WeChat 对接。</p></blockquote><h3 id="NLTK"><a href="#NLTK" class="headerlink" title="NLTK"></a>NLTK</h3><blockquote><p>NLTK 是 Natural Language Toolkit（自然语言处理工具包）</p></blockquote><ul><li><strong>文本分词</strong>（tokenization）</li><li><strong>词性标注</strong>（POS tagging）</li><li><strong>命名实体识别</strong>（NER）</li><li><strong>句法分析</strong>（parsing）</li></ul><h3 id="uv-lock-Python项目的依赖组件"><a href="#uv-lock-Python项目的依赖组件" class="headerlink" title="uv.lock Python项目的依赖组件"></a>uv.lock Python项目的依赖组件</h3><p><a href="https://zhuanlan.zhihu.com/p/1893299536002261393%20%20ragFlow">https://zhuanlan.zhihu.com/p/1893299536002261393 RAGFlow</a> 项目结构</p><p><strong>Werkzeug</strong>：Werkzeug 是一个纯 Python 编写的 WSGI 工具库，由 Flask 的核心开发者（Pallets 团队）维护。它的定位是：“HTTP 和 WSGI 的瑞士军刀”，提供构建 Web 框架&#x2F;服务器所需的各种底层功能，但本身不是一个完整的 Web 框架。</p><p>SIGINT：信息获取，SIGTERM：关闭。</p><p>WSGI：的全称是 <strong>Web Server Gateway Interface</strong>（Web 服务器网关接口）。一句话概括：<strong>它是 Python Web 应用（或框架）与 Web 服务器之间的“通用翻译官”</strong>。</p><p><strong>Node.js（简称 node）</strong> 是让你在浏览器之外也能运行 JavaScript 的“发动机”。运行 JavaScript 代码不用浏览器，直接在命令行。</p><p><strong>JavaScript</strong> 是让网页从“静态海报”变成“交互应用”的魔法语言，现在更是前后端通吃的万能胶水。</p><p><strong>构造函数</strong>：在 Python 中，构造函数的名字总是 <code>__init__</code>，是<strong>在创建对象时自动调用的特殊方法</strong>，用于初始化对象的状态（属性）。</p><p><code>dir()</code> 是 Python 的一个内置函数，作用是<strong>列出对象的属性和方法名称</strong>。</p><p><code>setattr</code> 是 Python 内置函数，用于<strong>给对象动态地设置属性值</strong>。<code>setattr(object, name, value)</code></p><p><code>__dict__</code>：实例属性，你创建一个类的实例后，实例的属性就会被存放在 <code>__dict__</code> 中。</p><p><strong>双下划线</strong>（dunder，double underscore）的函数，在 Python 里统称为**“魔术方法 &#x2F; 特殊方法”**。它们不让你直接调用，而是由 <strong>Python 解释器在特定场景下自动触发</strong>，用来定义对象的核心行为。</p><p><strong>三引号</strong>：就是“多行字符串”，至于拿来干什么，取决于它放在哪里。</p><ul><li><strong>当放在模块、类、函数或方法的第一行</strong> —— 它就是文档字符串（docstring），通过 <code>help(func)</code> 或 <code>func.__doc__</code> 能拿到这段说明。</li><li><strong>当放在赋值语句右边</strong> —— 它就是普通字符串，只是跨行写起来更方便。</li><li><strong>当放在代码里但既不赋值也不当 docstring</strong> —— 它就只是被忽略的字符串常量。</li></ul><hr><h2 id="JSON-处理"><a href="#JSON-处理" class="headerlink" title="JSON 处理"></a>JSON 处理</h2><p>✅ <code>json.dumps(obj)</code>：<strong>Python → JSON 字符串</strong><br>✅ <code>json.loads(json_str)</code>：<strong>JSON 字符串 → Python 对象（通常是字典）</strong>。</p><hr><h2 id="Python-命名约定"><a href="#Python-命名约定" class="headerlink" title="Python 命名约定"></a>Python 命名约定</h2><p>在 Python 中，变量名前加下划线（例如 <code>_param</code>）<strong>是一种约定，表示这是一个“内部变量”或“私有属性”</strong>。</p><p>Python 函数在调用时必须已经先定义在调用上方，函数内调用不分先后。</p><hr><h2 id="集合与生成器"><a href="#集合与生成器" class="headerlink" title="集合与生成器"></a>集合与生成器</h2><p>🟢 <code>set([])</code> 是什么意思？创建空集合。</p><p><code>yield</code> 是一个用于**生成器函数（generator function）**的关键字，可以让函数一次返回一个值，同时记住上次执行的位置。边执行边产出。“暂停一下，先给你一条消息，等你处理完了我再继续往下走。”</p><h3 id="🧠-yield-与-return-的区别"><a href="#🧠-yield-与-return-的区别" class="headerlink" title="🧠 yield 与 return 的区别"></a>🧠 yield 与 return 的区别</h3><table><thead><tr><th><strong>比较项</strong></th><th><strong>return</strong></th><th><strong>yield</strong></th></tr></thead><tbody><tr><td>函数类型</td><td>普通函数</td><td>生成器函数（返回生成器对象）</td></tr><tr><td>返回行为</td><td>一次性返回，函数结束</td><td>暂停函数，保留状态，下次继续</td></tr><tr><td>可多次输出？</td><td>否，一次</td><td>是，多次（使用 for 或 next()）</td></tr><tr><td>内存效率</td><td>不高（返回整个列表等）</td><td>高效（按需生成，每次一个值）</td></tr></tbody></table><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>✅ 一句话解释：<code>try-except-raise</code> 用于：</p><ul><li><strong>捕获异常</strong>（<code>try</code>）：可能出错的代码</li><li><strong>做出处理</strong>（<code>except</code>）：先处理一下，比如打印日志</li><li><strong>重新抛出异常</strong>（<code>raise</code>），让它传给外部或中止程序</li></ul><hr><h2 id="切片与装饰器"><a href="#切片与装饰器" class="headerlink" title="切片与装饰器"></a>切片与装饰器</h2><ul><li><code>[::-1]</code> 是 Python 的切片语法，用于反转序列：<ul><li>第一个 <code>:</code> 表示从开始到结束</li><li>第二个 <code>:</code> 后是步长（step），<code>-1</code> 表示从后向前遍历</li></ul></li></ul><p><code>@property</code> 装饰器将方法伪装成属性。用户像操作属性一样使用（无需显式调用方法）。</p><p><code>@</code> 是<strong>装饰器（Decorator）语法</strong>的标志，用于<strong>包装函数、方法或类</strong>，在不改变其原始定义的前提下，增强或修改其行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">pass</span><br>等价于：<br><br>python<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">pass</span><br>func = decorator(func)<br></code></pre></td></tr></table></figure><p>装饰器（Decorator）就是一个“包装函数”，在不修改原函数代码的前提下，给它加功能。</p><p>✅ 举个生活例子：<br>你点了一杯奶茶，店员在封口前又给你加了层奶盖 —— 这就是“装饰”：奶茶（原函数）没变，但多了奶盖（新功能）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">login_required</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> session.get(<span class="hljs-string">&#x27;username&#x27;</span>):<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)  <span class="hljs-comment"># 用户已登录，正常执行原函数</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;请先登录！&#x27;</span>  <span class="hljs-comment"># 未登录，拦截请求</span><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/profile&#x27;</span></span>)</span><br><span class="hljs-meta">@login_required  </span><span class="hljs-comment"># 👈 装饰器：给 /profile 加“登录检查”功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profile</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;个人中心页面&#x27;</span><br></code></pre></td></tr></table></figure><p>req &#x3D; request.json 是 Flask 中获取请求体中的 JSON 数据的一种方式。</p><p>nonlocal 是 Python 中的一个关键字，用于在嵌套函数中声明一个变量不是局部变量，而是来自外层（非全局）作用域的变量。</p><p>后端路由定位<br>根据 URL 定位后端路由：</p><p>框架搜索关键词示例路由定义示例<br>Spring Boot@PostMapping(“&#x2F;v1&#x2F;chunk&#x2F;list”) 或 @RequestMapping@PostMapping(“&#x2F;v1&#x2F;chunk&#x2F;list”)<br>数据库索引<br>KEY devparamtemplate_create_time (create_time)：这些语句是给表里的字段加普通索引（KEY），作用是为了提高查询速度，但不会限制字段值唯一。</p><p>类型作用是否防重复<br>KEY 或 INDEX提升查询性能❌ 不限制重复<br>UNIQUE KEY防重复值 + 提升查询性能✅ 限制重复<br>ORM 模型示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DevParamTemplate</span>(<span class="hljs-title class_ inherited__">DataBaseModel</span>):<br>    <span class="hljs-built_in">id</span> = CharField(max_length=<span class="hljs-number">32</span>, primary_key=<span class="hljs-literal">True</span>)<br>    name = CharField(max_length=<span class="hljs-number">100</span>, null=<span class="hljs-literal">False</span>, help_text=<span class="hljs-string">&quot;模板名称&quot;</span>, index=<span class="hljs-literal">True</span>)<br>    agent_id = CharField(max_length=<span class="hljs-number">64</span>, null=<span class="hljs-literal">True</span>, help_text=<span class="hljs-string">&quot;关联的agentID&quot;</span>, index=<span class="hljs-literal">True</span>)<br>    auth = CharField(max_length=<span class="hljs-number">255</span>, null=<span class="hljs-literal">True</span>, help_text=<span class="hljs-string">&quot;授权信息&quot;</span>)<br>    template = TextField(null=<span class="hljs-literal">True</span>, help_text=<span class="hljs-string">&quot;参数模板内容&quot;</span>, default=<span class="hljs-built_in">list</span>)<br>    status = CharField(max_length=<span class="hljs-number">1</span>, null=<span class="hljs-literal">True</span>, default=<span class="hljs-string">&quot;1&quot;</span>, help_text=<span class="hljs-string">&quot;状态 1是开启 0是关闭&quot;</span>, index=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        db_table = <span class="hljs-string">&quot;dev_param_template&quot;</span><br></code></pre></td></tr></table></figure><p>Index&#x3D;True 表示为这个字段创建普通索引（提高查询速度，但不会防止重复值）。</p><p>接口设计与错误码<br>改一下接口 create_paramtemplate 加一步“唯一性校验”，否则当用户传入重复的 name 时，数据库会抛出 IntegrityError，前端只会收到 500（HTTP 状态码，表示服务器内部错误）。</p><p>场景HTTP 状态码业务返回码（示例）<br>请求成功200code&#x3D;0<br>参数错误400code&#x3D;100<br>权限不足200（或 403）code&#x3D;401<br>服务器异常500code&#x3D;500<br>分层架构<br>Service 层：Controller 只负责接收参数、调用服务、返回结果，不做业务逻辑。</p><p>Controller（控制器）层<br>像前台接待员：</p><p>只负责“收快递”（接收 HTTP 请求参数）</p><p>把快递交给后台仓库（Service 层）</p><p>再把仓库返回的结果打包发回给客人（返回 JSON 给前端）<br>一句话：不处理业务逻辑，只做“收、转、返”。</p><p>Service（业务）层<br>像后台仓库：</p><p>真正拆包裹、检查货物（参数校验、业务规则）</p><p>决定能不能入库（判断名称是否重复）</p><p>把最终入库单交给工人（DAO &#x2F; ORM）去落库<br>一句话：所有“能不能做、该怎么做”的判断都在这里。</p><p>MVC &#x2F; 分层结构<br>就是把代码按职责切成三层（或更多层）：</p><p>M Model（数据模型，对应数据库表）</p><p>V View（前端页面 &#x2F; JSON 视图）</p><p>C Controller（上面说的前台接待员）</p><p>S Service（后台仓库）<br>好处：各层互不干扰，代码好维护、好测试、好复用。</p><p>Jenkins 与 CI&#x2F;CD<br>Jenkins：<br>Jenkins 是一个开源的、提供友好操作界面的持续集成（CI）工具，起源于 Hudson，主要用于持续、自动的构建&#x2F;测试软件项目。</p><p>CI&#x2F;CD 是什么？</p><p>CI（Continuous Integration，持续集成）：一种软件开发实践。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</p><p>CD（Continuous Delivery，持续交付）：是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境（类生产环境）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。</p><p>Tomcat<br>功能说明<br>接收浏览器请求别人输入网址，Tomcat 听见“有人敲门”<br>把你的代码跑起来它帮你把 Java 代码变成网页，回给浏览器<br>管理“网站生命”网站启动、关闭、重启，都由 Tomcat 管<br>npm 命令<br>npm run build &#x3D; 把“开发时的源代码”变成“用户真正看到的网页”，就像把厨房半成品变成端上桌的硬菜。</p><p>npm run dev &#x3D; 开发专用“实时预览 + 调试”模式，菜还没正式上桌，但厨师可以随时尝咸淡。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>🧠 基本概念<br>概念含义<br>线程池（ThreadPool）提前准备好的几个“工作线程”<br>任务（Task）你要执行的函数，比如 get_data()<br>Future表示“将来”会返回结果的对象，你可以等待它完成<br>submit()提交一个任务给线程池<br>map()批量处理多个任务，像 map() 函数一样<br>with … as自动关闭线程池资源的推荐写法<br>🧪 示例代码（带中文注释）</p><p>python<br>import time<br>from concurrent.futures import ThreadPoolExecutor, as_completed</p><h3 id="假设这是你要并行执行的函数"><a href="#假设这是你要并行执行的函数" class="headerlink" title="假设这是你要并行执行的函数"></a>假设这是你要并行执行的函数</h3><p>def fetch_data(name, wait&#x3D;1):<br>    print(f”[{name}] 开始执行任务，预计耗时 {wait} 秒”)<br>    time.sleep(wait)  # 模拟 I&#x2F;O 操作（比如请求网页）<br>    print(f”[{name}] 完成任务”)<br>    return f”{name} 的数据”</p><h3 id="主程序开始"><a href="#主程序开始" class="headerlink" title="主程序开始"></a>主程序开始</h3><p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    # 创建一个线程池，最多同时执行 3 个任务<br>    with ThreadPoolExecutor(max_workers&#x3D;3) as executor:<br>        # 提交多个任务给线程池执行<br>        futures &#x3D; []<br>        for i in range(5):<br>            # submit(函数, 参数1, 参数2, …)<br>            future &#x3D; executor.submit(fetch_data, f”任务{i+1}”, wait&#x3D;i % 3 + 1)<br>            futures.append(future)</p><pre><code class="hljs">    # 等待所有任务完成（异步）    for future in as_completed(futures):        result = future.result()  # 获取返回值（阻塞直到完成）        print(f&quot;[主程序] 收到结果：&#123;result&#125;&quot;)</code></pre><p>🧠 学习小笔记（建议记下来）</p><p>点说明<br>✅ ThreadPoolExecutor(max_workers&#x3D;N)N 是最多同时运行几个任务（线程数）<br>✅ submit(func, *args)异步执行函数，立即返回 Future<br>✅ as_completed(futures)按任务完成顺序返回结果<br>✅ .result()获取函数运行完后的返回值<br>❗ 适合 I&#x2F;O 密集型任务比如网络请求、数据库查询、文件操作<br>❌ 不适合 CPU 密集型如训练模型、数学计算 → 请用多进程</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>常用元字符<br>字符描述实例试一试<br>[]一组字符“[a-m]”<br>\示意特殊序列（也可用于转义特殊字符）“\d”<br>.任何字符（换行符除外）“he..o”<br>^起始于“^hello”<br>$结束于“world$”<br>*零次或多次出现“aix*”<br>+一次或多次出现“aix+”<br>{}确切地指定的出现次数“al{2}”<br><code></code>两者任一<code>&quot;fallsstays&quot;</code><br>特殊序列<br>字符描述实例<br>\A如果指定的字符位于字符串的开头，则返回匹配项“\AThe”<br>\b返回指定字符位于单词的开头或末尾的匹配项r”\bain”, r”ain\b”<br>\B返回指定字符存在的匹配项，但不在单词的开头（或结尾处）r”\Bain”, r”ain\B”<br>\d返回字符串包含数字的匹配项（数字 0-9）“\d”<br>\D返回字符串不包含数字的匹配项“\D”<br>\s返回字符串包含空白字符的匹配项“\s”<br>\S返回字符串不包含空白字符的匹配项“\S”<br>\w返回一个匹配项，其中字符串包含任何单词字符（a-z, A-Z, 0-9, _）“\w”<br>\W返回一个匹配项，其中字符串不包含任何单词字符“\W”<br>\Z如果指定的字符位于字符串的末尾，则返回匹配项“Spain\Z”<br>集合<br>表达式描述<br>[arn]返回一个匹配项，其中存在指定字符（a, r 或 n）之一<br>[a-n]返回字母顺序 a 和 n 之间的任意小写字符匹配项<br>[^arn]返回除 a、r 和 n 之外的任意字符的匹配项<br>[0123]返回存在任何指定数字（0、1、2 或 3）的匹配项<br>[0-9]返回 0 与 9 之间任意数字的匹配<br>[0-5][0-9]返回介于 0 到 9 之间的任何数字的匹配项<br>[a-zA-Z]返回字母顺序 a 和 z 之间的任何字符的匹配，小写或大写<br>[+]在集合中，+, *, ., <code>, (), $, &#123;&#125;没有特殊含义，因此[+]表示返回字符串中任何+</code> 字符的匹配项<br>正则函数<br>findall() 函数返回包含所有匹配项的列表。</p><p>search() 函数搜索字符串中的匹配项，如果存在匹配则返回 Match 对象。如果有多个匹配，则仅返回首个匹配项。</p><p>sub() 函数把匹配替换为您选择的文本。</p><p>模块与脚本<br>✅ 模块（module）和脚本（script）的区别</p><p>特性模块（Module）脚本（Script）<br>定义一个可以被导入和复用的 Python 文件一个可以直接运行的 Python 文件<br>用途提供功能、函数、类供其他代码调用执行某个特定任务或程序流程<br>入口点没有主入口，供其他文件使用通常有 if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘<br>导入方式import mymodule不能被别的脚本导入（如果它只是用来执行）<br>重复使用性高，可复用通常低，更专注执行任务<br>举例math.py, utils.py（定义函数供别人用）<br>Peewee ORM 示例<br>模型转字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseModel</span>(<span class="hljs-title class_ inherited__">Model</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_dict</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__dict__[<span class="hljs-string">&#x27;__data__&#x27;</span>]  <span class="hljs-comment"># 直接访问对象内部字典属性</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_human_model_dict</span>(<span class="hljs-params">self, only_primary_with: <span class="hljs-built_in">list</span> = <span class="hljs-literal">None</span></span>):<br>        model_dict = <span class="hljs-variable language_">self</span>.__dict__[<span class="hljs-string">&#x27;__data__&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> only_primary_with:<br>            <span class="hljs-keyword">return</span> &#123;remove_field_name_prefix(k): v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> model_dict.items()&#125;<br>        human_model_dict = &#123;&#125;<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._meta.primary_key.field_names:<br>            human_model_dict[remove_field_name_prefix(k)] = model_dict[k]<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> only_primary_with:<br>            human_model_dict[k] = model_dict[<span class="hljs-string">f&#x27;f_<span class="hljs-subst">&#123;k&#125;</span>&#x27;</span>]<br>        <span class="hljs-keyword">return</span> human_model_dict<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">meta</span>(<span class="hljs-params">self</span>) -&gt; Metadata:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._meta<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_primary_keys_name</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-keyword">return</span> cls._meta.primary_key.field_names <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(cls._meta.primary_key, CompositeKey) <span class="hljs-keyword">else</span> [cls._meta.primary_key.name]<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getter_by</span>(<span class="hljs-params">cls, attr</span>):<br>        <span class="hljs-keyword">return</span> operator.attrgetter(attr)(cls)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">cls, reverse=<span class="hljs-literal">None</span>, order_by=<span class="hljs-literal">None</span>, **kwargs</span>):<br>        filters = []<br>        <span class="hljs-keyword">for</span> f_n, f_v <span class="hljs-keyword">in</span> kwargs.items():<br>            attr_name = <span class="hljs-string">&#x27;%s&#x27;</span> % f_n<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, attr_name) <span class="hljs-keyword">or</span> f_v <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(f_v) <span class="hljs-keyword">in</span> &#123;<span class="hljs-built_in">list</span>, <span class="hljs-built_in">set</span>&#125;:<br>                f_v = <span class="hljs-built_in">list</span>(f_v)<br>                <span class="hljs-keyword">if</span> is_continuous_field(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">getattr</span>(cls, attr_name))):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(f_v) == <span class="hljs-number">2</span>:<br>                        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(f_v):<br>                            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(v, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">and</span> f_n <span class="hljs-keyword">in</span> auto_date_timestamp_field():<br>                                f_v[i] = utils.date_string_to_timestamp(v)<br>                        lt_value = f_v[<span class="hljs-number">0</span>]<br>                        gt_value = f_v[<span class="hljs-number">1</span>]<br>                        <span class="hljs-keyword">if</span> lt_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> gt_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                            filters.append(cls.getter_by(attr_name).between(lt_value, gt_value))<br>                        <span class="hljs-keyword">elif</span> lt_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                            filters.append(operator.attrgetter(attr_name)(cls) &gt;= lt_value)<br>                        <span class="hljs-keyword">elif</span> gt_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                            filters.append(operator.attrgetter(attr_name)(cls) &lt;= gt_value)<br>                <span class="hljs-keyword">else</span>:<br>                    filters.append(operator.attrgetter(attr_name)(cls) &lt;&lt; f_v)<br>            <span class="hljs-keyword">else</span>:<br>                filters.append(operator.attrgetter(attr_name)(cls) == f_v)<br>        <span class="hljs-keyword">if</span> filters:<br>            query_records = cls.select().where(*filters)<br>            <span class="hljs-keyword">if</span> reverse <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> order_by <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;order_by&#125;</span>&quot;</span>):<br>                    order_by = <span class="hljs-string">&quot;create_time&quot;</span><br>                <span class="hljs-keyword">if</span> reverse <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>                    query_records = query_records.order_by(cls.getter_by(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;order_by&#125;</span>&quot;</span>).desc())<br>                <span class="hljs-keyword">elif</span> reverse <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                    query_records = query_records.order_by(cls.getter_by(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;order_by&#125;</span>&quot;</span>).asc())<br>            <span class="hljs-keyword">return</span> [query_record <span class="hljs-keyword">for</span> query_record <span class="hljs-keyword">in</span> query_records]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><p>Peewee 基础<br>Peewee 是一个轻量级的 ORM（对象关系映射）框架，ORM 的核心思想就是用 Python 类来表示数据库表。在定义模型类时，Meta 就是 Peewee 提供的一种机制，告诉 ORM 框架这个类在数据库中应该怎么表现。</p><p>过滤器<br>.startswith(prefix)：搜索以前缀开头的值</p><p>.endswith(suffix)：搜索以后缀结尾的值</p><p>.regexp(exp)：正则表达式匹配（区分大小写）</p><p>.iregexp(exp)：正则表达式匹配（不区分大小写）</p><p>.cast(type)：将列的值转换为给定类型</p><p>Utils 工具目录<br>在一个项目里，utils（utilities） 文件或目录并不是官方规范，而是约定俗成的“工具箱”。它的核心定位是：放置那些与业务逻辑解耦、可在多处复用、与框架&#x2F;库无关的通用代码。</p><h2 id="logger"><a href="#logger" class="headerlink" title="&#x2F;logger&#x2F;"></a>&#x2F;<em>logger</em>&#x2F;</h2><p><code>只有当「Logger 设置的级别」≤「日志级别」时，才会输出。</code></p><table><thead><tr><th>Logger 设置的级别</th><th>会打印的级别</th><th>不会打印的级别</th></tr></thead><tbody><tr><td>DEBUG</td><td>DEBUG、INFO、WARNING、ERROR、CRITICAL</td><td>无</td></tr><tr><td>INFO</td><td>INFO、WARNING、ERROR、CRITICAL</td><td>DEBUG</td></tr><tr><td>WARNING</td><td>WARNING、ERROR、CRITICAL</td><td>DEBUG、INFO</td></tr><tr><td>ERROR</td><td>ERROR、CRITICAL</td><td>DEBUG、INFO、WARNING</td></tr><tr><td>CRITICAL</td><td>CRITICAL</td><td>DEBUG、INFO、WARNING、ERROR</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成器</title>
    <link href="/2025/08/13/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2025/08/13/%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="生成器函数和生成器对象的区别"><a href="#生成器函数和生成器对象的区别" class="headerlink" title="生成器函数和生成器对象的区别"></a>生成器函数和生成器对象的区别</h2><p>生成器函数被调用时，并不会立即执行函数体，而是返回一个生成器对象。只有在<strong>迭代生成器对象</strong>时，代码才会一步步执行。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator started&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yielded 1, continue...&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yielded 2, finish&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling gen()...&quot;</span>)<br>g = gen()  <span class="hljs-comment"># 创建生成器对象，不执行函数体</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator object created:&quot;</span>, g)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g)...&quot;</span>)<br>val1 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行到第一个 yield</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received:&quot;</span>, val1)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g) again...&quot;</span>)<br>val2 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行到第二个 yield</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received:&quot;</span>, val2)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g) final time...&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    val3 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行剩余代码，结束</span><br><span class="hljs-keyword">except</span> StopIteration:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator exhausted&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done.&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行结果<br>Calling gen()…<br>Generator object created: &lt;generator object gen at 0x…&gt;<br>Calling next(g)…<br>Generator started<br>Received: 1<br>Calling next(g) again…<br>Yielded 1, continue…<br>Received: 2<br>Calling next(g) final time…<br>Yielded 2, finish<br>Generator exhausted<br>Done.</p><p>术语解释<br>迭代器驱动<br>迭代器不会自己执行，需要外部调用 next() 或使用 for 循环来“驱动”它。</p><p>每次调用 next()，代码会从上一次 yield 后的位置继续运行，直到遇到下一个 yield 或结束。</p><p>next()<br>Python 内置函数，等价于调用迭代器的 <strong>next</strong>() 方法。</p><p>功能：运行生成器到下一个 yield，返回其后的值。</p><p>当没有更多值时，会抛出 StopIteration 异常。</p><p>callable(obj)<br>Python 内置函数，用于判断对象 obj 是否可调用。</p><p>可调用对象包括：函数、方法，或者实现了 <strong>call</strong>() 方法的类实例。</p><p>callable(res) 的应用场景<br>在某些代码（如 res &#x3D; self._run()）中：<br>场景res 类型callable(res)处理方式<br>普通组件字符串、字典、DataFrame…False直接记录耗时<br>流式组件生成器函数、functools.partialTrue再调用一次获取生成器，开始迭代</p><p>为什么不能立即记录耗时？<br>如果 res 是生成器函数，还没开始迭代就记录结束时间，会导致耗时被严重低估，无法反映真实执行时间。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/./%E5%A3%81%E7%BA%B8.jpg" alt="壁纸"></p><img src="/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E5%A3%81%E7%BA%B8.jpg" class="">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/01/hello-world/"/>
    <url>/2025/08/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bs4</title>
    <link href="/2025/08/01/bs4/"/>
    <url>/2025/08/01/bs4/</url>
    
    <content type="html"><![CDATA[<p><em><strong>爬虫</strong></em>*</p><ul><li>发送 HTTP 请求：爬虫通过 HTTP 请求从目标网站获取 HTML 页面，常用的库包括 requests。</li><li>解析 HTML 内容：获取 HTML 页面后，爬虫需要解析内容并提取数据，常用的库有 BeautifulSoup、lxml、Scrapy 等。</li><li>提取数据：通过定位 HTML 元素（如标签、属性、类名等）来提取所需的数据。</li><li>存储数据：将提取的数据存储到数据库、CSV 文件、JSON 文件等格式中，以便后续使用或分析。</li></ul><p><code>页面里的一个标签，就是一个元素。</code></p><table><thead><tr><th>你在 HTML 里写的</th><th>浏览器里的称呼</th><th>举例</th></tr></thead><tbody><tr><td><code>&lt;div&gt;</code></td><td>div 元素</td><td>一个容器块</td></tr><tr><td><code>&lt;img src=&quot;…&quot;&gt;</code></td><td>img 元素</td><td>一张图片</td></tr><tr><td><code>&lt;button&gt;</code></td><td>button 元素</td><td>按钮</td></tr><tr><td><code>&lt;a href=&quot;…&quot;&gt;</code></td><td>a 元素</td><td>超链接</td></tr><tr><td><code>&lt;span&gt;</code></td><td>span 元素</td><td>行内文本</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>    <span class="hljs-comment"># 读取示例 HTML 文件</span><br>html = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">    &lt;head&gt;</span><br><span class="hljs-string">        &lt;title&gt;Example Page&lt;/title&gt;</span><br><span class="hljs-string">    &lt;/head&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">        &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 创建 BeautifulSoup 对象，并指定解析器为 lxml</span><br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>    <span class="hljs-comment"># 找到第一个 h1 标签，并输出其文本内容</span><br>h1 = soup.find(<span class="hljs-string">&#x27;h1&#x27;</span>)<br><span class="hljs-built_in">print</span>(h1.text)<br></code></pre></td></tr></table></figure><h3 id="可以使用-BeautifulSoup-对象-soup-来提取其中的数据。例如，要获取文档标题，可以使用-title-属性"><a href="#可以使用-BeautifulSoup-对象-soup-来提取其中的数据。例如，要获取文档标题，可以使用-title-属性" class="headerlink" title="可以使用 BeautifulSoup 对象 soup 来提取其中的数据。例如，要获取文档标题，可以使用 title 属性"></a>可以使用 BeautifulSoup 对象 soup 来提取其中的数据。例如，要获取文档标题，可以使用 title 属性</h3><p>print(soup.title)<br>    # <title>Example Page</title>   </p><h3 id="要获取标签的文本内容，可以使用-text-属性或-string-属性："><a href="#要获取标签的文本内容，可以使用-text-属性或-string-属性：" class="headerlink" title="要获取标签的文本内容，可以使用 text 属性或 string 属性："></a>要获取标签的文本内容，可以使用 text 属性或 string 属性：</h3><p>print(soup.h1.text)</p><h3 id="要获取标签的属性，可以使用-attrs-属性："><a href="#要获取标签的属性，可以使用-attrs-属性：" class="headerlink" title="要获取标签的属性，可以使用 attrs 属性："></a>要获取标签的属性，可以使用 attrs 属性：</h3><p>1.Tag(标签)<br>print(soup.a.attrs[‘href’])<br>(1)每个tag都有自己的名字，通过.name来获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;a&gt;recall&lt;/a&gt;&#x27;</span>, features=<span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.a)<br><span class="hljs-comment">#&lt;a&gt;liyuhong&lt;/a&gt;</span><br><span class="hljs-built_in">print</span>(soup.a.name)<br><span class="hljs-comment">#a</span><br></code></pre></td></tr></table></figure><p>(2)一个tag可能有多个属性，操作与字典相同，通过.attrs来获取。</p><p>2.NavigableString(标签的值)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;a class=&quot;celebrity liyuhong&quot;&gt;li&lt;/a&gt;&#x27;</span>, features=<span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.a.string)<br><span class="hljs-comment">#li</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(soup.a.string))<br><span class="hljs-comment">#&lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h3 id="要获取所有符合条件的标签，可以使用-find-all-方法："><a href="#要获取所有符合条件的标签，可以使用-find-all-方法：" class="headerlink" title="要获取所有符合条件的标签，可以使用 find_all 方法："></a>要获取所有符合条件的标签，可以使用 find_all 方法：</h3><h1 id="获取所有-p-标签"><a href="#获取所有-p-标签" class="headerlink" title="获取所有 p 标签"></a>获取所有 p 标签</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">ps = soup.find_all(<span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps:<br>    <span class="hljs-built_in">print</span>(p.text)<br>    <span class="hljs-comment">#    This is the first paragraph.</span><br>    <span class="hljs-comment"># This is the second paragraph.</span><br>    <span class="hljs-comment"># 获取 class 为 &quot;second&quot; 的 p 标签</span><br>    p = soup.find(<span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;second&#x27;</span>&#125;)<br><span class="hljs-built_in">print</span>(p.text)<br>    <span class="hljs-comment"># This is the second paragraph.</span><br></code></pre></td></tr></table></figure><h3 id="BeautifulSoup-支持使用-CSS-选择器来查找标签，可以使用-select-方法"><a href="#BeautifulSoup-支持使用-CSS-选择器来查找标签，可以使用-select-方法" class="headerlink" title="BeautifulSoup 支持使用 CSS 选择器来查找标签，可以使用 select 方法"></a>BeautifulSoup 支持使用 CSS 选择器来查找标签，可以使用 select 方法</h3><p><code>返回列表。类似CSS写法来筛选元素，标签名不加任何修饰，类名加点，id名加#</code></p><ol><li>通过标签名查找</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;a&#x27;</span>)<br>soup.select(<span class="hljs-string">&#x27;a, span&#x27;</span>) <span class="hljs-comment"># 注意引号的位置</span><br></code></pre></td></tr></table></figure><p>2.通过类名查找<br>soup.select(‘.class’)</p><p>3.通过id名查找<br>soup.select(‘#id’)</p><ol start="4"><li>通过子标签查找</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pthon"># 直接子元素(必须相邻)<br>soup.select(&#x27;body &gt; div &gt;a&#x27;)<br># 间接子元素(不需相邻)<br>soup.select(&#x27;body a&#x27;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy</title>
    <link href="/2025/08/01/Scrapy/"/>
    <url>/2025/08/01/Scrapy/</url>
    
    <content type="html"><![CDATA[<h2 id="scrapy简介"><a href="#scrapy简介" class="headerlink" title="scrapy简介"></a>scrapy简介</h2><ul><li>Engine：引擎，处理整个系统的数据流和事件，是整个框架的核心，</li><li>Item： 它是一个抽象的数据结构，它定义了爬取结果的数据结构，爬取的数据会被赋值成 Item 对象。每个 Item 就是一个类，类里面定义了爬取结果的数据字段</li><li>Scheduler： 调度器，它用来接受 Engine 发过来的 Request 并将其加入队列中，同时也可以将 Request 发回给 Engine 供 Downloader 执行，它主要维护 Request 的调度逻辑，比如先进先出、先进后出、优先级进出等等。</li><li>Spiders： 每个 Spider 里面定义了站点的爬取逻辑和页面的解析规则，它主要负责解析响应并生成 Item 和新的请求然后发给 Engine 进行处理。</li><li>Downloader： 下载器，即完成 向服务器发送请求，然后拿到响应 的过程，得到的响应会再发送给 Engine 处理。</li><li>Item Pipelines： 项目管道，这也是一个复数统称，可以对应多个 Item Pipeline。Item Pipeline 主要负责处理由 Spider 从页面中抽取的 Item，做一些数据清洗、验证和存储等工作，比如将 Item 的某些字段进行规整，将 Item 存储到数据库等操作都可以由 Item Pipeline 来完成。</li><li>Downloader Middlewares： 图中 Engine 和 Downloader 之间的方块部分，中文可以称为下载器中间件，同样也是复数统称，其包含多个 Downloader Middleware，它是位于 Engine 和 Downloader 之间的 Hook 框架，负责实现 Downloader 和 Engine 之间的请求和响应的处理过程。</li><li>Spider Middlewares： 图中 Engine 和 Spiders 之间的方块部分，中文可以称为蜘蛛中间件，它是位于 Engine 和 Spiders 之间的 Hook 框架，负责实现 Spiders 和 Engine 之间的 Item，请求和响应的处理过程</li></ul><h2 id="项目运行过程"><a href="#项目运行过程" class="headerlink" title="项目运行过程"></a>项目运行过程</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><code>scrapy startproject tutorial</code><br>这将创建一个名为 tutorial 的目录，其内容如下<br>tutorial&#x2F;<br>    scrapy.cfg            # deploy configuration file</p><pre><code class="hljs">tutorial/             # project&#39;s Python module, you&#39;ll import your code from here    __init__.py    items.py          # project items definition file    middlewares.py    # project middlewares file    pipelines.py      # project pipelines file    settings.py       # project settings file    spiders/          # a directory where you&#39;ll later put your spiders        __init__.py</code></pre><h3 id="我们的第一个-Spider"><a href="#我们的第一个-Spider" class="headerlink" title="我们的第一个 Spider"></a>我们的第一个 Spider</h3><p>Spider 是您定义的类，Scrapy 使用它们从网站（或一组网站）抓取信息。它们必须继承自Spider，并定义初始请求，以及（可选地）如何跟踪页面中的链接和解析下载的页面内容以提取数据。</p><p>这是我们第一个 Spider 的代码。将其保存在项目目录 tutorial&#x2F;spiders 下名为 quotes_spider.py 的文件中</p><p><code>scrapy genspider sina news.sina.com.cn</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuotesSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;quotes&quot;</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        urls = [<br>            <span class="hljs-string">&quot;https://quotes.toscrape.com/page/1/&quot;</span>,<br>            <span class="hljs-string">&quot;https://quotes.toscrape.com/page/2/&quot;</span>,<br>        ]<br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=url, callback=<span class="hljs-variable language_">self</span>.parse)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        page = response.url.split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">2</span>]<br>        filename = <span class="hljs-string">f&quot;quotes-<span class="hljs-subst">&#123;page&#125;</span>.html&quot;</span><br>        Path(filename).write_bytes(response.body)<br>        <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;Saved file <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>name：用于标识 Spider。它在项目内必须是唯一的，也就是说，您不能为不同的 Spider 设置相同的名称。<br>start()：必须是一个异步生成器，用于产生供 spider 开始抓取的请求（以及可选的 item）。后续请求将从这些初始请求中连续生成。<br>parse()：一个将被调用的方法，用于处理每个请求下载的响应。response 参数是TextResponse 的一个实例，它包含页面内容并具有其他有用的方法来处理它。</p><h3 id="如何运行我们的-spider"><a href="#如何运行我们的-spider" class="headerlink" title="如何运行我们的 spider"></a>如何运行我们的 spider</h3><p>要运行我们的 spider，请进入项目的顶层目录并运行<br><code>scrapy crawl quotes</code></p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Playwright</title>
    <link href="/2025/08/01/playwright/"/>
    <url>/2025/08/01/playwright/</url>
    
    <content type="html"><![CDATA[<h1 id="Playwright"><a href="#Playwright" class="headerlink" title="Playwright"></a>Playwright</h1><p>*** 框架对比***</p><table><thead><tr><th>需求维度</th><th>推荐工具</th></tr></thead><tbody><tr><td>纯静态&#x2F;海量列表</td><td>Scrapy</td></tr><tr><td>少量动态页面</td><td>Playwright 直接脚本</td></tr><tr><td>大规模+少量 JS</td><td>Scrapy + scrapy-playwright</td></tr><tr><td>复杂人机交互</td><td>Playwright&#x2F;Selenium</td></tr><tr><td>必须 IE 兼容</td><td>Selenium</td></tr></tbody></table><ul><li>两者如何混合——“Scrapy 管调度，Playwright 管渲染”<br>• scrapy-playwright：官方插件，把 Playwright 作为 Scrapy 的下载器。</li><li>优点：<br>– 继续享受 Scrapy 的调度&#x2F;去重&#x2F;管道；<br>– 只有真正需要 JS 的请求才走 Playwright，其他仍走高速 HTTP。</li></ul><p><code>Playwright = 一个可以“自动化任何现代浏览器”（Chromium、Firefox、WebKit）的跨语言库，用它写出来的脚本能像真人一样打开网页、点击、输入、滚动、截图、下文件、抓接口、跑单测、生成 PDF/视频——速度快、稳定性高、反爬绕过能力强。</code></p><p>1️⃣ <code>inner_text</code>基本用法: 获取某个元素「可见文本」的API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ptthon">text = await page.inner_text(selector) #selector：CSS/XPath 选择器，定位目标元素。<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>是否只取可见文本</th><th>是否包含隐藏元素文本</th></tr></thead><tbody><tr><td><code>inner_text()</code></td><td>✅ 只取可见</td><td>❌ 不包含</td></tr><tr><td><code>text_content()</code></td><td>❌ 取所有（包括 <code>display:none</code>）</td><td>✅ 包含</td></tr></tbody></table><p>2️⃣ <code>query_selector </code> 根据 CSS&#x2F;XPath 选择器，返回第一个匹配的元素句柄（ElementHandle），找不到就返回 None。</p><table><thead><tr><th>方法</th><th>返回</th></tr></thead><tbody><tr><td><code>query_selector</code></td><td>第一个匹配元素（ElementHandle 或 None）</td></tr><tr><td><code>query_selector_all</code></td><td><strong>列表</strong> <code>[ElementHandle, …]</code>，空列表 <code>[]</code></td></tr></tbody></table><p>3️⃣ <code>get_attribute</code> 把 HTML 标签里的 属性&#x3D;”值” 取出来。</p><table><thead><tr><th>方法</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>get_attribute</code></td><td>取 <strong>标签属性值</strong></td><td><code>&lt;a href=&quot;x&quot;&gt;</code> → <code>&quot;x&quot;</code></td></tr><tr><td><code>inner_text</code> &#x2F; <code>text_content</code></td><td>取 <strong>元素内部可见文本</strong></td><td><code>&lt;a href=&quot;x&quot;&gt;点我&lt;/a&gt;</code> → <code>&quot;点我&quot;</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> async_playwright() <span class="hljs-keyword">as</span> p: <span class="hljs-comment">#Playwright 的“启动写法</span><br>    browser = <span class="hljs-keyword">await</span> p.chromium.launch(<br>                            headless=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 无界面运行，省资源。</span><br>                            args=[<br>                                <span class="hljs-string">&#x27;--disable-gpu&#x27;</span>,<br>                                <span class="hljs-string">&#x27;--disable-dev-shm-usage&#x27;</span>,<br>                                <span class="hljs-string">&#x27;--no-sandbox&#x27;</span>,<br>                                <span class="hljs-string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>,    <span class="hljs-comment">#去掉 navigator.webdriver=true 等自动化特征，降低被反爬识别概率。</span><br>                                <span class="hljs-string">&#x27;--disable-features=IsolateOrigins,site-per-process&#x27;</span>,<br>                                <span class="hljs-string">&#x27;--disable-site-isolation-trials&#x27;</span><br>                            ],<br>                            proxy=playwright_proxy<br>                        )<br>    iphone = p.devices[<span class="hljs-string">&quot;iPhone 12&quot;</span>] <span class="hljs-comment"># Playwright 自带的「iPhone 12」设备配置（含视口、UA、触控等）。</span><br>                    <span class="hljs-comment">#创建一个新的浏览器上下文（Context），相当于一个独立的浏览器环境（类似于一个新的窗口或用户）。</span><br>                    context = <span class="hljs-keyword">await</span> browser.new_context(<br>                        **iphone,<br>                        extra_http_headers=&#123;<br>                            <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://mp.weixin.qq.com/&quot;</span>,<br>                            <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.42(0x18002a2e) NetType/WIFI Language/zh_CN&quot;</span>,<br>                            <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>,<br>                            <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;zh-CN,zh;q=0.9,en;q=0.8&quot;</span>,<br>                            <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate, br&quot;</span>,<br>                            <span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;keep-alive&quot;</span>,<br>                            <span class="hljs-string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>                            <span class="hljs-string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="hljs-string">&quot;document&quot;</span>,<br>                            <span class="hljs-string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="hljs-string">&quot;navigate&quot;</span>,<br>                            <span class="hljs-string">&quot;Sec-Fetch-Site&quot;</span>: <span class="hljs-string">&quot;same-origin&quot;</span>,<br>                            <span class="hljs-string">&quot;Sec-Fetch-User&quot;</span>: <span class="hljs-string">&quot;?1&quot;</span>,<br>                            <span class="hljs-string">&quot;Cache-Control&quot;</span>: <span class="hljs-string">&quot;max-age=0&quot;</span><br>                        &#125;<br>                    )<br>                    <span class="hljs-comment"># 每个新页面加载前注入自定义 JavaScript 脚本。</span><br>                    <span class="hljs-keyword">await</span> context.add_init_script(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                        Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;</span><br><span class="hljs-string">                            get: () =&gt; undefined</span><br><span class="hljs-string">                        &#125;);</span><br><span class="hljs-string">                        Object.defineProperty(navigator, &#x27;plugins&#x27;, &#123;</span><br><span class="hljs-string">                            get: () =&gt; [1, 2, 3, 4, 5]</span><br><span class="hljs-string">                        &#125;);</span><br><span class="hljs-string">                        Object.defineProperty(navigator, &#x27;languages&#x27;, &#123;</span><br><span class="hljs-string">                            get: () =&gt; [&#x27;zh-CN&#x27;, &#x27;zh&#x27;]</span><br><span class="hljs-string">                        &#125;);</span><br><span class="hljs-string">                    &quot;&quot;&quot;</span>)<br>                    <span class="hljs-comment"># 创建页面并访问 同一个上下文下的页面共享 Cookie、存储等环境</span><br>                    page = <span class="hljs-keyword">await</span> context.new_page()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask</title>
    <link href="/2025/08/01/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_hexo_cleaned/"/>
    <url>/2025/08/01/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_hexo_cleaned/</url>
    
    <content type="html"><![CDATA[<p><strong>Flask</strong></p><h1 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、 简介"></a>一、 简介</h1><p>Flask是一个非常小的PythonWeb框架，被称为微型框架；只提供了一个稳健的核心，其他功能全部是通过扩展实现的</p><h1 id="二、-概要"><a href="#二、-概要" class="headerlink" title="二、 概要"></a>二、 概要</h1><p>1）安装： pip install flask<br>2）组成：WSGI系统、调试、路由<br>3）模板引擎：Jinja2（由Flask核心开发者人员开发）<br>4）使用到装饰器：以@开头的代码方法</p><h1 id="三、-知识点（附代码）"><a href="#三、-知识点（附代码）" class="headerlink" title="三、 知识点（附代码）"></a>三、 知识点（附代码）</h1><h2 id="1-Flask基础入门"><a href="#1-Flask基础入门" class="headerlink" title="1. Flask基础入门"></a>1. Flask基础入门</h2><h3 id="1）路由route的创建："><a href="#1）路由route的创建：" class="headerlink" title="1）路由route的创建："></a>1）路由route的创建：</h3><p>methods&#x3D;[]支持的请求方式参数设置，不设置默认为GET<br>  @app.route(‘&#x2F;login’, methods&#x3D;[‘GET’, ‘PoSt’])  # 请求参数设置不区分大小写，源码中自动进行了upper<br>  def login():  ✅ 访问 &#x2F;login 这个地址时：<br>🔹 如果是 GET 请求（比如你在浏览器地址栏输入 &#x2F;login）就返回一个 login.html 页面（登录表单页面）<br>      if request.method &#x3D;&#x3D; ‘GET’:<br>          return render_template(‘login.html’)<br>    🔹 如果是 POST 请求（比如你在表单里点“登录”按钮提交）：从表单里取出两个字段：<br>      elif request.method &#x3D;&#x3D; ‘POST’:<br>          username &#x3D; request.form.get(‘username’)<br>          pwd &#x3D; request.form.get(‘pwd’)<br>          🔹如果用户名是 yang 且密码是 123456：<br>          if username &#x3D;&#x3D; ‘yang’ and pwd &#x3D;&#x3D; ‘123456’:<br>          🔹把用户名存到 session（表示用户已登录）<br>              session[‘username’] &#x3D; username<br>              return ‘login successed 200  ok!’<br>          else:<br>             return ‘login failed!!!’</p><p>🔹视图函数：✅ 一句话解释<br>视图函数（view function）就是 Flask 中“处理某个 URL 请求并返回响应”的 Python 函数。它相当于 MVC 里的 C（Controller）+V（View） 的结合体：接收请求 → 做业务逻辑 → 把结果（HTML&#x2F;JSON&#x2F;文本）返回</p><p>url_map.convertersFlask 的转换器注册表，把自己的转换器“挂”进去<br>&lt;re(…)&gt;路由里的尖括号表达式，用来捕获并转换 URL 片段<br>✅ 第 2 步：我们想干啥？让路由支持正则表达式匹配！<br>✅ 第 3 步：写个“手机验证”转换器<br>class RegexConverter(BaseConverter):<br>    def <strong>init</strong>(self, url_map, regex):<br>        super().<strong>init</strong>(url_map)   # 先让父类干活<br>        self.regex &#x3D; regex          # 把我们传的正则保存起来<br>    def to_python(self, value):<br>        print(‘to_python被调用，拿到值：’, value)<br>        return value                # 原样返回即可<br><strong>init</strong>：Flask 会把路由里写的正则自动塞给你（regex 参数）。<br>to_python：Flask 每捕获一次，就调用它，你可以做额外处理（这里只是打印）。<br>✅ 第 4 步：把转换器“挂”到 Flask 上<br>app.url_map.converters[‘re’] &#x3D; RegexConverter    app你创建的 Flask 应用<br>现在可以用 &lt;re(…)&gt; 这种语法了！<br>✅ 第 5 步：用转换器写路由<br>@app.route(“&#x2F;index&#x2F;&lt;re(‘1\d{10}’):value&gt;”)<br>def index(value):<br>    print(‘视图函数收到的 value：’, value)<br>    return “Hello World!<br>‘1\d{10}’ 是正则：以 1 开头、后面 10 位数字 → 11 位手机号。<br>&lt;re(…)&gt; 里的 re 就是刚才注册的转换器。<br>捕获到的字符串会经 to_python 处理后，传给 index(value)。</p><h3 id="2）endpoint的作用"><a href="#2）endpoint的作用" class="headerlink" title="2）endpoint的作用"></a>2）endpoint的作用</h3><p>🔹说明：每个app中都存在一个url_map，这个url_map中包含了url到endpoint的映射；<br>🔹作用：当request请求传来一个url的时候，会在url_map中先通过rule找到endpoint，然后再在view_functions中根据endpoint再找到对应的视图函数view_func</p><p>自定义装饰器装饰多个视图函数时，如果在路由中没有指定唯一的endpoint,<br> 则所有装饰的视图函数返回的都是装饰器中的inner函数，同名因此会报错<br> def decorator(f):<br>    def inner(*args, **kwargs):<br>        return f(*args, **kwargs)<br>    return inner          # ← 所有被装饰的函数最终都叫 inner</p><p>@app.route(‘&#x2F;a’)<br>@decorator<br>def a():                  # 实际注册的是 inner<br>    return ‘a’</p><p>@app.route(‘&#x2F;b’)<br>@decorator<br>def b():                  # 又注册一个 inner → 同名冲突！<br>    return ‘b’</p><h3 id="3）request对象的使用"><a href="#3）request对象的使用" class="headerlink" title="3）request对象的使用"></a>3）request对象的使用</h3><p>render_template()：可以用于呈现一个我们编写的html文件模板</p><h3 id="4）请求钩子before-after-request"><a href="#4）请求钩子before-after-request" class="headerlink" title="4）请求钩子before&#x2F;after_request"></a>4）请求钩子before&#x2F;after_request</h3><p>🔹想要在正常执行的代码的前、中、后时期，强行执行一段我们想要执行的功能代码，便要用到钩子函数——用特定装饰器装饰的函数。<br>1.before_request：在每一次请求之前调用；执行顺序是先绑定的先执行；<br>2.after_request：每一次请求之后都会调用；执行的顺序是先绑定的后执行；</p><h3 id="5）redirect重定向"><a href="#5）redirect重定向" class="headerlink" title="5）redirect重定向"></a>5）redirect重定向</h3><p>🔹在flask 中，重定向是通过flask.redirect(location, code&#x3D;302)这个函数来实现的，location表示需要重定向的url, 应该配合url_for函数来使用， code表示采用哪个重定向，默认是302，即临时性重定向, 可以修改为301来实现永性重定向；</p><h3 id="6）返回json数据给前端"><a href="#6）返回json数据给前端" class="headerlink" title="6）返回json数据给前端"></a>6）返回json数据给前端</h3><p>1.使用：make_response方法和json库共同完成<br>response &#x3D; make_response(json.dumps(data,ensure_ascii&#x3D;False))<br>   response.mimetype &#x3D; ‘application&#x2F;json’<br>   return response<br>2.使用：jsonify库实现，减少代码行数</p><h3 id="7）abort函数的使用"><a href="#7）abort函数的使用" class="headerlink" title="7）abort函数的使用"></a>7）abort函数的使用</h3><p>🔹使用类似于python中的raise函数，可以在需要退出请求的地方抛出错误，并结束该请求；可以使用errorhandler()装饰器来进行异常的捕获与自定义：</p><h3 id="8）url-for实现反转"><a href="#8）url-for实现反转" class="headerlink" title="8）url_for实现反转"></a>8）url_for实现反转</h3><p>🔹视图函数 → \rightarrow →url；</p><h2 id="2-Flask高级视图"><a href="#2-Flask高级视图" class="headerlink" title="2. Flask高级视图"></a>2. Flask高级视图</h2><h3 id="1）add-url-rule的初登场"><a href="#1）add-url-rule的初登场" class="headerlink" title="1）add_url_rule的初登场"></a>1）add_url_rule的初登场</h3><p>实现url与视图函数的绑定，除了使用路由装饰器@app.route,  add_url_rule(rule,endpoint&#x3D;None,view_func&#x3D;None)</p><h3 id="2）类视图的引入"><a href="#2）类视图的引入" class="headerlink" title="2）类视图的引入"></a>2）类视图的引入</h3><p>🔹 定义的视图都是通过函数来实现的,所以称之为视图函数,但其实视图还可以由类来实现，即类视图；<br>🔹标准类视图：<br>        定义时需要继承flask的views.View这一基类;<br>        每个类视图内必须包含一个dispatch_request方法，每当类视图接收到请求时都会执行该方法，返回值的设定和视图函数相同；<br>        视图函数可以通过@app.route和app.add_url_rule来进行注册（映射到url），但类视图只能通过app.add_url_rule来注册，注册时view_func不能直接使用类名，需要调用基类中的as_view方法来为自己取一个“视图函数名”<br>from flask import Flask,render_template,views<br>app &#x3D; Flask(<strong>name</strong>)</p><h1 id="定义父视图类继承基类View"><a href="#定义父视图类继承基类View" class="headerlink" title="定义父视图类继承基类View"></a>定义父视图类继承基类View</h1><p>class Ads(views.View):<br>    def <strong>init</strong>(self):<br>        super(Ads, self).<strong>init</strong>()<br>        # 实例属性<br>        self.context&#x3D;{<br>            ‘ads’:’这是对联广告！’<br>        }</p><h1 id="定义子视图类继承父类并实现工程"><a href="#定义子视图类继承父类并实现工程" class="headerlink" title="定义子视图类继承父类并实现工程"></a>定义子视图类继承父类并实现工程</h1><p>class Index(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;index.html’,**self.context)<br>class Login(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;login.html’,**self.context)<br>class Register(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;register.html’,**self.context)</p><h1 id="注册我们创建的类视图-as-view给类视图起名"><a href="#注册我们创建的类视图-as-view给类视图起名" class="headerlink" title="注册我们创建的类视图,as_view给类视图起名"></a>注册我们创建的类视图,as_view给类视图起名</h1><p>app.add_url_rule(rule&#x3D;’&#x2F;‘,endpoint&#x3D;’index’,view_func&#x3D;Index.as_view(‘index’))<br>app.add_url_rule(rule&#x3D;’&#x2F;login&#x2F;‘,endpoint&#x3D;’login’,view_func&#x3D;Login.as_view(‘login’))<br>app.add_url_rule(rule&#x3D;’&#x2F;register&#x2F;‘,endpoint&#x3D;’register’,view_func&#x3D;Register.as_view(‘register’))</p><p>if <strong>name</strong>&#x3D;&#x3D;’<strong>main</strong>‘:<br>    print(app.view_functions)<br>    app.run(debug&#x3D;True)</p><h3 id="3）装饰器的自定义与使用"><a href="#3）装饰器的自定义与使用" class="headerlink" title="3）装饰器的自定义与使用"></a>3）装饰器的自定义与使用</h3><h3 id="4）蓝图的使用"><a href="#4）蓝图的使用" class="headerlink" title="4）蓝图的使用"></a>4）蓝图的使用</h3><p>当接收到请求时，Flask会遍历Flask对象下（已注册）的各蓝图对象，比对蓝图对象中记录的url，比对成功则映射到该url绑定的视图函数并返回响应<br>📌 举个例子（不用蓝图 vs 用蓝图）<br>❌ 不用蓝图：所有代码写在一个文件<br>from flask import Flask<br>app &#x3D; Flask(<strong>name</strong>)<br>@app.route(‘&#x2F;‘)<br>def home():<br>    return ‘Home’<br>@app.route(‘&#x2F;admin’)<br>def admin():<br>    return ‘Admin’<br>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    app.run()<br>✅ 用蓝图：按模块拆分</p><h1 id="文件：admin-routes-py"><a href="#文件：admin-routes-py" class="headerlink" title="文件：admin&#x2F;routes.py"></a>文件：admin&#x2F;routes.py</h1><p>from flask import Blueprint<br>admin_bp &#x3D; Blueprint(‘admin’, <strong>name</strong>, url_prefix&#x3D;’&#x2F;admin’)</p><p>@admin_bp.route(‘&#x2F;‘)<br>def admin_home():<br>    return ‘Admin Home’</p><h1 id="文件：main-py"><a href="#文件：main-py" class="headerlink" title="文件：main.py"></a>文件：main.py</h1><p>from flask import Flask<br>from admin.routes import admin_bp</p><p>app &#x3D; Flask(<strong>name</strong>)<br>app.register_blueprint(admin_bp)</p><p>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    app.run()</p><h3 id="5）url-prefix设置蓝图前缀"><a href="#5）url-prefix设置蓝图前缀" class="headerlink" title="5）url_prefix设置蓝图前缀"></a>5）url_prefix设置蓝图前缀</h3><p>蓝图对象定义时添加，为当前蓝图下的所有视图函数添加统一的前缀<br>new_list &#x3D; Blueprint(‘news’,<strong>name</strong>,url_prefix&#x3D;’&#x2F;index’)<br>@new_list.route(‘&#x2F;news’)<br>def new():<br>    return ‘这是新闻模块！’<br>此外，在主路由中注册蓝图时也可以为蓝图添加前缀，并且此次添加会覆写蓝图对象创建时添加的前缀；<br>如下例中，注册后的新闻模块的url又变为了”&#x2F;test&#x2F;news”：<br>app.register_blueprint(news.new_list,url_prefix&#x3D;’&#x2F;test’)</p><h3 id="6）subdomain设置蓝图子域名"><a href="#6）subdomain设置蓝图子域名" class="headerlink" title="6）subdomain设置蓝图子域名"></a>6）subdomain设置蓝图子域名</h3><p>通过修改Flask对象的配置,为我们的网站设置域名,用字段为’SERVER_NAME’,为该域名指定端口号：</p><h1 id="当前网站域名设置为example-com，端口号为5000"><a href="#当前网站域名设置为example-com，端口号为5000" class="headerlink" title="当前网站域名设置为example.com，端口号为5000"></a>当前网站域名设置为example.com，端口号为5000</h1><pre><code class="hljs">app.config[&#39;SERVER_NAME&#39;] = &#39;example.com:5000&#39;</code></pre><p>修改位于 C:\Windows\System32\drivers\etc 下的域名重定向文件 hosts<br>📌设置子域名:在蓝图文件admin.py中注册蓝图对象，添加subdomain&#x3D;’admin’即为该蓝图设置子域名admin；<br>再在hosts文件中添加记录：10.240.142.216 admin.example<br>📌再在hosts文件中添加记录：10.240.142.216 admin.example.com后，我们便可以通过域名：<a href="http://admin.example.com:5000/ad%E6%9D%A5%E8%AE%BF%E9%97%AE%E8%AF%A5%E8%93%9D%E5%9B%BE%EF%BC%88%E4%B8%8B%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%9C%A8%E4%B8%8A%E4%B8%80%E7%BA%A7%E5%B7%A6%E4%BE%A7%EF%BC%89%EF%BC%9B">http://admin.example.com:5000/ad来访问该蓝图（下一级域名在上一级左侧）；</a><br>        from flask import Blueprint<br>        bp &#x3D; Blueprint(‘admin’,<strong>name</strong>,subdomain &#x3D; ‘admin’)<br>        @bp.route(‘&#x2F;ad’)<br>        def admin():<br>            return ‘Admin Page’</p><h2 id="3-jinja2模板引擎"><a href="#3-jinja2模板引擎" class="headerlink" title="3.jinja2模板引擎"></a>3.jinja2模板引擎</h2><h3 id="1）模板的导入与使用"><a href="#1）模板的导入与使用" class="headerlink" title="1）模板的导入与使用"></a>1）模板的导入与使用</h3><pre><code class="hljs">Flask通过render_template来实现模板的渲染。要导入from flask     import rander_template，模板中注释需放在中</code></pre><h3 id="2）模板中的控制语句"><a href="#2）模板中的控制语句" class="headerlink" title="2）模板中的控制语句"></a>2）模板中的控制语句</h3><pre><code class="hljs">jinja2模板引擎中也可使用if和for控制语句，但是语句需要放置在&#123;% %&#125;中；if条件判断语句必须包含结束标签&#123;% endif %&#125;，其他部分与python中类似，可以与比较运算符&gt; &gt;= &lt; &lt;= == !=结合使用，或与逻辑运算符and,or,not,()结合使用；</code></pre><h3 id="3）过滤器的使用与自定义"><a href="#3）过滤器的使用与自定义" class="headerlink" title="3）过滤器的使用与自定义"></a>3）过滤器的使用与自定义</h3><p>&lt;— 自定义过滤器 —&gt;<br>def list_step(li):<br>    # 返回列表，步长为2<br>    return li[::2]</p><pre><code class="hljs"># 注册模板过滤器（filter）# 参数1为该过滤器调用的函数参数2为在前端中调用该过滤器使用的名称</code></pre><p>app.add_template_filter(list_step,’li2’)</p><p>可以在前端模板内  <!-- 原为 Jinja2 过滤器语法，已移除过滤器部分 -->的” | “后使用；</p><h2 id="4-Flask数据交互"><a href="#4-Flask数据交互" class="headerlink" title="4.Flask数据交互"></a>4.Flask数据交互</h2><h3 id="4）Cookie的使用"><a href="#4）Cookie的使用" class="headerlink" title="4）Cookie的使用"></a>4）Cookie的使用</h3><p>📌 在网站中，http请求是呈无序状态的<br>无序状态是指协议对于事务处理没有记忆能力，同一个服务器上你新打开的网页和之前打开的网页之间没有任何联系，你的当前请求和上一次请求究竟是不是一个用户发出的，服务器也无从得知；</p><p>Cookie一般通过Response对象的set_cookie()方法来设置<br>    # 前两个参数必须设置，后续参数则为可选参数<br>set_cookie(key,value[,max_age,expires,path,domain,secure,httponly,samesite])<br>key(或name)必需项，规定cookie的名称，字符串<br>value必需项，规定cookie的内容，字符串</p><p>除此之外，我们也可以通过修改响应对象Response的表单头headers来设置cookie：<br>@app.route(‘&#x2F;h’)<br>def set_cookie_h():<br>    resp &#x3D; Response(“设置Cookie！”)<br>    # 通过添加表头的键值对来实现cookie设置<br>    # 第一项为key&#x3D;value，需要同时设置这两个参数，后续项则用分号分隔<br>    resp.headers[‘Set-Cookie’] &#x3D; “ testname &#x3D; lisi; Expires &#x3D; SUN,01-Nov-2021 05:10:12 GMT; Max-Age&#x3D;3600; path&#x3D;&#x2F; “<br>    return resp</p>]]></content>
    
    
    <categories>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
