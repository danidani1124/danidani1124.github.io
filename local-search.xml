<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>torch-rechub</title>
    <link href="/2025/10/31/torch-rechub%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/10/31/torch-rechub%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="torch-rechub项目"><a href="#torch-rechub项目" class="headerlink" title="torch-rechub项目"></a>torch-rechub项目</h1><h2 id="项目简介（简介-关键位置）"><a href="#项目简介（简介-关键位置）" class="headerlink" title="项目简介（简介 + 关键位置）"></a>项目简介（简介 + 关键位置）</h2><ol><li>项目用途：一个基于 PyTorch 的推荐系统工具箱（matching、ranking、multi-task 等），包含模型、数据处理、训练器与示例脚本。</li><li>主要目录（你会用到的）：</li></ol><ul><li>matching：匹配&#x2F;检索模型实现（其中 dssm.py 实现了 Deep Structured Semantic Model，<strong>两塔结构</strong>）。</li><li>basic：基础组件（features、layers、MLP、EmbeddingLayer 等）。</li><li>utils：数据工具与帮助函数（data.py 提供 MatchDataGenerator、df_to_dict、pad&#x2F;neg-sample等）。</li><li>trainers：训练器（MatchTrainer 提供 point&#x2F;pair&#x2F;list 三种模式，保存模型、inference embedding 等）。</li><li>matching：matching 的示例脚本（例如 run_ml_dssm.py，对 MovieLens 做了完整的预处理、训练和评估流程）。<br>README.md：包含运行示例命令（也演示了运行 run_ml_dssm.py 的方法）。</li></ul><h2 id="核心组件（简要契约）"><a href="#核心组件（简要契约）" class="headerlink" title="核心组件（简要契约）"></a>核心组件（简要契约）</h2><ol><li>输入（数据）：CSV 原始行为日志（至少包含 user_id, item_id, timestamp），可带属性列（如 gender、age、genres 等）。示例脚本会对类别做 LabelEncoder 并把 id +1（0 用作 padding）。</li><li>特征（代码层面）：使用 SparseFeature, SequenceFeature, DenseFeature 在脚本里声明用户塔与物品塔所需特征并传入模型。</li><li>模型输出：两塔分别输出 L2 归一化后的用户&#x2F;物品向量（embedding）。训练器会保存 model.pth；可调用 MatchTrainer.inference_embedding 导出用户&#x2F;物品 embedding 做召回&#x2F;评估。</li><li>训练模式：默认是 point-wise（MatchTrainer mode&#x3D;0），也支持 pair-wise（BPR）和 list-wise。</li></ol><h2 id="用例：训练双塔（DSSM）的步骤（从零到可运行）"><a href="#用例：训练双塔（DSSM）的步骤（从零到可运行）" class="headerlink" title="用例：训练双塔（DSSM）的步骤（从零到可运行）"></a>用例：训练双塔（DSSM）的步骤（从零到可运行）</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>  最简单：使用仓库自带&#x2F;示例的 MovieLens 预处理文件（run_ml_dssm.py 默认读取 .&#x2F;data&#x2F;ml-1m&#x2F;ml-1m_sample.csv）</p><h3 id="查看-修改特征定义"><a href="#查看-修改特征定义" class="headerlink" title="查看&#x2F;修改特征定义"></a>查看&#x2F;修改特征定义</h3><p>在示例脚本 run_ml_dssm.py 中会构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">user_features = [SparseFeature(<span class="hljs-string">&#x27;user_id&#x27;</span>, vocab_size=..., embed_dim=<span class="hljs-number">16</span>), ...]<br>user_features += [SequenceFeature(<span class="hljs-string">&quot;hist_movie_id&quot;</span>, vocab_size=..., embed_dim=<span class="hljs-number">16</span>, pooling=<span class="hljs-string">&quot;mean&quot;</span>, shared_with=<span class="hljs-string">&quot;movie_id&quot;</span>)]<br>item_features = [SparseFeature(<span class="hljs-string">&#x27;movie_id&#x27;</span>, vocab_size=..., embed_dim=<span class="hljs-number">16</span>), ...]<br></code></pre></td></tr></table></figure><p>（vocab_size 通常为该列的最大编码 + 1）。</p><h3 id="配置模型超参（示例）"><a href="#配置模型超参（示例）" class="headerlink" title="配置模型超参（示例）"></a>配置模型超参（示例）</h3><p>在 run_ml_dssm.py，模型构建示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">model = DSSM(<br>    user_features,<br>    item_features,<br>    temperature=<span class="hljs-number">0.02</span>,<br>    user_params=&#123;<span class="hljs-string">&quot;dims&quot;</span>: [<span class="hljs-number">256</span>,<span class="hljs-number">128</span>,<span class="hljs-number">64</span>], <span class="hljs-string">&quot;activation&quot;</span>: <span class="hljs-string">&quot;prelu&quot;</span>&#125;,<br>    item_params=&#123;<span class="hljs-string">&quot;dims&quot;</span>: [<span class="hljs-number">256</span>,<span class="hljs-number">128</span>,<span class="hljs-number">64</span>], <span class="hljs-string">&quot;activation&quot;</span>: <span class="hljs-string">&quot;prelu&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p>调整 dims 控制 MLP 宽度&#x2F;深度；embed_dim 在 Feature 定义控制 embedding 大小。</p><h3 id="运行训练（示例命令）"><a href="#运行训练（示例命令）" class="headerlink" title="运行训练（示例命令）"></a>运行训练（示例命令）</h3><ul><li>如果使用 CPU 或小机器，请把 batch_size 调小（e.g., 1024 或 256）。在有 GPU 时可用大 batch。</li></ul><p><code>vocab_size = 最大编码 + 1 就是「one-hot 向量长度」——Embedding 表总行数。</code><br><code>&quot;dims&quot;: [256,128,64] 表示把特征先过 3 层全连接，依次 256→128→64 维；&quot;activation&quot;: &quot;prelu&quot; 是每层后面接的激活函数。</code></p><ul><li>在项目根目录下运行：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用默认示例数据（MovieLens）</span><br>python .\examples\matching\run_ml_dssm.py --dataset_path .\data\ml-1m\ml-1m_sample.csv --device cpu --epoch 10 --batch_size 1024 --save_dir .\saved\dssm_test\<br></code></pre></td></tr></table></figure><table><thead><tr><th>片段</th><th>含义</th></tr></thead><tbody><tr><td><code>python .\examples\matching\run_ml_dssm.py</code></td><td>启动官方写好的“一站式”演示脚本，里面已经包好：读数据 → 构造特征 → 建塔 → 训练 → 导出向量。</td></tr><tr><td><code>--dataset_path .\data\ml-1m\ml-1m_sample.csv</code></td><td>告诉脚本“我用哪份数据”。这里给的其实是 <strong>MovieLens-1M 的采样子集</strong>（1000 用户左右，几十秒就能跑完）。如果你想换成自己的数据，只要保持列名一致（user_id, item_id, rating 或 label），把路径指过去即可。</td></tr><tr><td><code>--device cpu</code></td><td>强制用 CPU 训练（没 GPU 或想省显存时写这个）。</td></tr><tr><td><code>--epoch 10</code></td><td>一共跑 10 个轮次，先快速看效果。</td></tr><tr><td><code>--batch_size 1024</code></td><td>每步喂 1024 条样本，CPU 一般 512~2048 都可。</td></tr><tr><td><code>--save_dir .\saved\dssm_test\</code></td><td>训练结束后，脚本会把：<br>① 最好模型 <code>best_model.pt</code><br>② 用户塔向量 <code>user_embedding.npy</code><br>③ 物品塔向量 <code>item_embedding.npy</code><br>④ 配置文件 <code>args.json</code><br>全都丢进这个文件夹，方便你下一步 Faiss 建索引或直接加载做召回。</td></tr></tbody></table><h3 id="训练与评估流程（脚本内部）"><a href="#训练与评估流程（脚本内部）" class="headerlink" title="训练与评估流程（脚本内部）"></a>训练与评估流程（脚本内部）</h3><p>脚本会：<br>    读 CSV、LabelEncode、构造序列 hist（generate_seq_feature_match）；<br>    构造 MatchDataGenerator，得到 (train_dl, test_dl, item_dl)；<br>    用 MatchTrainer.fit(train_dl) 训练并保存 model.pth；<br>    再用 trainer.inference_embedding 导出 user&#x2F;item embedding，并用 match_evaluation 评估 topk 准确率（示例中会打印结果）。</p><p><code>LabelEncoder（来自 sklearn.preprocessing）把类别型（categorical）变量映射为连续的整数标签（0,1,2,...）。它只处理一维标签数组。</code><br><code>这里把编码结果 +1 的原因：保留 0 作为 padding 索引（sequence padding），embedding 的 index 0 用作填充。</code></p><p>本周主要学习了基于 PyTorch 的推荐系统工具箱 torch-rechub，重点研究了其双塔模型（DSSM）的实现原理和应用。该项目采用模块化设计，包含特征工程、模型构建、训练优化等完整流程。在特征处理方面，学习了如何使用 LabelEncoder 进行类别型特征的编码转换，以及如何构建用户-物品交互序列特征。在模型架构上，掌握了双塔模型中用户塔和物品塔的构建方法，理解了如何通过 embedding 层和 MLP 层提取特征表示。在训练部分，熟悉了点击预测任务的实现方式，包括负样本采样、批处理数据加载和模型参数优化等环节。通过 MovieLens 数据集的实践，深入理解了推荐系统从数据预处理到模型训练的完整工作流程，为后续开发推荐系统奠定了良好基础。</p><h2 id="特征处理"><a href="#特征处理" class="headerlink" title="特征处理"></a>特征处理</h2><h3 id="LabelEncoder-类别型特征的编码转换"><a href="#LabelEncoder-类别型特征的编码转换" class="headerlink" title="LabelEncoder 类别型特征的编码转换"></a>LabelEncoder 类别型特征的编码转换</h3><p>👉<br>LabelEncoder 把物品编号映射成连续整数（0~N），<br>这些整数就能用来在 Embedding 表中查到对应的向量。</p><h3 id="用户-物品交互序列特征"><a href="#用户-物品交互序列特征" class="headerlink" title="用户-物品交互序列特征"></a>用户-物品交互序列特征</h3><p>🧩 序列推荐（sequential recommendation）的关键概念<br>模型用用户的历史行为（点击序列） [i1, i2] 来预测他是否会点击 i3</p><h3 id="双塔模型中用户塔和物品塔的构建方法"><a href="#双塔模型中用户塔和物品塔的构建方法" class="headerlink" title="双塔模型中用户塔和物品塔的构建方法"></a>双塔模型中用户塔和物品塔的构建方法</h3><ol><li><p>双塔基本架构<br> 用户塔（User Tower）和物品塔（Item Tower）是完全独立的<br> 每个塔的基本结构：Input -&gt; Embedding Layer -&gt; MLP Layers -&gt; L2 Normalization<br> 最终通过内积计算相似度得到匹配分数</p><p> <code>“塔的输入维度”就是把所有特征对应的 Embedding 向量挨个拼起来后，喂给 MLP 的那一串数字的总长度</code></p><p> 假设用户塔只用 3 个稀疏特征：</p><table><thead><tr><th>特征名</th><th>取值举例</th><th>词表大小 vocab_size</th><th>嵌入维度 embed_dim</th></tr></thead><tbody><tr><td>user_id</td><td>10001</td><td>50 000</td><td>64</td></tr><tr><td>gender</td><td>“M”</td><td>3</td><td>16</td></tr><tr><td>age_bucket</td><td>“25-34”</td><td>10</td><td>16</td></tr></tbody></table><ol><li>每个特征先查自己的 Embedding 表，得到一条向量：<br> user_id → 64 维<br> gender → 16 维<br> age_bucket → 16 维</li><li>拼接（concat） → 一条用户样本的向量长度<br> 64 + 16 + 16 &#x3D; 96 维 这 96 就是“用户塔的输入维度”。</li><li>随后塔里的 MLP 接收这 96 维，再往下压缩：96 → 256 → 128 → 64（输出向量）</li></ol><p> <code>共享的embedding层（处理所有稀疏特征）self.embedding = EmbeddingLayer(user_features + item_features)</code><br> 一次性给“所有稀疏特征”建一张公共的 Embedding 查表字典</p><p> <strong>为什么需要“共享”</strong><br>     稀疏特征（user_id、item_id、category…）都要先 map 成稠密向量才能进神经网络。<br>     如果用户塔和物品塔各自建自己的 nn.Embedding，<br>     同一个 user_id 会出现两份矩阵，浪费显存；<br>     梯度更新也互不干扰，可能把相同 ID 学到两个完全不同的向量，效果反而差。<br>     把<strong>所有稀疏特征</strong>扔给同一个 EmbeddingLayer 对象，它就：<br>     -按特征名自动去重；<br>     为每个特征维护一张 vocab_size × embed_dim 的表；<br>     前向传播时“谁用谁来查”，<strong>同 ID 同特征永远返回同一向量。</strong></p></li><li><p>特征表示过程<br> 2.1 Embedding 层（稀疏特征转稠密）<br> Embedding 处理过程：<br> 每个稀疏特征先通过 LabelEncoder 转为整数 ID<br> 每个 ID 查表得到对应的 embedding 向量（如16维）<br> 序列特征（如历史观看）会先embed再做pooling<br> 所有特征的 embedding 向量拼接，得到该塔的输入向量<br> <code>pooling = 把“一串向量”压成“一个向量”</code><br> 用户看过 50 部影片 → 50 个 item_id<br> 每个 item_id 先 embed 成 16 维 → 得到形状 (50, 16)<br> pooling 把这 50 条 16 维向量压成 1 条 16 维向量（或 32&#x2F;64 维，看你设置），再和用户其他特征拼在一起喂给塔。<br> 2.2 MLP 层（特征交互）<br> <code>MLP = 把“拼好的特征”层层压缩+非线性变换，输出一个紧凑的向量表示，让双塔能算相似度、也能被 Faiss/Annoy 快速检索。</code></p><p> 2.3 L2归一化 <code>把向量除以自己的 模长，让结果变成 单位向量（长度=1）</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>推荐算法</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双塔模型</title>
    <link href="/2025/10/24/%E5%8F%8C%E5%A1%94%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/10/24/%E5%8F%8C%E5%A1%94%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://zhuanlan.zhihu.com/p/601743047">https://zhuanlan.zhihu.com/p/601743047</a><br><a href="https://tianchi.aliyun.com/notebook/844878">https://tianchi.aliyun.com/notebook/844878</a></p><h2 id="词汇"><a href="#词汇" class="headerlink" title="词汇"></a>词汇</h2><h3 id="特征（feature）就是能被机器拿来计算、比较、做决策的“量化事实”。"><a href="#特征（feature）就是能被机器拿来计算、比较、做决策的“量化事实”。" class="headerlink" title="特征（feature）就是能被机器拿来计算、比较、做决策的“量化事实”。"></a>特征（feature）<code>就是能被机器拿来计算、比较、做决策的“量化事实”。</code></h3><h3 id="近似最近邻搜索（ANN）它并不追求找到与用户向量距离最近的精确物品向量，而是在可接受的误差范围内，快速找出与用户向量距离较近的一些物品向量"><a href="#近似最近邻搜索（ANN）它并不追求找到与用户向量距离最近的精确物品向量，而是在可接受的误差范围内，快速找出与用户向量距离较近的一些物品向量" class="headerlink" title="近似最近邻搜索（ANN）它并不追求找到与用户向量距离最近的精确物品向量，而是在可接受的误差范围内，快速找出与用户向量距离较近的一些物品向量"></a>近似最近邻搜索（ANN）<code>它并不追求找到与用户向量距离最近的精确物品向量，而是在可接受的误差范围内，快速找出与用户向量距离较近的一些物品向量</code></h3><h3 id="在数据库为什么加上索引可以加快查询？"><a href="#在数据库为什么加上索引可以加快查询？" class="headerlink" title="在数据库为什么加上索引可以加快查询？"></a>在数据库为什么加上索引可以加快查询？</h3><p><code>没有索引 = 你查“喵”字只能从第一页逐页翻到最后一页，最坏情况翻完全书。</code><br><code>有索引 = 先翻前面的部首检字表，瞬间定位到“喵”在第 863 页，直接跳过去。</code><br><strong>索引把“按值查找”的全表扫描（O(n)）变成树形二分搜索（O(log n) 甚至 O(1)），所以快。</strong></p><p>数据行存在聚簇索引（主键）的叶子页里，相当于字典正文。<br>你给 name 字段再加二级索引，数据库会额外建一棵 B+ 树，叶子只存 name→主键 的映射。<br>查询 WHERE name&#x3D;’Alice’ 时：<br>走 name 索引树，** log n 步** 找到对应主键；<br>用主键回表（一次随机 IO）拿整行；<br>整体耗时 ≈ 树高 3-4 次磁盘页读取，而不是几十万次。</p><h3 id="冷启动：系统“从零开始”，没有历史数据，模型只能靠猜。"><a href="#冷启动：系统“从零开始”，没有历史数据，模型只能靠猜。" class="headerlink" title="冷启动：系统“从零开始”，没有历史数据，模型只能靠猜。"></a>冷启动：<code>系统“从零开始”，没有历史数据，模型只能靠猜。</code></h3><h3 id="特征交叉"><a href="#特征交叉" class="headerlink" title="特征交叉"></a>特征交叉</h3><p><code>特征交叉就是把两个或多个特征组合起来，形成一个新的特征，用来表达它们之间的相互关系</code></p><h3 id="CNN-卷积神经"><a href="#CNN-卷积神经" class="headerlink" title="CNN(卷积神经)"></a>CNN(卷积神经)</h3><pre><code class="hljs">            ┌────────────────────┐            │ 输入层（图像）     │                      └───────┬────────────┘                    ↓            ┌────────────────────┐            │ 卷积层（提取局部特征│             └───────┬────────────┘                    ↓            ┌────────────────────┐            │ 激活层（ReLU）     │            └───────┬────────────┘                    ↓            ┌────────────────────┐            │ 池化层（下采样）   │            └───────┬────────────┘                    ↓            ┌────────────────────┐            │ 全连接层（分类）   │            └───────┬────────────┘                    ↓            ┌────────────────────┐            │ 输出层（预测结果） │            └────────────────────┘</code></pre><p>2️⃣ 卷积层（Convolution Layer）<br>从输入中提取局部特征，比如边缘、角点、纹理等。<br>3️⃣ 激活层（Activation Layer）<br>卷积只是线性运算，还不够聪明。<br>于是我们加一个激活函数（非线性变换），让网络可以学习复杂的模式。<br>4️⃣ 池化层（Pooling Layer）<br>作用：降维、提取主要特征、防止过拟合<br>全连接层（Fully Connected Layer）</p><p>经过几层卷积和池化后，我们得到了抽象的特征表示。</p><p>然后把它“摊平”（flatten）成一个向量，送入全连接层（Dense Layer），</p><h3 id="🧠-DNN-是什么？DNN（Deep-Neural-Network）-深度神经网络"><a href="#🧠-DNN-是什么？DNN（Deep-Neural-Network）-深度神经网络" class="headerlink" title="🧠 DNN 是什么？DNN（Deep Neural Network）&#x3D; 深度神经网络"></a>🧠 DNN 是什么？DNN（Deep Neural Network）&#x3D; 深度神经网络</h3><p>输入层 → 隐藏层1 → 隐藏层2 → … → 输出层</p><p>输入：一个用户的特征（年龄、性别、兴趣、观看时长等）<br>↓<br>隐藏层1：提取简单组合特征<br>↓<br>隐藏层2：提取更深层的抽象关系<br>↓<br>输出层：预测点击概率、评分或分类结果</p><h3 id="MLP（Multi-Layer-Perceptron）多层感知机"><a href="#MLP（Multi-Layer-Perceptron）多层感知机" class="headerlink" title="MLP（Multi-Layer Perceptron）多层感知机"></a>MLP（Multi-Layer Perceptron）多层感知机</h3><p>🧠一、MLP 是什么？<br><code> MLP 是由多个“感知机（Perceptron）”堆叠起来的神经网络，能够自动从输入特征中学习复杂的映射关系。</code></p><p>🧩 二、什么是“感知机（Perceptron）”？<br>感知机是神经网络中最基本的“神经元”，是整个网络的最小计算单元。<br>它的数学形式非常简单👇：y&#x3D;f(Wx+b)<br>x：输入特征向量（比如年龄、性别、观看时长等）</p><p>W：权重（每个特征的重要程度）</p><p>b：偏置项</p><p>f：激活函数（ReLU、Sigmoid等）</p><p>假设我们要预测“一个用户是否会点击视频”，<br>输入两个特征：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x1</span> = 用户是否喜欢这个主题<br><span class="hljs-attr">x2</span> = 视频时长<br></code></pre></td></tr></table></figure><p>模型计算：<br>y&#x3D;f(0.8x1​+0.2x2​−0.3)<br>输出一个概率，比如 0.9，表示点击的可能性很高。</p><h3 id="🔗-“多层感知机”是什么意思？"><a href="#🔗-“多层感知机”是什么意思？" class="headerlink" title="🔗 “多层感知机”是什么意思？"></a>🔗 “多层感知机”是什么意思？</h3><p>单个感知机太简单，只能做线性分类（像一条直线分界）。<br>于是我们叠加多层：输入层 → 隐藏层1 → 隐藏层2 → 输出层<br>每一层都是若干个感知机（神经元），层与层之间全连接（fully connected）。</p><p>通过多层非线性变换，模型能学习<br>特征的组合；</p><p>高阶特征交互；</p><p>非线性关系</p><p>📘 举个直观比喻：<br>单层感知机：像一条直线，只能分开简单的两类；<br>多层感知机（MLP）：像一张弯曲的曲线，可以适应复杂边界。</p><p>⚙️ 四、MLP 的结构图（文字版）<br>输入层（Feature Input）<br>   ↓<br>隐藏层1：多个神经元 + 激活函数<br>   ↓<br>隐藏层2：多个神经元 + 激活函数<br>   ↓<br>输出层（预测结果）</p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>在机器学习或深度学习中，我们有：L(θ)<br>L：损失函数（Loss Function），衡量模型预测与真实的误差<br>θ：模型参数（例如权重 W、偏置 b）目标是找到一组参数 𝜃，使损失尽可能小<br>于是我们用梯度下降法：θ:&#x3D;θ−η⋅∇θ​L(θ)  学习率（learning rate），决定每次走多大步</p><h2 id="一、什么是双塔模型？"><a href="#一、什么是双塔模型？" class="headerlink" title="一、什么是双塔模型？"></a>一、什么是双塔模型？</h2><p>它的核心思想是：<br>👉 把“用户”和“物品”分开建模，各自用一个“塔”来表示，然后通过比较它们的向量（embedding）来计算匹配程度。</p><h2 id="二、结构长什么样？"><a href="#二、结构长什么样？" class="headerlink" title="二、结构长什么样？"></a>二、结构长什么样？</h2><pre><code class="hljs">  用户特征 --&gt; [用户塔] ---&gt; 用户向量 U                                     \                                      &gt; 点积（或相似度） --&gt; 预测分数                                     /  物品特征 --&gt; [物品塔] ---&gt; 物品向量 I</code></pre><p><strong>左边塔</strong>：用户塔（User Tower）</p><ul><li>输入：用户的特征（如ID、性别、兴趣、历史行为等）</li><li>输出：一个用户向量 U（用数字组成的一个向量，比如 [0.1, 0.5, 0.3, …]）</li></ul><p><strong>右边塔</strong>：物品塔（Item Tower）</p><ul><li>输入：物品的特征（如商品ID、类别、标签、标题等）</li><li>输出：一个物品向量 I</li></ul><p><em><strong>两塔的参数通常不共享，输出维度相同的向量（如128维）。</strong></em></p><p><em><strong>用户塔和物品塔不是独立训练的，而是通过联合优化目标端到端训练。二者的Embedding需要在同一向量空间中对齐。</strong></em></p><p><strong>匹配部分</strong>：</p><ul><li>比较 U 和 I 的相似度（通常用点积或余弦相似度），</li><li>相似度越高，说明这个用户越可能喜欢这个物品。</li></ul><h2 id="三、为什么叫“双塔”？"><a href="#三、为什么叫“双塔”？" class="headerlink" title="三、为什么叫“双塔”？"></a>三、为什么叫“双塔”？</h2><ul><li>因为模型的结构看起来像两座并列的塔：</li><li>两边都各自有几层神经网络（用来学习特征的表示）。</li><li>最后才在顶部“相遇”进行匹配。</li><li>这两座塔可以是相同结构的，也可以是不同结构的。</li></ul><h2 id="四、有什么好处？"><a href="#四、有什么好处？" class="headerlink" title="四、有什么好处？"></a>四、有什么好处？</h2><p><code>双塔模型最厉害的一点是——效率高！</code></p><ol><li><p>离线计算物品向量<br>所有<strong>物品的向量</strong>可以<strong>提前算好并存起来</strong>。<br>这样当有一个<strong>用户来时，只需要计算一次用户向量</strong>，然后和<strong>数据库里所有物品向量做相似度搜索</strong>，就能快速找到最匹配的物品。<br>👉 这比每次都要重新计算“用户×物品”的组合要快得多！</p></li><li><p>可扩展性强<br>适合上亿级的物品（比如抖音视频、淘宝商品、YouTube视频等）。</p></li><li><p>可灵活扩展<br>可以把特征换成别的（比如文字、图像、语音），仍然适用。</p></li></ol><h2 id="双塔模型代码实现"><a href="#双塔模型代码实现" class="headerlink" title="双塔模型代码实现"></a>双塔模型代码实现</h2><h3 id="函数解释"><a href="#函数解释" class="headerlink" title="函数解释"></a>函数解释</h3><p>1️⃣ Dot 是什么 <code>similarity = Dot(axes=-1, normalize=True, name=&quot;cosine_similarity&quot;)([user_embedding, item_embedding])</code><br>Dot 是 Keras 的一个层（tensorflow.keras.layers.Dot），用于计算两个张量之间的 点积（dot product）。</p><p>点积（dot product）&#x3D; 两个向量对应元素相乘后求和。<br>例如：<br>u &#x3D; [1, 2, 3]<br>v &#x3D; [4, 5, 6]<br>u·v &#x3D; 1×4 + 2×5 + 3×6 &#x3D; 32</p><p>2️⃣ axes&#x3D;-1 的含义</p><p>在最后一个维度上进行点积。<br>假设：<br>user_embedding 的形状是 (batch_size, embedding_dim)，比如 (5, 8)；<br>item_embedding 的形状是 (batch_size, embedding_dim)，比如 (5, 8)。</p><p>那么：<br>Dot(axes&#x3D;-1) 会对每对 (user[i], item[i]) 进行最后一个维度的点积；<br>输出的形状会是 (batch_size, 1)。<br>也就是说，每一对（用户向量，物品向量）都会得到一个相似度分数。</p><p>3️⃣ normalize&#x3D;True 是什么？<br><code>在做点积前，先把两个向量都进行 L2 归一化（normalize）。</code><br>L2 归一化：把向量的长度（模）变成 1：</p><p>4️⃣ 所以这层的功能是：<code>✅ 计算用户向量与物品向量的余弦相似度。</code></p><h3 id="self-model-compile-optimizer-Adam-learning-rate-0-001-loss-”binary-crossentropy”-metrics-“accuracy”-这是干嘛的？"><a href="#self-model-compile-optimizer-Adam-learning-rate-0-001-loss-”binary-crossentropy”-metrics-“accuracy”-这是干嘛的？" class="headerlink" title="self.model.compile( optimizer&#x3D;Adam(learning_rate&#x3D;0.001), loss&#x3D;”binary_crossentropy”, metrics&#x3D;[“accuracy”] ) 这是干嘛的？"></a>self.model.compile( optimizer&#x3D;Adam(learning_rate&#x3D;0.001), loss&#x3D;”binary_crossentropy”, metrics&#x3D;[“accuracy”] ) 这是干嘛的？</h3><p>💡 告诉 TensorFlow：<br>“我这个模型要怎么训练、用什么优化器、用什么损失函数、以及在训练过程中关注哪些指标。”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">双塔模型（Two-Tower Model）完整实现</span><br><span class="hljs-string">来源：https://blog.csdn.net/goTsHgo/article/details/144259481</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Input, Dense, Dot, Flatten, Concatenate<br><span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Model<br><span class="hljs-keyword">from</span> tensorflow.keras.optimizers <span class="hljs-keyword">import</span> Adam<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> matplotlib<br><br>matplotlib.use(<span class="hljs-string">&#x27;Agg&#x27;</span>)  <span class="hljs-comment"># 使用非交互式后端</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;WenQuanYi Zen Hei&#x27;</span>]  <span class="hljs-comment"># 设置中文字体</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoTowerModel</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;双塔模型实现类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, user_feature_dim, item_feature_dim, embedding_dim=<span class="hljs-number">8</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        初始化双塔模型</span><br><span class="hljs-string"></span><br><span class="hljs-string">        参数:</span><br><span class="hljs-string">            user_feature_dim: 用户特征维度</span><br><span class="hljs-string">            item_feature_dim: 物品特征维度</span><br><span class="hljs-string">            embedding_dim: 嵌入向量维度</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.user_feature_dim = user_feature_dim<br>        <span class="hljs-variable language_">self</span>.item_feature_dim = item_feature_dim<br>        <span class="hljs-variable language_">self</span>.embedding_dim = embedding_dim          <span class="hljs-comment">#双塔输出统一 embedding 维数</span><br>        <span class="hljs-variable language_">self</span>.model = <span class="hljs-literal">None</span>                           <span class="hljs-comment"># 完整训练模型（用户+物品→相似度）</span><br>        <span class="hljs-variable language_">self</span>.user_model = <span class="hljs-literal">None</span>                      <span class="hljs-comment"># 仅用户塔（用户→向量）</span><br>        <span class="hljs-variable language_">self</span>.item_model = <span class="hljs-literal">None</span>                      <span class="hljs-comment"># 仅物品塔（物品→向量）</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">build_model</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;构建双塔模型架构&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 用户塔</span><br>        user_input = Input(shape=(<span class="hljs-variable language_">self</span>.user_feature_dim,), name=<span class="hljs-string">&quot;user_input&quot;</span>)   <span class="hljs-comment"># 定义一个 Keras 输入张量，形状 (user_feature_dim,)，用于送入用户特征（比如 [性别, 年龄, 历史行为]）。</span><br>        <span class="hljs-comment"># 把刚才那个输入张量连到一层全连接神经元，让它输出一个固定长度的向量，这就叫‘用户塔’。</span><br>        user_embedding = Dense(<span class="hljs-variable language_">self</span>.embedding_dim, activation=<span class="hljs-string">&quot;relu&quot;</span>, name=<span class="hljs-string">&quot;user_embedding&quot;</span>)(user_input)<br><br>        <span class="hljs-comment"># 物品塔</span><br>        item_input = Input(shape=(<span class="hljs-variable language_">self</span>.item_feature_dim,), name=<span class="hljs-string">&quot;item_input&quot;</span>)<br>        item_embedding = Dense(<span class="hljs-variable language_">self</span>.embedding_dim, activation=<span class="hljs-string">&quot;relu&quot;</span>, name=<span class="hljs-string">&quot;item_embedding&quot;</span>)(item_input)<br><br>        <span class="hljs-comment"># 匹配层：余弦相似度</span><br>        <span class="hljs-comment"># 用户塔输出的向量和物品塔输出的向量连接在一起，计算它们的“相似度”，从而判断用户和物品是否匹配（喜欢 / 不喜欢）。</span><br>        similarity = Dot(axes=-<span class="hljs-number">1</span>, normalize=<span class="hljs-literal">True</span>, name=<span class="hljs-string">&quot;cosine_similarity&quot;</span>)([user_embedding, item_embedding])<br><br>        <span class="hljs-comment"># 构建完整模型</span><br>        <span class="hljs-variable language_">self</span>.model = Model(inputs=[user_input, item_input], outputs=similarity)<br><br>        <span class="hljs-comment"># 构建用户塔模型（用于生成用户向量）</span><br>        <span class="hljs-variable language_">self</span>.user_model = Model(inputs=user_input, outputs=user_embedding)<br><br>        <span class="hljs-comment"># 构建物品塔模型（用于生成物品向量）</span><br>        <span class="hljs-variable language_">self</span>.item_model = Model(inputs=item_input, outputs=item_embedding)<br><br>        <span class="hljs-comment"># 编译模型</span><br>        <span class="hljs-variable language_">self</span>.model.<span class="hljs-built_in">compile</span>(<br>            optimizer=Adam(learning_rate=<span class="hljs-number">0.001</span>),<br>            loss=<span class="hljs-string">&quot;binary_crossentropy&quot;</span>,<br>            metrics=[<span class="hljs-string">&quot;accuracy&quot;</span>]<br>        )<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.model<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_data</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;准备训练和测试数据&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 用户特征：性别（0=女, 1=男）、年龄（18-60）、历史行为（物品ID）</span><br>        user_features = np.array([<br>            [<span class="hljs-number">1</span>, <span class="hljs-number">25</span>, <span class="hljs-number">101</span>],  <span class="hljs-comment"># 用户1：男，25岁，历史行为物品101</span><br>            [<span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">102</span>],  <span class="hljs-comment"># 用户2：女，30岁，历史行为物品102</span><br>            [<span class="hljs-number">1</span>, <span class="hljs-number">35</span>, <span class="hljs-number">103</span>],  <span class="hljs-comment"># 用户3：男，35岁，历史行为物品103</span><br>            [<span class="hljs-number">0</span>, <span class="hljs-number">28</span>, <span class="hljs-number">104</span>],  <span class="hljs-comment"># 用户4：女，28岁，历史行为物品104</span><br>            [<span class="hljs-number">1</span>, <span class="hljs-number">22</span>, <span class="hljs-number">105</span>],  <span class="hljs-comment"># 用户5：男，22岁，历史行为物品105</span><br>        ])<br><br>        <span class="hljs-comment"># 物品特征：类别（0=电影, 1=书籍）、热度（0-1）</span><br>        item_features = np.array([<br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>],  <span class="hljs-comment"># 物品1：电影，热度0.8</span><br>            [<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>],  <span class="hljs-comment"># 物品2：书籍，热度0.5</span><br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0.9</span>],  <span class="hljs-comment"># 物品3：电影，热度0.9</span><br>            [<span class="hljs-number">1</span>, <span class="hljs-number">0.7</span>],  <span class="hljs-comment"># 物品4：书籍，热度0.7</span><br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0.6</span>],  <span class="hljs-comment"># 物品5：电影，热度0.6</span><br>        ])<br><br>        <span class="hljs-comment"># 标签：用户是否喜欢该物品</span><br>        labels = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])  <span class="hljs-comment"># 正样本和负样本</span><br><br>        <span class="hljs-keyword">return</span> user_features, item_features, labels<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train_model</span>(<span class="hljs-params">self, epochs=<span class="hljs-number">50</span>, batch_size=<span class="hljs-number">2</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;训练模型&quot;&quot;&quot;</span><br>        user_features, item_features, labels = <span class="hljs-variable language_">self</span>.prepare_data()<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始训练双塔模型...&quot;</span>)<br>        history = <span class="hljs-variable language_">self</span>.model.fit(<br>            [user_features, item_features],<br>            labels,<br>            epochs=epochs,<br>            batch_size=batch_size,<br>            verbose=<span class="hljs-number">1</span>,<br>            validation_split=<span class="hljs-number">0.2</span><br>        )<br><br>        <span class="hljs-keyword">return</span> history<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_similarity</span>(<span class="hljs-params">self, user_features, item_features</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;预测用户和物品的相似度&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.model.predict([user_features, item_features])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_user_embedding</span>(<span class="hljs-params">self, user_features</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;获取用户嵌入向量&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.user_model.predict(user_features)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_item_embedding</span>(<span class="hljs-params">self, item_features</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;获取物品嵌入向量&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.item_model.predict(item_features)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visualize_training</span>(<span class="hljs-params">self, history</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;可视化训练过程&quot;&quot;&quot;</span><br>        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">12</span>))<br><br>        <span class="hljs-comment"># 训练损失</span><br>        ax1.plot(history.history[<span class="hljs-string">&#x27;loss&#x27;</span>], label=<span class="hljs-string">&#x27;训练损失&#x27;</span>)<br>        ax1.plot(history.history[<span class="hljs-string">&#x27;val_loss&#x27;</span>], label=<span class="hljs-string">&#x27;验证损失&#x27;</span>)<br>        ax1.set_title(<span class="hljs-string">&#x27;模型损失&#x27;</span>)<br>        ax1.set_xlabel(<span class="hljs-string">&#x27;轮次&#x27;</span>)<br>        ax1.set_ylabel(<span class="hljs-string">&#x27;损失&#x27;</span>)<br>        ax1.legend()<br>        ax1.grid(<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-comment"># 训练准确率</span><br>        ax2.plot(history.history[<span class="hljs-string">&#x27;accuracy&#x27;</span>], label=<span class="hljs-string">&#x27;训练准确率&#x27;</span>)<br>        ax2.plot(history.history[<span class="hljs-string">&#x27;val_accuracy&#x27;</span>], label=<span class="hljs-string">&#x27;验证准确率&#x27;</span>)<br>        ax2.set_title(<span class="hljs-string">&#x27;模型准确率&#x27;</span>)<br>        ax2.set_xlabel(<span class="hljs-string">&#x27;轮次&#x27;</span>)<br>        ax2.set_ylabel(<span class="hljs-string">&#x27;准确率&#x27;</span>)<br>        ax2.legend()<br>        ax2.grid(<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-comment"># 用户嵌入向量可视化</span><br>        user_features, _, _ = <span class="hljs-variable language_">self</span>.prepare_data()<br>        user_embeddings = <span class="hljs-variable language_">self</span>.get_user_embedding(user_features)<br><br>        ax3.scatter(user_embeddings[:, <span class="hljs-number">0</span>], user_embeddings[:, <span class="hljs-number">1</span>],<br>                    c=[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;purple&#x27;</span>], s=<span class="hljs-number">100</span>)<br>        <span class="hljs-keyword">for</span> i, txt <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&#x27;用户1&#x27;</span>, <span class="hljs-string">&#x27;用户2&#x27;</span>, <span class="hljs-string">&#x27;用户3&#x27;</span>, <span class="hljs-string">&#x27;用户4&#x27;</span>, <span class="hljs-string">&#x27;用户5&#x27;</span>]):<br>            ax3.annotate(txt, (user_embeddings[i, <span class="hljs-number">0</span>], user_embeddings[i, <span class="hljs-number">1</span>]))<br>        ax3.set_title(<span class="hljs-string">&#x27;用户嵌入向量可视化&#x27;</span>)<br>        ax3.set_xlabel(<span class="hljs-string">&#x27;维度1&#x27;</span>)<br>        ax3.set_ylabel(<span class="hljs-string">&#x27;维度2&#x27;</span>)<br>        ax3.grid(<span class="hljs-literal">True</span>)<br><br>        <span class="hljs-comment"># 物品嵌入向量可视化</span><br>        _, item_features, _ = <span class="hljs-variable language_">self</span>.prepare_data()<br>        item_embeddings = <span class="hljs-variable language_">self</span>.get_item_embedding(item_features)<br><br>        ax4.scatter(item_embeddings[:, <span class="hljs-number">0</span>], item_embeddings[:, <span class="hljs-number">1</span>],<br>                    c=[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;purple&#x27;</span>], s=<span class="hljs-number">100</span>)<br>        <span class="hljs-keyword">for</span> i, txt <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&#x27;物品1&#x27;</span>, <span class="hljs-string">&#x27;物品2&#x27;</span>, <span class="hljs-string">&#x27;物品3&#x27;</span>, <span class="hljs-string">&#x27;物品4&#x27;</span>, <span class="hljs-string">&#x27;物品5&#x27;</span>]):<br>            ax4.annotate(txt, (item_embeddings[i, <span class="hljs-number">0</span>], item_embeddings[i, <span class="hljs-number">1</span>]))<br>        ax4.set_title(<span class="hljs-string">&#x27;物品嵌入向量可视化&#x27;</span>)<br>        ax4.set_xlabel(<span class="hljs-string">&#x27;维度1&#x27;</span>)<br>        ax4.set_ylabel(<span class="hljs-string">&#x27;维度2&#x27;</span>)<br>        ax4.grid(<span class="hljs-literal">True</span>)<br><br>        plt.tight_layout()<br>        plt.savefig(<span class="hljs-string">&#x27;training_visualization.png&#x27;</span>, dpi=<span class="hljs-number">300</span>, bbox_inches=<span class="hljs-string">&#x27;tight&#x27;</span>)<br>        plt.close()<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练可视化图表已保存为 &#x27;training_visualization.png&#x27;&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">demonstrate_recommendation</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;演示推荐功能&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n=== 双塔模型推荐演示 ===&quot;</span>)<br><br>        <span class="hljs-comment"># 测试用户特征 - 为每个物品复制相同的用户特征</span><br>        test_user = np.array([<br>            [<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">101</span>],  <span class="hljs-comment"># 用户特征：男性，28岁，历史行为物品101</span><br>            [<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">101</span>],<br>            [<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">101</span>],<br>            [<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">101</span>],<br>            [<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">101</span>]<br>        ])<br><br>        <span class="hljs-comment"># 测试物品特征</span><br>        test_items = np.array([<br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0.9</span>],  <span class="hljs-comment"># 物品1：电影，热度0.9</span><br>            [<span class="hljs-number">1</span>, <span class="hljs-number">0.7</span>],  <span class="hljs-comment"># 物品2：书籍，热度0.7</span><br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0.6</span>],  <span class="hljs-comment"># 物品3：电影，热度0.6</span><br>            [<span class="hljs-number">1</span>, <span class="hljs-number">0.8</span>],  <span class="hljs-comment"># 物品4：书籍，热度0.8</span><br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0.95</span>],  <span class="hljs-comment"># 物品5：电影，热度0.95</span><br>        ])<br><br>        <span class="hljs-comment"># 计算相似度</span><br>        scores = <span class="hljs-variable language_">self</span>.predict_similarity(test_user, test_items)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试用户特征：男性，28岁，历史行为物品101&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n物品推荐排序：&quot;</span>)<br><br>        items_info = [<span class="hljs-string">&#x27;电影(热度0.9)&#x27;</span>, <span class="hljs-string">&#x27;书籍(热度0.7)&#x27;</span>, <span class="hljs-string">&#x27;电影(热度0.6)&#x27;</span>, <span class="hljs-string">&#x27;书籍(热度0.8)&#x27;</span>, <span class="hljs-string">&#x27;电影(热度0.95)&#x27;</span>]<br><br>        <span class="hljs-comment"># 按分数排序</span><br>        sorted_indices = np.argsort(scores.flatten())[::-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> rank, idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(sorted_indices, <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;rank&#125;</span>. 物品<span class="hljs-subst">&#123;idx + <span class="hljs-number">1</span>&#125;</span> - <span class="hljs-subst">&#123;items_info[idx]&#125;</span> - 匹配分数: <span class="hljs-subst">&#123;scores[idx][<span class="hljs-number">0</span>]:<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br><br>        <span class="hljs-keyword">return</span> scores<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-string">&quot;&quot;&quot;主函数&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">60</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;双塔模型（Two-Tower Model）实现演示&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;来源：https://blog.csdn.net/goTsHgo/article/details/144259481&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">60</span>)<br><br>    <span class="hljs-comment"># 创建模型实例</span><br>    model = TwoTowerModel(user_feature_dim=<span class="hljs-number">3</span>, item_feature_dim=<span class="hljs-number">2</span>, embedding_dim=<span class="hljs-number">8</span>)<br><br>    <span class="hljs-comment"># 构建模型</span><br>    model.build_model()<br><br>    <span class="hljs-comment"># 打印模型结构</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n模型结构：&quot;</span>)<br>    model.model.summary()<br><br>    <span class="hljs-comment"># 训练模型</span><br>    history = model.train_model(epochs=<span class="hljs-number">50</span>)<br><br>    <span class="hljs-comment"># 可视化训练过程</span><br>    model.visualize_training(history)<br><br>    <span class="hljs-comment"># 演示推荐功能</span><br>    model.demonstrate_recommendation()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">60</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;双塔模型演示完成！&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">60</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>推荐算法</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Word2Vec</title>
    <link href="/2025/10/13/Word2Vec/"/>
    <url>/2025/10/13/Word2Vec/</url>
    
    <content type="html"><![CDATA[<h1 id="Gensim"><a href="#Gensim" class="headerlink" title="Gensim"></a>Gensim</h1><p><code>Gensim是在做自然语言处理时较为经常用到的一个工具库，主要用来以无监督的方式从原始的非结构化文本当中来学习到文本隐藏层的主题向量表达。</code></p><h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><p><strong>Word2Vec</strong> 模型 &#x3D; 两张表</p><ul><li>vocabulary（词 → 行号）</li><li>vectors（行号 → 200 维向量）<br><strong>KeyedVectors</strong> &#x3D; 只有第二张表（vectors），没有训练能力，纯查表。<br><strong>intersect_word2vec_format()</strong>&#x3D;「把外部 vectors 插进现有模型」的专用 API，不会扩增词汇表，只能「覆盖」已有词。<br>         <code>是 Gensim 库中 Word2Vec 模型的一个方法，主要用于将外部预训练的词向量（如 Google 的 Word2Vec 模型）与当前模型的词汇表进行交集操作。</code><br>         <code>它的作用是加载外部文件中的词向量，但仅加载那些与当前模型词汇表中已有单词匹配的向量。</code></li></ul><h2 id="🧩-第-1-步：学习-Word2Vec-理论（CBOW-Skip-gram）"><a href="#🧩-第-1-步：学习-Word2Vec-理论（CBOW-Skip-gram）" class="headerlink" title="🧩 第 1 步：学习 Word2Vec 理论（CBOW &#x2F; Skip-gram）"></a>🧩 第 1 步：学习 Word2Vec 理论（CBOW &#x2F; Skip-gram）</h2><p><code>腾讯词向量（Tencent AI Lab Embedding）主要是基于 Word2Vec 的 Skip-gram 模型，并使用 ​​C++ 实现的原始 Word2Vec 工具​​进行训练的。</code></p><h3 id="⚙️模型原理（两种结构）"><a href="#⚙️模型原理（两种结构）" class="headerlink" title="⚙️模型原理（两种结构）"></a>⚙️模型原理（两种结构）</h3><table><thead><tr><th>模型</th><th>输入</th><th>输出</th><th>特点</th></tr></thead><tbody><tr><td><strong>CBOW（Continuous Bag of Words）</strong></td><td>上下文（周围词）</td><td>预测中心词</td><td>快、适合小数据</td></tr><tr><td><strong>Skip-Gram</strong></td><td>中心词</td><td>预测上下文</td><td>准确、适合大数据</td></tr></tbody></table><p>🧮 模型目标<br><code>相似上下文 → 相似向量</code><br>训练时通过优化函数让语义相近的词在向量空间靠得更近。</p><p>🧩 模型结构<br>Skip-Gram 实际上是一个两层神经网络：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">输入层 (one-hot)<br>     ↓<br>隐藏层 (embedding matrix)<br>     ↓<br>输出层 (softmax)<br></code></pre></td></tr></table></figure><p>Step 1️⃣ 输入层<br><code>输入是一个词（比如 &quot;sits&quot;），用 one-hot 表示。如果词汇表大小是 10,000，那输入是一个 10,000 维的向量，其中只有一个位置是 1。</code></p><p>Step 2️⃣ 隐藏层（权重矩阵）<br>这个层没有激活函数。<br>权重矩阵大小是 V × N，其中：<br>V &#x3D; 词汇表大小（比如 10,000）<br>N &#x3D; 词向量维度（比如 100）<br>输入 one-hot 向量后，输出实际上就是那一行对应的词向量！<br>👉 这就是为什么我们最后说「Word2Vec 学到的其实就是这个权重矩阵」。</p><p>Step 3️⃣ 输出层（Softmax）<br><code>隐藏层输出经过另一个权重矩阵 (N × V)，变成长度为 V 的向量。这个向量经过 softmax 变成概率分布，表示：“给定中心词 w_t，某个词 w_c 是它的上下文的概率”。</code></p><h3 id="输入权重矩阵-W"><a href="#输入权重矩阵-W" class="headerlink" title="输入权重矩阵 W"></a>输入权重矩阵 W</h3><p>W 不需要自己手动设置，而是由模型随机初始化，然后通过训练自动学习的。训练结束后，W 的每一行就是该词的“词向量（embedding）</p><p>输入层：上下文单词的onehot。（假设单词向量空间dim为V，上下文单词个数为C）<br>所有onehot分别乘以共享的输入权重矩阵W（W为V<em>N矩阵，N为自己设定的数，需要初始化权重矩阵W）<br>所得的向量 （注意onehot向量乘以矩阵的结果） 相加求平均作为隐层向量, size为1</em>N.<br>乘以输出权重矩阵W’ {N<em>V}<br>得到向量 {1</em>V} 激活函数处理得到V-dim概率分布 {PS: 因为是onehot嘛，其中的每一维都代表着一个单词}，概率最大的index所指示的单词为预测出的中间词（target word）<br>与true label的onehot做比较，误差越小越好。loss function（一般为交叉熵代价函数）<br>说明：w是输入层到隐藏层的权重矩阵，维度是{V*N}，W’是隐藏层到输出层的权重矩阵，维度是{N * V}.</p><h2 id="⚙️第-2-步：下载模型"><a href="#⚙️第-2-步：下载模型" class="headerlink" title="⚙️第 2 步：下载模型"></a>⚙️第 2 步：下载模型</h2><p>地址：<a href="https://modelscope.cn/models/lili666/text2vec-word2vec-tencent-chinese/summary">https://modelscope.cn/models/lili666/text2vec-word2vec-tencent-chinese/summary</a></p><p>相关参考数据地址：<br><a href="https://github.com/cliuxinxin/TX-WORD2VEC-SMALL?tab=readme-ov-file">https://github.com/cliuxinxin/TX-WORD2VEC-SMALL?tab=readme-ov-file</a>    腾讯词向量数据集<br><a href="https://www.biaodianfu.com/tencent-word-embedding">https://www.biaodianfu.com/tencent-word-embedding</a>. 腾讯AI Lab中文词向量数据使用<br><a href="https://blog.csdn.net/sinat_26917383/article/details/83999966%E5%9F%BA%E4%BA%8E%E8%85%BE%E8%AE%AFAI">https://blog.csdn.net/sinat_26917383/article/details/83999966基于腾讯AI</a> Lab词向量进行未知词、短语向量补齐与域内相似词搜索<br><a href="https://zhuanlan.zhihu.com/p/486161850">https://zhuanlan.zhihu.com/p/486161850</a> 基于腾讯AI Lab开源的中文词向量的再训练<br><a href="https://blog.csdn.net/qq_45301231/article/details/116521241?ops_request_misc%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3word2vector%E8%AF%8D%E5%90%91%E9%87%8F%E6%A8%A1%E5%9E%8B">https://blog.csdn.net/qq_45301231/article/details/116521241?ops_request_misc通俗理解word2vector词向量模型</a></p><p>🧰 1. 安装依赖<br><code>pip install gensim jieba</code><br><code> pip install modelscope</code></p><ol start="2"><li>下载模型<br><code>modelscope download --model lili666/text2vec-word2vec-tencent-chinese</code></li></ol><h2 id="💾-第-3-步：加载腾讯中文词向量测试效果"><a href="#💾-第-3-步：加载腾讯中文词向量测试效果" class="headerlink" title="💾 第 3 步：加载腾讯中文词向量测试效果"></a>💾 第 3 步：加载腾讯中文词向量测试效果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim.models <span class="hljs-keyword">import</span> KeyedVectors<br><span class="hljs-keyword">import</span> os<br>dir_path = <span class="hljs-string">&#x27;C:\\Users\\26079\\.cache\\modelscope\\hub\\models\\lili666\\text2vec-word2vec-tencent-chinese&#x27;</span><br>bin_file = os.path.join(dir_path, <span class="hljs-string">&quot;light_Tencent_AILab_ChineseEmbedding.bin&quot;</span>)<br><br>wv = KeyedVectors.load_word2vec_format(bin_file, binary=<span class="hljs-literal">True</span>, unicode_errors=<span class="hljs-string">&#x27;ignore&#x27;</span>)<br><br><span class="hljs-comment"># 1. 查一个词</span><br>vec = wv[<span class="hljs-string">&#x27;人工智能&#x27;</span>]          <span class="hljs-comment"># 返回 numpy 数组，维度 200</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;词向量：&quot;</span>,vec)<br><span class="hljs-built_in">print</span>(vec.shape)              <span class="hljs-comment"># (200,)</span><br><span class="hljs-comment"># 2. 近义词</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;近义词：&quot;</span>,wv.most_similar(<span class="hljs-string">&#x27;人工智能&#x27;</span>, topn=<span class="hljs-number">5</span>))<br><span class="hljs-comment"># 3. 相似度</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;相似度&quot;</span>,wv.similarity(<span class="hljs-string">&#x27;猫&#x27;</span>, <span class="hljs-string">&#x27;狗&#x27;</span>))<br><span class="hljs-comment"># 4.词向量维度</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;词向量维度：&quot;</span>, wv.vector_size)<br><span class="hljs-comment"># 5.词类比任务示例</span><br><span class="hljs-comment"># 用向量算术做“国王 − 男人 + 女人 ≈ ？”的语义推理，返回最接近的 5 个词。</span><br>result = wv.most_similar(positive=[<span class="hljs-string">&quot;国王&quot;</span>, <span class="hljs-string">&quot;女人&quot;</span>], negative=[<span class="hljs-string">&quot;男人&quot;</span>], topn=<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;词类比任务示例：&quot;</span>,result)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;模型词汇量：&quot;</span>, <span class="hljs-built_in">len</span>(wv))<br></code></pre></td></tr></table></figure><h2 id="🧩新领域词向量扩展"><a href="#🧩新领域词向量扩展" class="headerlink" title="🧩新领域词向量扩展"></a>🧩新领域词向量扩展</h2><h3 id="🧠用-FastText"><a href="#🧠用-FastText" class="headerlink" title="🧠用 FastText"></a>🧠<em><strong>用 FastText</strong></em></h3><p>腾讯词向量（Word2Vec）只能表示训练语料里出现过的词，词表是固定的。<br>FastText 则不同 —— 它的核心是“子词 n-gram 表示”，即每个词由多个子词向量组成：<br>这样：<br> 即便新词没在训练语料出现，FastText 也能通过子词组合生成语义合理的向量；</p><p> 同时它仍然可以继承腾讯预训练的知识，通过初始化已有词的权重。</p><h3 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h3><p><code>在腾讯通用词向量的基础上，加载自己的领域语料，通过 FastText 增量训练，让模型能生成领域新词向量。</code></p><h3 id="🧩-一、FastText-模型保存机制概览"><a href="#🧩-一、FastText-模型保存机制概览" class="headerlink" title="🧩 一、FastText 模型保存机制概览"></a>🧩 一、FastText 模型保存机制概览</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">ft_model.save(<span class="hljs-string">&quot;tencent_fasttext_medical.model&quot;</span>)<br>ft_model.wv.save_word2vec_format(<span class="hljs-string">&quot;tencent_fasttext_medical.vec&quot;</span>, binary=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>Gensim 会自动生成多个文件。</p><table><thead><tr><th>向量类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>词向量 (word vectors)</strong></td><td>每个完整词对应的语义向量，比如 <code>&quot;医生&quot;</code>、<code>&quot;感冒&quot;</code></td></tr><tr><td><strong>子词向量 (subword vectors)</strong></td><td>FastText 的核心特性：把词分成字符 n-gram（如 “医”, “医生”, “生” 等）并为它们也建立向量</td></tr></tbody></table><p>&#x2F;<em>🔍 1️⃣ tencent_fasttext_medical.model</em>&#x2F;<br>这个是最重要的文件，它包含：</p><ul><li>模型结构；</li><li>训练参数（vector_size, window, epochs…）；</li><li>词典（key_to_index）；</li><li>向量矩阵文件的路径引用；</li><li>子词索引信息。</li></ul><p><code>🔸 加载方法：</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim.models <span class="hljs-keyword">import</span> FastText<br>model = FastText.load(<span class="hljs-string">&quot;tencent_fasttext_medical.model&quot;</span>)<br></code></pre></td></tr></table></figure><p><code>加载后，你可以直接：</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model.wv[<span class="hljs-string">&quot;胃炎&quot;</span>]<br>model.wv.most_similar(<span class="hljs-string">&quot;医生&quot;</span>)<br></code></pre></td></tr></table></figure><p>&#x2F;<em>🔍 2️⃣ tencent_fasttext_medical.model.wv.vectors_ngrams.npy</em>&#x2F;<br>这是 <strong>FastText 的子词向量矩阵文件。</strong><br>FastText 不像普通的 Word2Vec，它需要保存：<br><code>每个词的 n-gram（子字符串）的向量表示。</code><br><code>🔸 没有这个文件的话：你仍然可以加载模型；但无法正确生成 新词（未登录词） 的向量；</code></p><p><code>🔍 3️⃣ tencent_fasttext_medical.vec</code><br>这个文件是：把模型中每个词的向量导出成<strong>Word2Vec兼容格式</strong>的文本文件。<br><code>文件可以直接导入</code>   <strong>gensim.models.KeyedVectors.load_word2vec_format()</strong></p><h4 id="🧱-三、总结对比表"><a href="#🧱-三、总结对比表" class="headerlink" title="🧱 三、总结对比表"></a>🧱 三、总结对比表</h4><table><thead><tr><th>文件</th><th>含义</th><th>是否包含子词向量</th><th>可用于生成 OOV 向量</th><th>推荐用途</th></tr></thead><tbody><tr><td><code>.model</code></td><td>完整 FastText 模型</td><td>✅ 是</td><td>✅ 是</td><td>训练后加载继续使用</td></tr><tr><td><code>.model.wv.vectors_ngrams.npy</code></td><td>子词向量矩阵</td><td>✅ 是</td><td>✅ 是</td><td>FastText 必需</td></tr><tr><td><code>.vec</code></td><td>仅词向量文本格式</td><td>❌ 否</td><td>❌ 否</td><td>导出分析、兼容 word2vec</td></tr></tbody></table><h2 id="通过fasttext-训练出现的情况"><a href="#通过fasttext-训练出现的情况" class="headerlink" title="通过fasttext 训练出现的情况"></a>通过fasttext 训练出现的情况</h2><p>🧠 一、训练导致语义漂移（Semantic Drift）<br>你现在的 FastText 模型经历了三个阶段：</p><table><thead><tr><th>阶段</th><th>向量来源</th><th>是否含有腾讯语义</th></tr></thead><tbody><tr><td>1️⃣ <code>build_vocab()</code></td><td>随机初始化</td><td>❌ 无语义</td></tr><tr><td>2️⃣ 初始化阶段：<code>ft_model.wv[word] = tencent_wv[word]</code></td><td>部分词继承腾讯向量</td><td>✅ 有语义</td></tr><tr><td>3️⃣ <code>ft_model.train(sentences, ...)</code></td><td>基于医疗语料训练</td><td>⚠️ 有可能被覆盖或漂移</td></tr><tr><td><code>问题就出在 第 3 步训练阶段。如果你继续训练在一个完全不同领域的语料（例如“医疗文本”），模型会逐步将腾讯原有的语义调整到医疗语境中。</code></td><td></td><td></td></tr></tbody></table><p>⚙️二、从机制上看，FastText 训练会调整所有词的向量<br>FastText 的训练过程是基于 skip-gram + negative sampling，每次训练都会更新目标词及其上下文词的向量。</p><p><code>也就是说，即使“人工智能”在腾讯模型中有向量，训练时 FastText 仍然会继续优化它的参数，使它在新语料中预测上下文更准确。这就不可避免地产生语义漂移（semantic shift）。</code></p><p>🧩 三、确认是否真的“丢失语义”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#你可以对比看看“腾讯原始向量”和“训练后向量”的差异：</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>vec_tencent = tencent_wv[<span class="hljs-string">&quot;人工智能&quot;</span>]<br>vec_new = model.wv[<span class="hljs-string">&quot;人工智能&quot;</span>]<br><br>cosine = np.dot(vec_tencent, vec_new) / (np.linalg.norm(vec_tencent) * np.linalg.norm(vec_new))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;语义相似度：&quot;</span>, cosine)<br></code></pre></td></tr></table></figure><p>🔧 四、如何防止或减弱这种“语义漂移”</p><table><thead><tr><th>方法</th><th>说明</th><th>适合场景</th></tr></thead><tbody><tr><td><strong>1️⃣ 冻结腾讯向量层（不再更新）</strong></td><td>对已有词不再进行训练更新，只训练新词和子词</td><td>想保持腾讯语义不变</td></tr><tr><td><strong>2️⃣ 使用较小学习率 (alpha)</strong></td><td>比如 <code>alpha=0.001</code></td><td>让微调幅度变小</td></tr><tr><td><strong>3️⃣ 医疗语料中增加通用语料混合训练</strong></td><td>加入一部分腾讯原始语料或百科语料</td><td>兼顾通用语义和领域语义</td></tr></tbody></table><h2 id="1️⃣-冻结腾讯向量层（不再更新）"><a href="#1️⃣-冻结腾讯向量层（不再更新）" class="headerlink" title="1️⃣ 冻结腾讯向量层（不再更新）"></a><strong>1️⃣ 冻结腾讯向量层（不再更新）</strong></h2><h2 id="🚀-部署说明"><a href="#🚀-部署说明" class="headerlink" title="🚀 部署说明"></a>🚀 部署说明</h2><ol><li><p>将以下文件上传到 221 指定目录（例如 <code>/home/user/word2vec/</code>）：</p><ul><li><code>Tencent_AILab_ChineseEmbedding.txt</code></li><li><code>load_and_test.py</code>（加载与测试脚本）</li><li>本技术文档（Word2Vec_Usage_Report.md）</li></ul></li><li><p>在 221 上执行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">   python load_and_test.py<br><br><br><br><span class="hljs-comment">## 内存消耗</span><br>**核心影响因素**<br>词向量维度​​、数据类型​​、词表大小<br><br>float32（单精度浮点数）： 每个数字占 ​​4 字节​​。这是最常见和研究中使用最多的格式。<br>float16（半精度浮点数）： 每个数字占 ​​2 字节​​。常用于深度学习和移动端以节省内存和计算资源，精度略有损失。<br>float64（双精度浮点数）： 每个数字占 ​​8 字节​​。用于高精度计算，但词向量中很少用。<br><br>**内存计算**<br>总内存 (字节) = 词表大小 × 词向量维度 × 每个浮点数所占字节数<br>` 计算： 1,920,000 × 768 × 4 字节 = 5,898,240,000 字节 单位换算： 5,898,240,000 字节 / 1024 / 1024 / 1024 ≈ **5.9GB**`<br><br>| 概念             | 解释                    | 你可以怎么理解       |<br>| -------------- | --------------------- | ------------- |<br>| **JVM**        | Java 虚拟机，Java 程序的运行环境 | “Java 的操作系统”  |<br>| **GC**         | 垃圾回收器，自动清理不用的内存       | “清洁工”         |<br>| **堆内存 (Heap)** | JVM 运行时存放对象、模型数据的地方   | “仓库”          |<br>| **两个进程**       | 各自运行独立 JVM，各自加载模型副本   | “两台独立机器”      |<br>| **负载均衡**       | 请求均匀分配给不同服务实例         | “排队窗口分流”      |<br>| **内存高达 60G**   | 两份模型副本 + JVM 自身开销     | “每台机器都存了一份字典” |<br><br>VIRT：虚拟内存（进程申请的总空间，不等于实际占用）<br><br>RES：常驻内存（真正占用的物理内存）<br><br>%MEM：占整个机器物理内存的百分比<br><br>COMMAND：执行命令，这里都是 Java<br><br>启动 两个 Java 服务（进程 A 和 B）；<br>两个都加载同一份模型文件；<br>上层用 负载均衡（load balancer） 把请求分给 A 或 B；<br>比如一半请求去 A，一半去 B。<br>结果就是：<br>两个 Java 进程各自拥有独立的模型副本，并行工作。<br><br><br><br><span class="hljs-comment">### 🧠 背景：Java 程序里的数据都在“堆（Heap）”里</span><br>`当 Java 程序运行时，JVM（Java虚拟机）会在内存中划出一块大区域叫 “堆内存（Heap）”，专门用来放对象。`<br><br><span class="hljs-comment">#### 🧩 一项一项解释：</span><br>1️⃣ 字符串对象（String）在 Java 里，String 其实是一个对象，不是像 Python 那样简单的字面量<br>```java<br>String word = <span class="hljs-string">&quot;工程师&quot;</span>;<br></code></pre></td></tr></table></figure><p>这行代码在内存中其实包含：<br>一个 String 对象（对象头、指针等元数据）<br>一个内部的 char[] 数组（真正存放“工 程 师”三个字符）<br>还要记录长度、哈希值等信息<br>📦 大概会占几十个字节。</p></li></ol><p>2️⃣ HashMap 桶（bucket）和 Entry 对象  很多 Java 程序会用 HashMap&lt;String, Object&gt; 来保存 key-value 对，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, <span class="hljs-type">float</span>[]&gt; word2vec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>word2vec.put(<span class="hljs-string">&quot;工程师&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">float</span>[<span class="hljs-number">768</span>]);<br></code></pre></td></tr></table></figure><p>3️⃣ Float&#x2F;Float[] 装箱（boxing） 装箱的意思是：Java 会把“原始类型”（primitive）变成“对象类型”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14f</span>;        <span class="hljs-comment">// 原始 float，占4字节</span><br><span class="hljs-type">Float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14f</span>;        <span class="hljs-comment">// 装箱成对象，占 ~16–24 字节</span><br></code></pre></td></tr></table></figure><p>4️⃣ JVM heap、metaspace、GC buffer</p><table><thead><tr><th align="left">名称</th><th align="left">用途</th><th align="left">大概作用</th></tr></thead><tbody><tr><td align="left"><strong>Heap（堆）</strong></td><td align="left">存放你创建的对象</td><td align="left">所有 <code>String</code>、<code>HashMap</code>、<code>Float[]</code> 都在这里</td></tr><tr><td align="left"><strong>Metaspace</strong></td><td align="left">存放类的元数据（反射信息、类加载）</td><td align="left">Java 内部使用</td></tr><tr><td align="left"><strong>GC buffer</strong></td><td align="left">垃圾回收器临时区</td><td align="left">JVM 清理内存时会分配缓冲区</td></tr></tbody></table><h3 id="堆和栈区别"><a href="#堆和栈区别" class="headerlink" title="堆和栈区别"></a>堆和栈区别</h3><table><thead><tr><th align="left">场景</th><th align="left">类比</th></tr></thead><tbody><tr><td align="left"><strong>操作台</strong></td><td align="left">栈（Stack）：放眼前要马上用的材料</td></tr><tr><td align="left"><strong>冰箱&#x2F;储物柜</strong></td><td align="left">堆（Heap）：放做菜需要的所有食材</td></tr><tr><td align="left">你每做完一道菜，马上收拾操作台</td><td align="left">栈：使用完自动清理</td></tr><tr><td align="left">冰箱里的食材要你手动拿出来、放回去</td><td align="left">堆：由程序（或 JVM）管理和回收</td></tr></tbody></table><h3 id="为什么会消耗65G内存？为什么两个进程-VIRT-不一样？"><a href="#为什么会消耗65G内存？为什么两个进程-VIRT-不一样？" class="headerlink" title="为什么会消耗65G内存？为什么两个进程 VIRT 不一样？"></a>为什么会消耗65G内存？为什么两个进程 VIRT 不一样？</h3><p>① 不同时间点触发的 GC 不同<br>Java 的垃圾回收器（GC）会动态管理内存：<br>当一个进程已经加载完所有模型、缓存、索引，堆空间相对“稳定”；<br>另一个进程可能正在分配缓存或正在 GC 后重新分配内存。<br>② 不同的线程数量、线程栈空间.如果一个进程创建了更多工作线程（比如：<br>JVM 内存是“动态决策”出来的，JVM 在启动时会根据机器配置（CPU 核数、总内存大小等）自动“算”出它要申请多少堆空间。</p><p>参数默认规则含义<br>-Xms默认是 物理内存的 1&#x2F;64JVM 启动时分配的初始堆<br>-Xmx默认是 物理内存的 1&#x2F;4JVM 最大可用堆空间上限</p><p>&#x2F;<em>占用来源</em>&#x2F;  Java 运行时的数据结构开销</p><table><thead><tr><th align="left">来源</th><th align="left">可能占用</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">向量数据（float32）</td><td align="left">~5.6GB</td><td align="left">理论数据本体</td></tr><tr><td align="left">字符串对象（词语）</td><td align="left">1–3GB</td><td align="left">195万个 <code>String</code> 对象 + char[]</td></tr><tr><td align="left">HashMap 桶、Entry 对象</td><td align="left">3–5GB</td><td align="left">每个 entry 至少几十字节</td></tr><tr><td align="left">Float&#x2F;Float[] 装箱</td><td align="left">10–20GB</td><td align="left">若每个维度是 Float 对象，内存翻倍</td></tr><tr><td align="left">JVM heap + metaspace + GC buffer</td><td align="left">若干</td><td align="left">JVM 自身分配</td></tr><tr><td align="left">两份模型重复加载</td><td align="left">×2</td><td align="left">进程A+B 各自加载</td></tr></tbody></table><p>String object 本身（12 B 对象头 + 4 B 哈希 + 4 B 指针）&#x3D; 20 B<br>  └── 指向一个 char[]（数组对象头 12 B + 长度 4 B + 数据 2 B × 字符数）</p><h2 id="推荐的结构"><a href="#推荐的结构" class="headerlink" title="推荐的结构"></a>推荐的结构</h2><p>word2vec_project&#x2F;<br>├── model&#x2F;                        # 模型文件（放到服务器）<br>│   ├── medical_domain.model<br>│   └── medical_domain_word2vec.bin<br>│<br>├── train&#x2F;                        # 训练代码（只开发环境用）<br>│   └── train_word2vec.py<br>│<br>├── api&#x2F;                          # 部署接口（放到服务器运行）<br>│   └── app.py<br>│<br>└── requirements.txt              # 环境依赖</p><h3 id="启动fastapi"><a href="#启动fastapi" class="headerlink" title="启动fastapi"></a>启动fastapi</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cd word2vec_project/api<br>python -m uvicorn app:app --host <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> --port <span class="hljs-number">8080</span> --reload<br></code></pre></td></tr></table></figure><h3 id="后台长期运行（不依赖终端）"><a href="#后台长期运行（不依赖终端）" class="headerlink" title="后台长期运行（不依赖终端）"></a>后台长期运行（不依赖终端）</h3><p>🧱 举个例子对比</p><table><thead><tr><th>场景</th><th>行为</th><th>结果</th></tr></thead><tbody><tr><td>🧩 <strong>前台运行</strong></td><td>你运行：<code>python -m uvicorn app:app --host 0.0.0.0 --port 8080</code></td><td>一旦你关闭终端（或 SSH 断线），服务就<strong>停止</strong>。</td></tr><tr><td>⚙️ <strong>后台长期运行</strong></td><td>你运行：<code>nohup python -m uvicorn app:app --host 0.0.0.0 --port 8080 &amp;</code></td><td>即使你关掉终端、电脑休眠、SSH 断开，服务<strong>仍在后台运行</strong>。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/09/26/%E4%BA%BA%E5%B2%97/"/>
    <url>/2025/09/26/%E4%BA%BA%E5%B2%97/</url>
    
    <content type="html"><![CDATA[<h1 id="职位-简历"><a href="#职位-简历" class="headerlink" title="职位 -&gt; 简历"></a>职位 -&gt; 简历</h1><p>猎上当前的人岗匹配逻辑（must_field 硬条件过滤 -&gt; 技能 + sub_field 加权打分 -&gt; 排序推荐）</p><h2 id="加入更多排序因子"><a href="#加入更多排序因子" class="headerlink" title="加入更多排序因子"></a>加入更多排序因子</h2><p>当前主要是，技能 + 领域 排序，可以考虑加入以下 ：</p><ol><li>&#x2F;<em>工作年限匹配度</em>&#x2F;</li></ol><ul><li>JD：要求 3~5 年经验</li><li>简历：候选人有 4 年 -&gt; 得分高</li></ul><ol start="2"><li>&#x2F;<em>教育背景</em>&#x2F;</li></ol><ul><li>JD：本科及以上</li><li>简历：硕士&#x2F;博士 -&gt; 得分高</li></ul><ol start="3"><li>&#x2F;<em>稳定性</em>&#x2F;</li></ol><ul><li>候选人平均在职时间太短（频繁跳槽） -&gt; 排序靠后</li></ul><ol start="4"><li>&#x2F;<em>行业、公司规模偏好</em>&#x2F;</li></ol><ul><li>候选人有华为&#x2F;阿里&#x2F;腾讯经历 -&gt; 排序靠前</li></ul><h2 id="多样性候选人"><a href="#多样性候选人" class="headerlink" title="多样性候选人"></a>多样性候选人</h2><p><code>给HR提供更多不一样的候选人避免**同质化**</code><br>比如有两种排序:</p><ul><li>技能 + 领域 十分匹配</li><li>学习能力十分强，跨行业但潜力大的人</li></ul><h2 id="给予排序的解释"><a href="#给予排序的解释" class="headerlink" title="给予排序的解释"></a>给予排序的解释</h2><p>告诉 HR 为什么排在前面</p><ul><li>技能高度匹配</li><li>领域符合</li><li>年限匹配</li><li>加分项</li></ul><h2 id="反馈学习"><a href="#反馈学习" class="headerlink" title="反馈学习"></a>反馈学习</h2><p>HR 选择了哪些候选人进入面试 -&gt; 作为正样本<br>HR 淘汰了哪些候选人 -&gt; 作为负样本<br>用这些反馈不断优化排序模型</p><h1 id="岗位精准推送"><a href="#岗位精准推送" class="headerlink" title="岗位精准推送"></a>岗位精准推送</h1><h2 id="意图更精准"><a href="#意图更精准" class="headerlink" title="意图更精准"></a>意图更精准</h2><p>不仅依赖用户对话，还可以结合简历、过往申请记录、用户在 APP 内的浏览行为，动态推测求职意图。</p><h2 id="匹配逻辑优化"><a href="#匹配逻辑优化" class="headerlink" title="匹配逻辑优化"></a>匹配逻辑优化</h2><ul><li>个性化权重：不同用户在意的因素不同（有人更看重薪资，有人更看重地点），可以通过问答&#x2F;行为推断，动态调整匹配权重。</li><li>引入约束条件：比如用户明确“不考虑加班多的岗位”，就要过滤掉。</li></ul><h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><ul><li>多样性排序：避免<strong>同质化</strong>，可以覆盖不同企业规模、不同地点或不同福利</li><li>透明化推荐理由：每个推荐的岗位旁边附上“推荐原因”<br>例如：技能匹配度高、地点符合、薪资接近期望</li></ul><h2 id="用户交互优化-反馈学习"><a href="#用户交互优化-反馈学习" class="headerlink" title="用户交互优化&#x2F;反馈学习"></a>用户交互优化&#x2F;反馈学习</h2><p>用户点“不感兴趣” -&gt; 系统学习，减少类似岗位推送。<br>用户点“特别喜欢” -&gt; 增加类似岗位的推荐</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>猎上匹配</title>
    <link href="/2025/09/25/%E7%8C%8E%E4%B8%8A%E5%8C%B9%E9%85%8D/"/>
    <url>/2025/09/25/%E7%8C%8E%E4%B8%8A%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="ner"><a href="#ner" class="headerlink" title="ner"></a>ner</h3><p><code>NER任务（Named Entity Recognition，命名实体识别）是自然语言处理（NLP）中的一项基础任务，目标是：从非结构化文本中自动识别出具有特定意义的实体，并将其分类到预定义的类别中</code></p><p>✅ 一句话理解：<br>NER &#x3D; 找实体 + 分类别</p><p>✅ NER任务的两个子任务：</p><ul><li>实体边界检测：找出实体的开始和结束位置</li><li>实体类型分类：给实体打上正确的类别标签</li></ul><h3 id="监督学习-无监督学习-自监督学习"><a href="#监督学习-无监督学习-自监督学习" class="headerlink" title="监督学习 无监督学习 自监督学习"></a>监督学习 无监督学习 自监督学习</h3><p>监督学习给你一堆猫狗图片，每张都标了“这是猫”或“这是狗”，模型学会分类。<br>无监督学习给你一堆猫狗图片，不告诉你谁是猫谁是狗，模型自己找出“猫长得像这样，狗长得那样”。<br>自监督学习给你一堆没有标签的猫狗图片，模型自己玩“猜图游戏”：比如遮住一半，猜另一半是什么。用这种方式学会图像特征，之后再拿去分类猫狗。</p><ul><li><p>✅ 一句话区分：<br>监督学习：有“标准答案”的学习。<br>无监督学习：没有“标准答案”，自己找规律。<br>自监督学习：没有人工标注的“标准答案”，但从数据本身构造“伪标签”来学习。</p></li><li><p>✅ 技术角度对比：<br>特征监督学习无监督学习自监督学习</p></li></ul><p>是否需要人工标签✅ 需要❌ 不需要❌ 不需要（但需构造伪标签）<br>目标预测标签发现数据结构学会通用特征，下游任务再微调<br>数据利用率低（依赖标注）高高（利用大量无标注数据）<br>应用场景分类、回归聚类、降维预训练模型（如BERT、SimCLR）</p><h3 id="伪标签"><a href="#伪标签" class="headerlink" title="伪标签"></a>伪标签</h3><p>&#x2F;<em>伪标签</em>&#x2F;（Pseudo-label）的核心思想是：从数据本身“挖”出监督信号，不依赖人工标注。<br>✅ 一、自监督学习中的“伪标签”构造方法<br>任务领域代表方法伪标签怎么来的？（构造方式）直觉解释<br>图像旋转预测（RotNet）把图片随机旋转 0°&#x2F;90°&#x2F;180°&#x2F;270°，旋转角度就是标签模型必须看懂物体方向才能猜角度<br>文本BERT随机遮住 15% 的词（[MASK]），被遮住的词就是标签像“完形填空”：凭上下文猜缺失词</p><p>✅ 二、伪标签通用公式（3 步）</p><ol><li><strong>设计一个“预测任务”</strong><br>必须让模型只能通过理解语义才能完成，而不是靠“捷径”。</li><li><strong>从数据本身生成“答案”</strong><br>不需要人工标注，答案就是数据的一部分（被旋转的角度、被遮住的词、被裁剪的图块……）。</li><li><strong>训练模型</strong><br>把伪标签当“真标签”用，训练一个编码器；下游任务（分类、检测等）再微调即可。<br>✅ <strong>伪标签</strong> &#x3D; <strong>把数据的一部分当“答案”</strong>，让模型<strong>预测数据的另一部分</strong>，从而<strong>被迫学会语义。</strong></li></ol><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p><code>/*编码器*/ = 把“原始高维垃圾”变成“紧凑低维精华”的函数/网络。</code></p><ol><li><p>它到底在“编码”什么？</p><table><thead><tr><th>输入（原始垃圾）</th><th>输出（精华）</th><th>举例</th></tr></thead><tbody><tr><td>224×224×3 图片</td><td>512 维向量</td><td>一张猫图 → [0.21, -1.34, …, 0.78]</td></tr><tr><td>一句 20 词的话</td><td>768 维向量</td><td>“我爱你” → [0.05, 0.91, …, -0.30]</td></tr><tr><td>3 秒语音波形</td><td>256 维向量</td><td>一段“你好” → [-0.12, …, 0.66]</td></tr><tr><td><strong>精华</strong> &#x3D; <strong>语义向量 &#x2F; 特征向量 &#x2F; embedding</strong></td><td></td><td></td></tr></tbody></table></li><li><p>长什么样？（最小结构）</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 图像编码器 = 卷积 Backbone + 全局池化 + 全连接</span><br>encoder = nn.Sequential(<br>    nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>),   <span class="hljs-comment"># 下采样</span><br>    ...<br>    nn.AdaptiveAvgPool2d(<span class="hljs-number">1</span>),  <span class="hljs-comment"># 变成 1×1×C</span><br>    nn.Flatten(),             <span class="hljs-comment"># 变成向量</span><br>    nn.Linear(C, <span class="hljs-number">512</span>)         <span class="hljs-comment"># 最终 512 维</span><br>)<br><span class="hljs-comment"># 文本编码器 = Transformer</span><br>encoder = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base&quot;</span>)  <span class="hljs-comment"># 输出 768 维向量</span><br></code></pre></td></tr></table></figure><ol start="3"><li>它跟“模型”有什么区别？<table><thead><tr><th>编码器</th><th>整个模型</th></tr></thead><tbody><tr><td>只负责“提特征”</td><td>负责“完成最终任务”</td></tr><tr><td>输出向量</td><td>输出标签&#x2F;像素&#x2F;单词等</td></tr><tr><td>可复用</td><td>通常任务相关</td></tr></tbody></table></li></ol><h3 id="TF-IDA-word2Vec-CNN-RNN"><a href="#TF-IDA-word2Vec-CNN-RNN" class="headerlink" title="TF-IDA word2Vec CNN RNN"></a>TF-IDA word2Vec CNN RNN</h3><p>“几万维”<br>维数 &#x3D; 词典里有多少个不同的词。<br>中文大语料随便就 2-5 万个词，所以向量长度是“几万”。<br>“稀疏”<br>一篇短文通常只出现几十个词，其余位置全是 0。<br>就像 5 万座位的大体育场，只坐了 50 个人，其余全空——这叫稀疏。<br>“每维 &#x3D; 词的重要性分数”<br>每个座位（每一维）对应一个固定词。<br>如果这个词在文章里出现，就把它的 TF-IDF 得分填进去；<br>没出现就保持 0。<br>所以“非零的那些数字”就是这个词对这篇文章的重要程度。&#96;</p><ol><li><p>TF-IDF（词袋统计派）词袋模型（BoW）把句子当成“装了哪些词”的篮子，只认词频，不认顺序和含义；<br>输入：一篇文档<br>输出：几万维的稀疏向量，每维&#x3D;词的重要性分数<br>核心：出现多＋别人少见 → 分数高<br>用途：关键词提取、检索排序、 baseline 文本分类</p></li><li><p>Word2Vec（分布式表示派）分布式表示把每个词放进连续向量空间，靠向量距离就能体现语义相似性。<br>输入：大量句子<br>输出：每个词一个 100～300 维的实数向量（密集）<br>两种训练模式：<br>– CBOW：用上下文猜中间词<br>– Skip-gram：用中间词猜上下文<br>特性：语义相近的词向量靠得近（king−man+woman≈queen）<br>用途：做同义词、推荐、下游模型的初始化 embedding</p></li><li><p>CNN（卷积神经网络，文本版）<br>核心操作：把“滑动窗口+权重共享”用在词向量矩阵上<br>过程：句子→embedding 矩阵→多个不同尺寸的 2D 卷积核（其实只沿“时间”滑）→提取局部 n-gram 特征→最大池化→全连接<br>优点：并行快、抓局部关键片段（如“not bad”里的否定）<br>用途：文本分类、情感分析、短文本匹配</p></li></ol><p><code>池化 = 把特征图“缩水”</code><br><code>卷积操作就是用一个可移动的小窗口来提取图像中的特征</code></p><ol start="4"><li>RNN（循环神经网络，序列记忆派）<br>核心：每个时间步把“当前输入+上一步隐藏状态”一起喂给自己，形成循环，天然吃变长序列<br>常见变种：<br>– LSTM：用门控解决长程梯度消失<br>– GRU：简化版 LSTM<br>优点：能捕捉顺序依赖（如“昨天……今天……明天……”）<br>用途：机器翻译、语音识别、文本生成、时间序列预测</li></ol><h2 id="人岗算法"><a href="#人岗算法" class="headerlink" title="人岗算法"></a>人岗算法</h2><p>在第三部分：使用阿里 embedding 模型，每个词指定生成 768 的向量纬度（model：text-embedding-v3）<br>🔹中文向量化的基本流程</p><ol><li><p>分词 &#x2F; Tokenization<br>把一段中文文本切分成“token”（可能是一个汉字、一个词，或者一个子词片段）。<br>例如：<br>- 句子：有5年Java开发经验<br>- 分词结果：[“有”, “5”, “年”, “Java”, “开发”, “经验”]</p></li><li><p>向量映射<br>- 每个 token 会被映射到一个向量（768维）。<br>- 模型会把这些 token 向量合并成一个整体 embedding（通常是加权平均或通过 Transformer pooling）。</p></li><li><p>技能对比（SkillWords）<br><code>技能部分直接计算简历和职位中的 skillWords 得出所有词的双向调和平均值</code><br> &#x2F;<em>双向调和平均值</em>&#x2F;是推荐系统、信息检索里为了同时衡量两个排序列表的吻合度而设计的一种对称化指标。</p></li></ol><h1 id="猎上算法"><a href="#猎上算法" class="headerlink" title="猎上算法"></a>猎上算法</h1><p>猎上当前的人岗匹配逻辑（must_field 硬条件过滤 -&gt; 技能 + sub_field 加权打分 -&gt; 排序推荐）</p><h2 id="加入更多排序因子"><a href="#加入更多排序因子" class="headerlink" title="加入更多排序因子"></a>加入更多排序因子</h2><p>当前主要是，技能 + 领域 排序，可以考虑加入以下 ：</p><ol><li>&#x2F;<em>工作年限匹配度</em>&#x2F;</li></ol><ul><li>JD：要求 3~5 年经验</li><li>简历：候选人有 4 年 -&gt; 得分高</li></ul><ol start="2"><li>&#x2F;<em>教育背景</em>&#x2F;</li></ol><ul><li>JD：本科及以上</li><li>简历：硕士&#x2F;博士 -&gt; 得分高</li></ul><ol start="3"><li>&#x2F;<em>稳定性</em>&#x2F;</li></ol><ul><li>候选人平均在职时间太短（频繁跳槽） -&gt; 排序靠后</li></ul><ol start="4"><li>&#x2F;<em>行业、公司规模偏好</em>&#x2F;</li></ol><ul><li>候选人有华为&#x2F;阿里&#x2F;腾讯经历 -&gt; 排序靠前</li></ul><h2 id="多样性候选人"><a href="#多样性候选人" class="headerlink" title="多样性候选人"></a>多样性候选人</h2><p><code>给HR提供更多不一样的候选人避免**同质化**</code><br>比如有两种排序:</p><ul><li>技能 + 领域 十分匹配</li><li>学习能力十分强，跨行业但潜力大的人</li></ul><h2 id="给予排序的解释"><a href="#给予排序的解释" class="headerlink" title="给予排序的解释"></a>给予排序的解释</h2><p>告诉 HR 为什么排在前面</p><ul><li>技能高度匹配</li><li>领域符合</li><li>年限匹配</li><li>加分项</li></ul><h2 id="反馈学习"><a href="#反馈学习" class="headerlink" title="反馈学习"></a>反馈学习</h2><p>HR 选择了哪些候选人进入面试 -&gt; 作为正样本<br>HR 淘汰了哪些候选人 -&gt; 作为负样本<br>用这些反馈不断优化排序模型</p><h1 id="岗位精准推送"><a href="#岗位精准推送" class="headerlink" title="岗位精准推送"></a>岗位精准推送</h1><h2 id="意图更精准"><a href="#意图更精准" class="headerlink" title="意图更精准"></a>意图更精准</h2><p>不仅依赖用户对话，还可以结合简历、过往申请记录、用户在 APP 内的浏览行为，动态推测求职意图。</p><h2 id="匹配逻辑优化"><a href="#匹配逻辑优化" class="headerlink" title="匹配逻辑优化"></a>匹配逻辑优化</h2><ul><li>个性化权重：不同用户在意的因素不同（有人更看重薪资，有人更看重地点），可以通过问答&#x2F;行为推断，动态调整匹配权重。</li><li>引入约束条件：比如用户明确“不考虑加班多的岗位”，就要过滤掉。</li></ul><h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><ul><li>多样性排序：避免<strong>同质化</strong>，可以覆盖不同企业规模、不同地点或不同福利</li><li>透明化推荐理由：每个推荐的岗位旁边附上“推荐原因”<br>例如：技能匹配度高、地点符合、薪资接近期望</li></ul><h2 id="用户交互优化-反馈学习"><a href="#用户交互优化-反馈学习" class="headerlink" title="用户交互优化&#x2F;反馈学习"></a>用户交互优化&#x2F;反馈学习</h2><p>用户点“不感兴趣” -&gt; 系统学习，减少类似岗位推送。<br>用户点“特别喜欢” -&gt; 增加类似岗位的推荐</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>检索相关</title>
    <link href="/2025/09/23/message/"/>
    <url>/2025/09/23/message/</url>
    
    <content type="html"><![CDATA[ <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_stream</span>(<span class="hljs-params">self, rand_cnt:<span class="hljs-built_in">str</span></span>):    <span class="hljs-comment"># 解析 rand_cnt 中的变量占位符,生成器函数，因为使用了 yield 来逐步产生值。</span><br>       s = <span class="hljs-number">0</span>   <span class="hljs-comment">#s用于跟踪当前在 rand_cnt 字符串中处理到的位置（索引）</span><br>       all_content = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-comment"># 存储所有解析后的结果。</span><br>       cache = &#123;&#125;  <span class="hljs-comment"># 缓存已经解析过的变量引用结果，键是变量表达式，值是对应的解析结果。这样可以避免重复解析相同的变量，提高效率。</span><br><br>       <span class="hljs-comment"># 使用 re.finditer 函数来匹配变量引用，并返回一个迭代器，迭代器的元素是匹配到的结果，包括匹配到的字符串、开始和结束索引等信息。</span><br>       <span class="hljs-comment"># 使用正则表达式 re.finditer 查找 rand_cnt 中所有匹配 self.variable_ref_patt 模式的子字符串，迭代处理每个匹配项。</span><br>       <span class="hljs-comment"># self.variable_ref_patt 是一个正则表达式模式（可能是类的一个属性），用于匹配字符串中的变量引用（例如，&#123;&#123;var&#125;&#125; 这样的占位符）。</span><br>       <span class="hljs-comment"># 使用 re.DOTALL 标志，表示在匹配时允许 . 匹配换行符。</span><br>       <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> re.finditer(<span class="hljs-variable language_">self</span>.variable_ref_patt, rand_cnt, flags=re.DOTALL):<br>           all_content += rand_cnt[s: r.start()]<br>           <span class="hljs-keyword">yield</span> rand_cnt[s: r.start()]<br>           s = r.end() <span class="hljs-comment"># 更新 s 为当前匹配项的结束位置 r.end()</span><br><br>           <span class="hljs-comment">#self.variable_ref_patt 可能定义了一个捕获组，用于提取变量引用的内容（例如，&#123;&#123;var&#125;&#125; 中的 var）。r.group(1) 返回该捕获组的内容，即变量的表达式。</span><br>           exp = r.group(<span class="hljs-number">1</span>)    <span class="hljs-comment">#提取正则表达式匹配的第一个捕获组（group），并赋值给变量 exp。</span><br>           <span class="hljs-keyword">if</span> exp <span class="hljs-keyword">in</span> cache:    <span class="hljs-comment">#检查变量表达式 exp 是否已经存在于 cache 字典中。</span><br>               <span class="hljs-keyword">yield</span> cache[exp]<br>               all_content += cache[exp]<br>               <span class="hljs-keyword">continue</span><br><br>           v = <span class="hljs-variable language_">self</span>._canvas.get_variable_value(exp)<br>           <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> v:<br>               v = <span class="hljs-string">&quot;&quot;</span><br>           <span class="hljs-comment">#partial 是一种函数对象，可能表示一个需要动态生成内容的变量（例如，生成器或流式内容）。如果 v 是 partial，需要特殊处理。</span><br>           <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(v, partial):<br>               cnt = <span class="hljs-string">&quot;&quot;</span><br>               <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> v():<br>                   <span class="hljs-comment">#调用 partial 对象 v（通过 v() 执行），并迭代其返回的生成器或可迭代对象中的每个元素 t。</span><br>                   all_content += t<br>                   cnt += t<br>                   <span class="hljs-keyword">yield</span> t <span class="hljs-comment">#将每个片段 t 作为生成器的输出返回</span><br><br>               <span class="hljs-keyword">continue</span><br>           <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(v, <span class="hljs-built_in">str</span>):<br>               <span class="hljs-keyword">try</span>:<br>                   v = json.dumps(v, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>)<br>               <span class="hljs-keyword">except</span> Exception:<br>                   v = <span class="hljs-built_in">str</span>(v)<br>           <span class="hljs-keyword">yield</span> v <span class="hljs-comment">#无论是从 partial 对象、JSON 序列化还是直接字符串，都以流式方式返回变量值。</span><br>           all_content += v<br>           cache[exp] = v<br><br>       <span class="hljs-comment">#作用：检查是否还有未处理的字符串部分（即 s 小于 rand_cnt 的长度）。</span><br>       <span class="hljs-comment"># 上下文：正则表达式可能没有匹配到字符串的末尾，剩余的部分需要处理。</span><br>       <span class="hljs-keyword">if</span> s &lt; <span class="hljs-built_in">len</span>(rand_cnt):<br>           all_content += rand_cnt[s: ]<br>           <span class="hljs-keyword">yield</span> rand_cnt[s: ]<br><br>       <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;content&quot;</span>, all_content)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大模型框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>检索相关</title>
    <link href="/2025/09/22/%E6%A3%80%E7%B4%A2%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/09/22/%E6%A3%80%E7%B4%A2%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="相似度阈值、关键词权重"><a href="#相似度阈值、关键词权重" class="headerlink" title="相似度阈值、关键词权重"></a>相似度阈值、关键词权重</h2><h2 id="rerank模型通常是独立的，不依赖特定嵌入模型，能对所有chunks统一打分，解决跨模型相似度不可比的问题。"><a href="#rerank模型通常是独立的，不依赖特定嵌入模型，能对所有chunks统一打分，解决跨模型相似度不可比的问题。" class="headerlink" title="rerank模型通常是独立的，不依赖特定嵌入模型，能对所有chunks统一打分，解决跨模型相似度不可比的问题。"></a>rerank模型通常是独立的，不依赖特定嵌入模型，能对所有chunks统一打分，解决跨模型相似度不可比的问题。</h2><p>Rerank模型（如cross-encoder模型，例如bge-ranker-base或bge-reranker-v2-m3）就是为了解决这个问题而设计的。它不依赖于预计算的嵌入向量，而是直接基于原始文本进行计算，从而实现跨模型的统一排序。</p><h2 id="rerank模型是怎么对不同嵌入模型向量化知识库进行统一排序"><a href="#rerank模型是怎么对不同嵌入模型向量化知识库进行统一排序" class="headerlink" title="rerank模型是怎么对不同嵌入模型向量化知识库进行统一排序?"></a>rerank模型是怎么对不同嵌入模型向量化知识库进行统一排序?</h2><h2 id="有的模型可以用于排序，有的模型只能用于检索"><a href="#有的模型可以用于排序，有的模型只能用于检索" class="headerlink" title="有的模型可以用于排序，有的模型只能用于检索"></a>有的模型可以用于排序，有的模型只能用于检索</h2><h2 id="交叉编码器、双编码器"><a href="#交叉编码器、双编码器" class="headerlink" title="交叉编码器、双编码器"></a>交叉编码器、双编码器</h2><p><code>在信息检索领域（即从海量数据中查找相关信息），双编码器和交叉编码器是两种至关重要的工具。它们各自拥有独特的工作机制、优势和局限性</code></p><p>*双编码器(Bi-Encoder)：高效的大规模检索*<br>双编码器分别处理文档和搜索查询。可以将其类比为两个人独立工作：一人负责概括文档，另一人则专注于搜索查询，两者之间互不交流。“双”字体现了查询和文档的独立编码过程。</p><p>*交叉编码器(cross-encoder)：高效的多任务学习*<br>1.交叉编码器将两个文本片段（例如，用户查询和文档）同时作为输入。它不分别生成向量表示，而是输出 0 到 1 之间的值，表示输入对的相似度。<br>2.交叉编码器在高精度至关重要的任务中尤其重要，例如在最终文档重排序阶段，或在语义匹配的准确性至关重要时。</p><h2 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h2><p>余弦相似度是衡量两个向量 $ \mathbf{A} $ 和 $ \mathbf{B} $ 之间夹角的指标，公式如下：<br>$$\text{cosine_similarity}(\mathbf{A}, \mathbf{B}) &#x3D; \frac{\mathbf{A} \cdot \mathbf{B}}{|\mathbf{A}| |\mathbf{B}|}$$<br><code>余弦相似度范围为 $[-1, 1]$，值越大表示越相似。</code></p><h2 id="欧氏距离"><a href="#欧氏距离" class="headerlink" title="欧氏距离"></a>欧氏距离</h2><h2 id="语义相似度、文本相似度、向量相似度"><a href="#语义相似度、文本相似度、向量相似度" class="headerlink" title="语义相似度、文本相似度、向量相似度"></a>语义相似度、文本相似度、向量相似度</h2><ul><li>向量相似度是实现语义相似度和文本相似度的一种常用技术:。</li></ul><h2 id="向量维度-≠-精度，二者的区别？"><a href="#向量维度-≠-精度，二者的区别？" class="headerlink" title="向量维度 ≠ 精度，二者的区别？"></a>向量维度 ≠ 精度，二者的区别？</h2><p>概念说明<br>维度（Dimension）向量的长度，比如是 384、768 还是 1024 维。它影响的是“表达能力上限”。维度越高，模型有更多空间表达复杂语义关系。但也可能引入噪声。<br>精度（Precision）通常指模型在特定任务上的检索准确率，比如 Top-1 命中率、MRR（Mean Reciprocal Rank）、Recall@K。它取决于训练数据、目标任务是 否匹配，而不是维度本身。<br>举个例子一个 384 维的模型可能在法律领域比 1024 维的通用模型效果还好（因为数据更贴近）</p><h2 id="向量库差异对比"><a href="#向量库差异对比" class="headerlink" title="向量库差异对比"></a>向量库差异对比</h2><p>使用场景推荐库原因<br>本地轻量测试FAISS &#x2F; Chroma快、简单、集成方便<br>中型项目（多用户、多字段）Qdrant &#x2F; Milvus高性能 + 支持 metadata + 支持 REST&#x2F;gRPC<br>想做 hybrid 检索（关键词 + 向量）Weaviate &#x2F; ElasticSearch有结构化 + semantic 搜索能力<br>有中文大数据、需要稳定上线Milvus（Zilliz 出品）生态全、企业支持强</p><h2 id="检索"><a href="#检索" class="headerlink" title="检索"></a><strong>检索</strong></h2><p><code>检索 = 信息命中的关键策略，关键词 vs 向量 vs 混合，各有千秋，选错方法可能“差之毫厘谬以千里”。</code></p><ul><li><p>1.常见检索方式总览<br>检索方式技术基础优点缺点应用场景示例<br>关键词检索BM25、TF-IDF快速、解释性强不懂语义，无法容错FAQ 检索、搜索引擎<br>向量检索Embedding + Faiss &#x2F; Milvus 等语义相关性强，能理解语言的含义不懂结构、不精确、不透明RAG 问答、智能客服、推荐系统<br>混合检索向量 + 关键词 + rerank结合语义与关键词，效果更好实现复杂高要求的智能搜索系统</p></li><li><p>2.关键词检索（Keyword-based Retrieval）</p></li></ul><ol><li>原理<br>文档、问题 → 分词 → 统计词频（TF-IDF）或 BM25 打分 → 选出包含关键词的文档,不理解「语义」层面，比如“结婚”≠“婚礼”</li><li>关键词检索优点<br>快、可解释：你知道它为啥命中，因为你看到词了<br>适合标题、标签、代码搜索等场景</li></ol><ul><li>3.向量检索</li></ul><ol><li>原理<br>每段文本 → 转成向量（用 Embedding 模型）<br>问题 → 也转成向量<br>相似度计算（通常是余弦相似度） → 得出最相近的文本段落</li><li>向量检索优点<br>可理解语言语义，如“我累了”≈“我想休息一下”,能找到意思相近但没有关键词重合的内容</li><li>缺点<br>不解释为什么召回了这些文本<br>不适合精确查找、对结构敏感的信息（比如合同条款）</li></ol><ul><li>⚖️ 4.混合检索（Hybrid Retrieval）<br>通常是以下结构：</li></ul><ol><li>问题 -&gt; Embedding 向量</li><li>向量检索召回 Top-K 文档（广撒网）</li><li><ul><li>BM25&#x2F;关键词命中过滤（精准查找）</li></ul></li><li><ul><li>Reranker 精排打分（语义判断）</li></ul></li></ol><h2 id="TopK-背后的“相关性”是怎么判断的？"><a href="#TopK-背后的“相关性”是怎么判断的？" class="headerlink" title="TopK 背后的“相关性”是怎么判断的？"></a>TopK 背后的“相关性”是怎么判断的？</h2><p>检索方式相似度&#x2F;相关性分数是怎么来的？<br>BM25基于词频+逆文档频率（TF-IDF）+词位信息<br>向量检索计算 Query 和文档向量的余弦相似度<br>语义 rerank用更大的 LLM 比较语义相关性（例如 bge-reranker）</p>]]></content>
    
    
    <categories>
      
      <category>大模型框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ragflow0.20.4(retrival)</title>
    <link href="/2025/09/18/%E6%A3%80%E7%B4%A2%E7%BB%84%E4%BB%B60.20.4/"/>
    <url>/2025/09/18/%E6%A3%80%E7%B4%A2%E7%BB%84%E4%BB%B60.20.4/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RetrievalParam</span>(<span class="hljs-title class_ inherited__">ToolParamBase</span>):    <span class="hljs-comment"># 继承自公共参数基类</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Define the Retrieval component parameters.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.meta:ToolMeta = &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;search_my_dateset&quot;</span>,<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;This tool can be utilized for relevant content searching in the datasets.&quot;</span>,<br>            <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;The keywords to search the dataset. The keywords should be the most important words/terms(includes synonyms) from the original request.&quot;</span>,<br>                    <span class="hljs-string">&quot;default&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                    <span class="hljs-string">&quot;required&quot;</span>: <span class="hljs-literal">True</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.similarity_threshold = <span class="hljs-number">0.2</span>        <span class="hljs-comment"># 向量相似度低于 0.2 的块不要</span><br>        <span class="hljs-variable language_">self</span>.keywords_similarity_weight = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 关键词匹配得分占 50%，向量得分占 50%</span><br>        <span class="hljs-variable language_">self</span>.top_n = <span class="hljs-number">8</span>                         <span class="hljs-comment"># 最终返回 8 个文本块</span><br>        <span class="hljs-variable language_">self</span>.top_k = <span class="hljs-number">1024</span>                      <span class="hljs-comment"># 向量索引阶段先粗筛 1024 个，再精排</span><br>        <span class="hljs-variable language_">self</span>.kb_ids = []                       <span class="hljs-comment"># 允许指定多个知识库 ID</span><br>        <span class="hljs-variable language_">self</span>.kb_vars = []                      <span class="hljs-comment"># 也可以用变量名动态指代知识库</span><br>        <span class="hljs-variable language_">self</span>.rerank_id = <span class="hljs-string">&quot;&quot;</span>                    <span class="hljs-comment"># 指定一个“重排序”模型 ID（可选）</span><br>        <span class="hljs-variable language_">self</span>.empty_response = <span class="hljs-string">&quot;&quot;</span>               <span class="hljs-comment"># 啥也没搜到时的兜底文案</span><br>        <span class="hljs-variable language_">self</span>.use_kg = <span class="hljs-literal">False</span>                    <span class="hljs-comment"># 是否同时用知识图谱召回</span><br>        <span class="hljs-variable language_">self</span>.cross_languages = []              <span class="hljs-comment"># 跨语言检索配置</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">self</span>):     <span class="hljs-comment"># 参数合法性自检</span><br>        <span class="hljs-variable language_">self</span>.check_decimal_float(<span class="hljs-variable language_">self</span>.similarity_threshold, <span class="hljs-string">&quot;[Retrieval] Similarity threshold&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.check_decimal_float(<span class="hljs-variable language_">self</span>.keywords_similarity_weight, <span class="hljs-string">&quot;[Retrieval] Keyword similarity weight&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.check_positive_number(<span class="hljs-variable language_">self</span>.top_n, <span class="hljs-string">&quot;[Retrieval] Top N&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_input_form</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">dict</span>]:    <span class="hljs-comment"># 告诉前端“我只需要一个单行文本框”</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Query&quot;</span>,<br>                <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;line&quot;</span><br>            &#125;<br>        &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Retrieval</span>(ToolBase, ABC):<br>    component_name = <span class="hljs-string">&quot;Retrieval&quot;</span><br><br><span class="hljs-meta">    @timeout(<span class="hljs-params">os.environ.get(<span class="hljs-params"><span class="hljs-string">&quot;COMPONENT_EXEC_TIMEOUT&quot;</span>, <span class="hljs-number">12</span></span>)</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_invoke</span>(<span class="hljs-params">self, **kwargs</span>):    <span class="hljs-comment"># 被框架回调的入口，最多跑 12 秒</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> kwargs.get(<span class="hljs-string">&quot;query&quot;</span>):<br>            <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;formalized_content&quot;</span>, <span class="hljs-variable language_">self</span>._param.empty_response)<br><br>        kb_ids: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = []<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._param.kb_ids:    <span class="hljs-comment"># 支持“硬编码 ID”或“变量名@变量”</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span>.find(<span class="hljs-string">&quot;@&quot;</span>) &lt; <span class="hljs-number">0</span>:<br>                kb_ids.append(<span class="hljs-built_in">id</span>)<br>                <span class="hljs-keyword">continue</span><br>            kb_nm = <span class="hljs-variable language_">self</span>._canvas.get_variable_value(<span class="hljs-built_in">id</span>)<br>            <span class="hljs-comment"># if kb_nm is a list</span><br>            kb_nm_list = kb_nm <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(kb_nm, <span class="hljs-built_in">list</span>) <span class="hljs-keyword">else</span> [kb_nm]<br>            <span class="hljs-keyword">for</span> nm_or_id <span class="hljs-keyword">in</span> kb_nm_list:<br>                e, kb = KnowledgebaseService.get_by_name(nm_or_id,<br>                                                         <span class="hljs-variable language_">self</span>._canvas._tenant_id)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> e:<br>                    e, kb = KnowledgebaseService.get_by_id(nm_or_id)<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> e:<br>                        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">f&quot;Dataset(<span class="hljs-subst">&#123;nm_or_id&#125;</span>) does not exist.&quot;</span>)<br>                kb_ids.append(kb.<span class="hljs-built_in">id</span>)<br><br>        filtered_kb_ids: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>([kb_id <span class="hljs-keyword">for</span> kb_id <span class="hljs-keyword">in</span> kb_ids <span class="hljs-keyword">if</span> kb_id]))<br><br>        kbs = KnowledgebaseService.get_by_ids(filtered_kb_ids)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> kbs:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;No dataset is selected.&quot;</span>)<br><br>        embd_nms = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>([kb.embd_id <span class="hljs-keyword">for</span> kb <span class="hljs-keyword">in</span> kbs]))<br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(embd_nms) == <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Knowledge bases use different embedding models.&quot;</span>    <span class="hljs-comment"># 一次检索必须所有库用同一种向量模型，否则无法拼结果</span><br><br>        embd_mdl = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> embd_nms:<br>            embd_mdl = LLMBundle(<span class="hljs-variable language_">self</span>._canvas.get_tenant_id(), LLMType.EMBEDDING, embd_nms[<span class="hljs-number">0</span>])<br><br>        rerank_mdl = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._param.rerank_id:<br>            rerank_mdl = LLMBundle(kbs[<span class="hljs-number">0</span>].tenant_id, LLMType.RERANK, <span class="hljs-variable language_">self</span>._param.rerank_id)<br><br>        <span class="hljs-built_in">vars</span> = <span class="hljs-variable language_">self</span>.get_input_elements_from_text(kwargs[<span class="hljs-string">&quot;query&quot;</span>])<br>        <span class="hljs-built_in">vars</span> = &#123;k:o[<span class="hljs-string">&quot;value&quot;</span>] <span class="hljs-keyword">for</span> k,o <span class="hljs-keyword">in</span> <span class="hljs-built_in">vars</span>.items()&#125;<br>        query = <span class="hljs-variable language_">self</span>.string_format(kwargs[<span class="hljs-string">&quot;query&quot;</span>], <span class="hljs-built_in">vars</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._param.cross_languages:<br>             <span class="hljs-comment"># 跨语言场景：把 query 翻成目标语言</span><br>            query = cross_languages(kbs[<span class="hljs-number">0</span>].tenant_id, <span class="hljs-literal">None</span>, query, <span class="hljs-variable language_">self</span>._param.cross_languages)<br><br>        <span class="hljs-keyword">if</span> kbs:<br>            query = re.sub(<span class="hljs-string">r&quot;^user[:：\s]*&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, query, flags=re.IGNORECASE)<br>            kbinfos = settings.retrievaler.retrieval(<br>                query,<br>                embd_mdl,<br>                [kb.tenant_id <span class="hljs-keyword">for</span> kb <span class="hljs-keyword">in</span> kbs],<br>                filtered_kb_ids,<br>                <span class="hljs-number">1</span>,<br>                <span class="hljs-variable language_">self</span>._param.top_n,<br>                <span class="hljs-variable language_">self</span>._param.similarity_threshold,<br>                <span class="hljs-number">1</span> - <span class="hljs-variable language_">self</span>._param.keywords_similarity_weight,<br>                aggs=<span class="hljs-literal">False</span>,<br>                rerank_mdl=rerank_mdl,<br>                rank_feature=label_question(query, kbs),<br>            )<br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._param.use_kg:    <span class="hljs-comment"># 如果开启知识图谱</span><br>                ck = settings.kg_retrievaler.retrieval(query,<br>                                                       [kb.tenant_id <span class="hljs-keyword">for</span> kb <span class="hljs-keyword">in</span> kbs],<br>                                                       kb_ids,<br>                                                       embd_mdl,<br>                                                       LLMBundle(<span class="hljs-variable language_">self</span>._canvas.get_tenant_id(), LLMType.CHAT))<br>                <span class="hljs-keyword">if</span> ck[<span class="hljs-string">&quot;content_with_weight&quot;</span>]:<br>                    kbinfos[<span class="hljs-string">&quot;chunks&quot;</span>].insert(<span class="hljs-number">0</span>, ck)<br>        <span class="hljs-keyword">else</span>:<br>            kbinfos = &#123;<span class="hljs-string">&quot;chunks&quot;</span>: [], <span class="hljs-string">&quot;doc_aggs&quot;</span>: []&#125;<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._param.use_kg <span class="hljs-keyword">and</span> kbs:<br>            ck = settings.kg_retrievaler.retrieval(query, [kb.tenant_id <span class="hljs-keyword">for</span> kb <span class="hljs-keyword">in</span> kbs], filtered_kb_ids, embd_mdl, LLMBundle(kbs[<span class="hljs-number">0</span>].tenant_id, LLMType.CHAT))<br>            <span class="hljs-keyword">if</span> ck[<span class="hljs-string">&quot;content_with_weight&quot;</span>]:<br>                ck[<span class="hljs-string">&quot;content&quot;</span>] = ck[<span class="hljs-string">&quot;content_with_weight&quot;</span>]<br>                <span class="hljs-keyword">del</span> ck[<span class="hljs-string">&quot;content_with_weight&quot;</span>]<br>                kbinfos[<span class="hljs-string">&quot;chunks&quot;</span>].insert(<span class="hljs-number">0</span>, ck)<br><br>        <span class="hljs-keyword">for</span> ck <span class="hljs-keyword">in</span> kbinfos[<span class="hljs-string">&quot;chunks&quot;</span>]:<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;vector&quot;</span> <span class="hljs-keyword">in</span> ck:<br>                <span class="hljs-keyword">del</span> ck[<span class="hljs-string">&quot;vector&quot;</span>]<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;content_ltks&quot;</span> <span class="hljs-keyword">in</span> ck:<br>                <span class="hljs-keyword">del</span> ck[<span class="hljs-string">&quot;content_ltks&quot;</span>]<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> kbinfos[<span class="hljs-string">&quot;chunks&quot;</span>]:<br>            <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;formalized_content&quot;</span>, <span class="hljs-variable language_">self</span>._param.empty_response)<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-variable language_">self</span>._canvas.add_refernce(kbinfos[<span class="hljs-string">&quot;chunks&quot;</span>], kbinfos[<span class="hljs-string">&quot;doc_aggs&quot;</span>])<br>        form_cnt = <span class="hljs-string">&quot;\n&quot;</span>.join(kb_prompt(kbinfos, <span class="hljs-number">200000</span>, <span class="hljs-literal">True</span>))<br>        <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;formalized_content&quot;</span>, form_cnt)<br>        <span class="hljs-keyword">return</span> form_cnt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">thoughts</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Keywords: &#123;&#125; </span><br><span class="hljs-string">Looking for the most relevant articles.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.get_input().get(<span class="hljs-string">&quot;query&quot;</span>, <span class="hljs-string">&quot;-_-!&quot;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大模型框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ragflow0.20.4(llm_service)</title>
    <link href="/2025/09/18/llm_service/"/>
    <url>/2025/09/18/llm_service/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">chat</span>(<span class="hljs-params">self, system: <span class="hljs-built_in">str</span>, history: <span class="hljs-built_in">list</span>, gen_conf: <span class="hljs-built_in">dict</span> = &#123;&#125;, **kwargs</span>) -&gt; <span class="hljs-built_in">str</span>:<br></code></pre></td></tr></table></figure><pre><code class="hljs">    system: 系统提示词（system prompt）    history: 聊天历史（用户和模型的对话记录）    gen_conf: 生成配置（比如 temperature、max_tokens 等）    kwargs: 额外的参数（会做清洗再传下去）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.langfuse:   <span class="hljs-comment">#启用了 Langfuse（一个 LLM 调用追踪 &amp; 分析工具），这里会启动一个新的 “generation” 追踪，记录输入。</span><br>    generation = <span class="hljs-variable language_">self</span>.langfuse.start_generation(trace_context=<span class="hljs-variable language_">self</span>.trace_context, name=<span class="hljs-string">&quot;chat&quot;</span>, model=<span class="hljs-variable language_">self</span>.llm_name, <span class="hljs-built_in">input</span>=&#123;<span class="hljs-string">&quot;system&quot;</span>: system, <span class="hljs-string">&quot;history&quot;</span>: history&#125;)<br><br>chat_partial = partial(<span class="hljs-variable language_">self</span>.mdl.chat, system, history, gen_conf)<br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.is_tools <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.mdl.is_tools:<br>    chat_partial = partial(<span class="hljs-variable language_">self</span>.mdl.chat_with_tools, system, history, gen_conf)<br>    <br>use_kwargs = <span class="hljs-variable language_">self</span>._clean_param(chat_partial, **kwargs)  <span class="hljs-comment"># kwargs 交给 _clean_param 清洗、过滤或转换为 chat_partial 实际接受的参数名/格式</span><br>txt, used_tokens = chat_partial(**use_kwargs)<br>txt = <span class="hljs-variable language_">self</span>._remove_reasoning_content(txt)<br><br><br><span class="hljs-comment"># 如果配置 verbose_tool_use 为 False（不希望在最终响应中看到工具调用细节），就用正则把 &lt;tool_call&gt;...&lt;/tool_call&gt; 区段删掉。</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.verbose_tool_use:<br>    txt = re.sub(<span class="hljs-string">r&quot;&lt;tool_call&gt;.*?&lt;/tool_call&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, txt, flags=re.DOTALL)<br><br><span class="hljs-comment"># 先判断 txt 是否是 int，再调用 TenantLLMService.increase_usage(...) 去增加租户的 token 用量统计。</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(txt, <span class="hljs-built_in">int</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> TenantLLMService.increase_usage(<span class="hljs-variable language_">self</span>.tenant_id, <span class="hljs-variable language_">self</span>.llm_type, used_tokens, <span class="hljs-variable language_">self</span>.llm_name):<br>    logging.error(<span class="hljs-string">&quot;LLMBundle.chat can&#x27;t update token usage for &#123;&#125;/CHAT llm_name: &#123;&#125;, used_tokens: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.tenant_id, <span class="hljs-variable language_">self</span>.llm_name, used_tokens))<br><br><br><span class="hljs-comment"># 如果启用了 langfuse，把输出 txt 和使用详情 used_tokens 更新到之前创建的 generation 对象上，然后调用 </span><br><span class="hljs-comment"># generation.end() 结束这次追踪。这样 Langfuse 会保存整条生成的输入/输出/用量等元数据。</span><br><span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.langfuse:<br>    generation.update(output=&#123;<span class="hljs-string">&quot;output&quot;</span>: txt&#125;, usage_details=&#123;<span class="hljs-string">&quot;total_tokens&quot;</span>: used_tokens&#125;)<br>    generation.end()<br><br><span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure></code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">chat</span>(<span class="hljs-params">self, system, history, gen_conf=&#123;&#125;, **kwargs</span>):<br>    <span class="hljs-keyword">if</span> system:<br>        history.insert(<span class="hljs-number">0</span>, &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: system&#125;)<br>    gen_conf = <span class="hljs-variable language_">self</span>._clean_conf(gen_conf)<br><br>    <span class="hljs-comment"># Implement exponential backoff retry strategy</span><br>    <span class="hljs-keyword">for</span> attempt <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.max_retries + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">try</span>:<br>            response = <span class="hljs-variable language_">self</span>._chat(history, gen_conf, **kwargs)<br>            <span class="hljs-keyword">return</span> response<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            e = <span class="hljs-variable language_">self</span>._exceptions(e, attempt)<br>            <span class="hljs-keyword">if</span> e:<br>                <span class="hljs-keyword">return</span> e, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span>, <span class="hljs-string">&quot;Shouldn&#x27;t be here.&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_chat</span>(<span class="hljs-params">self, history, gen_conf, **kwargs</span>):<br>       logging.info(<span class="hljs-string">&quot;[HISTORY]&quot;</span> + json.dumps(history, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>))<br>       <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.model_name.lower().find(<span class="hljs-string">&quot;qwen3&quot;</span>) &gt;= <span class="hljs-number">0</span>:<br>           kwargs[<span class="hljs-string">&quot;extra_body&quot;</span>] = &#123;<span class="hljs-string">&quot;enable_thinking&quot;</span>: <span class="hljs-literal">False</span>&#125;<br><br>       completion_args = <span class="hljs-variable language_">self</span>._construct_completion_args(history=history, stream=<span class="hljs-literal">False</span>, tools=<span class="hljs-literal">False</span>, **gen_conf)<br>       response = litellm.completion(<br>           **completion_args,<br>           drop_params=<span class="hljs-literal">True</span>,<br>           timeout=<span class="hljs-variable language_">self</span>.timeout,<br>       )<br>       <span class="hljs-comment"># response = self.client.chat.completions.create(model=self.model_name, messages=history, **gen_conf, **kwargs)</span><br><br>       <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>([<span class="hljs-keyword">not</span> response.choices, <span class="hljs-keyword">not</span> response.choices[<span class="hljs-number">0</span>].message, <span class="hljs-keyword">not</span> response.choices[<span class="hljs-number">0</span>].message.content]):<br>           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span><br>       ans = response.choices[<span class="hljs-number">0</span>].message.content.strip()<br>       <span class="hljs-keyword">if</span> response.choices[<span class="hljs-number">0</span>].finish_reason == <span class="hljs-string">&quot;length&quot;</span>:<br>           ans = <span class="hljs-variable language_">self</span>._length_stop(ans)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_construct_completion_args</span>(<span class="hljs-params">self, history, stream: <span class="hljs-built_in">bool</span>, tools: <span class="hljs-built_in">bool</span>, **kwargs</span>):<br>       completion_args = &#123;<br>           <span class="hljs-string">&quot;model&quot;</span>: <span class="hljs-variable language_">self</span>.model_name,<br>           <span class="hljs-string">&quot;messages&quot;</span>: history,<br>           <span class="hljs-string">&quot;api_key&quot;</span>: <span class="hljs-variable language_">self</span>.api_key,<br>           **kwargs,<br>       &#125;<br>       <span class="hljs-keyword">if</span> stream:<br>           completion_args.update(<br>               &#123;<br>                   <span class="hljs-string">&quot;stream&quot;</span>: stream,<br>               &#125;<br>           )<br>       <br>       <span class="hljs-keyword">if</span> tools <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.tools:<br>           completion_args.update(<br>               &#123;<br>                   <span class="hljs-string">&quot;tools&quot;</span>: <span class="hljs-variable language_">self</span>.tools,<span class="hljs-comment">#工具定义。</span><br>                   <span class="hljs-string">&quot;tool_choice&quot;</span>: <span class="hljs-string">&quot;auto&quot;</span>,<span class="hljs-comment">#让模型自动选择是否调用工具。</span><br>               &#125;<br>           )<br><br>       <span class="hljs-comment"># 如果当前提供商在默认 base_url 列表中，则添加 &quot;api_base&quot;: self.base_url。</span><br>       <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.provider <span class="hljs-keyword">in</span> FACTORY_DEFAULT_BASE_URL:<br>           completion_args.update(&#123;<span class="hljs-string">&quot;api_base&quot;</span>: <span class="hljs-variable language_">self</span>.base_url&#125;)<br>       <br>       <span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.provider == SupportedLiteLLMProvider.Bedrock:<br>           completion_args.pop(<span class="hljs-string">&quot;api_key&quot;</span>, <span class="hljs-literal">None</span>)<br>           completion_args.pop(<span class="hljs-string">&quot;api_base&quot;</span>, <span class="hljs-literal">None</span>)<br>           completion_args.update(<br>               &#123;<br>                   <span class="hljs-string">&quot;aws_access_key_id&quot;</span>: <span class="hljs-variable language_">self</span>.bedrock_ak,<br>                   <span class="hljs-string">&quot;aws_secret_access_key&quot;</span>: <span class="hljs-variable language_">self</span>.bedrock_sk,<br>                   <span class="hljs-string">&quot;aws_region_name&quot;</span>: <span class="hljs-variable language_">self</span>.bedrock_region,<br>               &#125;<br>           )<br>       <span class="hljs-keyword">return</span> completion_args<br></code></pre></td></tr></table></figure><h1 id="前端返回的"><a href="#前端返回的" class="headerlink" title="前端返回的"></a><strong>前端返回的</strong></h1><p>“### <strong>Task Analysis: “静夜思原文”</strong> — #### <strong>1. Is it just a small talk?</strong> ❌ <strong>No</strong>, this is not small talk. The query “静夜思原文” (meaning “Original text of <em>Quiet Night Thoughts</em>“) is a <strong>factual, information-seeking request</strong>. It asks for the original poem by Li Bai titled 《静夜思》, which is one of the most famous classical Chinese poems. This requires retrieval and presentation of accurate textual content. &gt; ✅ <strong>Conclusion</strong>: Not small talk — proceed with full analysis. — #### <strong>2. What is the core objective of the task?</strong> 🎯 <strong>Core Objective</strong>: To provide the <strong>original full text</strong> of the poem 《静夜思》 written by the Tang dynasty poet <strong>Li Bai (李白)</strong> in <strong>Classical Chinese</strong>, as traditionally recognized and widely accepted in standard literary sources. This includes: - The correct version of the poem (avoiding misquotations or variants). - Presenting it in its original form (four lines, five characters per line). — #### <strong>3. What is the complexity level of the task?</strong> 🔍 <strong>Complexity Level</strong>: <strong>Low</strong> Reasoning: - The poem is among the most well-known in Chinese literature. - It has a standardized canonical version taught in schools across China. - No interpretation, translation, or contextual explanation is requested — only the <strong>original text</strong>. - Minimal ambiguity in intent. However, despite low complexity, accuracy must still be ensured due to potential variations in historical texts or common misremembered versions. &gt; ⚠️ Note: Some users may confuse slight variants (e.g., “床前明月光” vs. “牀前明月光”), but these are orthographic differences rather than substantive ones. — #### <strong>4. What types of specialized skills are required?</strong> 📚 Required Skills: - <strong>Knowledge of Classical Chinese poetry</strong> - <strong>Access to authoritative literary datasets or corpora</strong> - <strong>Ability to distinguish canonical from non-canonical versions</strong> - <strong>Basic understanding of Chinese character variants (e.g., 简体 vs. 繁体)</strong> Since the user asked for the <strong>original text</strong>, the response should reflect the standard modern simplified Chinese version typically used in mainland education unless otherwise specified. ✅ However, since no specific script (simplified&#x2F;traditional) was requested, default to <strong>modern standard simplified Chinese</strong>. — #### <strong>5. Does the task need to be decomposed into subtasks? If yes, propose the subtask structure.</strong> ✅ <strong>Yes</strong>, although simple, decomposition ensures robustness and verifiability. ##### <strong>Proposed Subtask Structure</strong>: | Subtask | Description | Purpose | |——–|————-|——–| | <strong>ST1: Clarify Intent</strong> | Confirm that the user wants the original poem text by Li Bai titled 《静夜思》 | Avoid confusion with similar titles or parodies | | <strong>ST2: Retrieve Canonical Text</strong> | Use reliable source&#x2F;data to retrieve the standard version of the poem | Ensure accuracy | | <strong>ST3: Validate Version</strong> | Cross-check against known authoritative editions (e.g., Complete Tang Poems, school textbooks) | Prevent propagation of errors or folk variants | | <strong>ST4: Format Output</strong> | Present the poem clearly, line-by-line, without additions unless needed | Meet user expectations for readability | &gt; 🔍 Since we have access to <code>search_my_dateset</code>, we can use it at <strong>ST2</strong> to retrieve the poem. — #### <strong>6. How to know the task or the subtasks are impossible to lead to success after a few rounds of interaction?</strong> 🛑 <strong>Failure Indicators</strong>: | Scenario | Detection Method | Conclusion | |——–|——————|———–| | <code>search_my_dateset</code> returns no results for queries like <code>&quot;静夜思 原文&quot;</code> or <code>&quot;静夜思 李白&quot;</code> | After 2–3 attempts with synonym variations (e.g., “全文”, “原文”, “诗”) | Dataset lacks basic cultural knowledge → critical gap | | Results contain inconsistent or conflicting versions (e.g., different wordings across results) | Multiple unresolvable discrepancies | Requires external validation; if unavailable, flag uncertainty | | Returned text is incomplete (only 1–2 lines) or corrupted | Inspection fails consistency check | Insufficient data quality | 🟢 <strong>Success Condition</strong>: One clear, consistent, complete four-line version matching established canon appears in search results. If repeated searches fail to produce such a result, conclude: &gt; ❌ “Unable to retrieve verified original text due to dataset limitations.” — #### <strong>7. What are the expected success criteria?</strong> ✅ <strong>Success Criteria</strong>: | Criterion | Description | |——–|————-| | <strong>Accuracy</strong> | Must match the standard version of 《静夜思》 as commonly accepted: <br>床前明月光， <br>疑是地上霜。 <br>举头望明月， <br>低头思故乡。 | | <strong>Completeness</strong> | All four lines present | | <strong>Original Form</strong> | In Classical Chinese (not translated or paraphrased) | | <strong>Clarity</strong> | Clearly formatted, easy to read | | <strong>Source Reliability</strong> | Based on authoritative corpus (via <code>search_my_dateset</code>) | | <strong>No Extra Content</strong> | Unless requested, do not include translation, commentary, or author bio | &gt; 🎯 Final Output Example (Expected): <code>床前明月光， 疑是地上霜。 举头望明月， 低头思故乡。</code> — ### ✅ <strong>Summary &amp; Recommended Execution Plan</strong> | Aspect | Assessment | |——-|————| | <strong>Nature of Task</strong> | Factual retrieval of a famous Chinese poem | | <strong>Core Objective</strong> | Provide the original text of 《静夜思》 by Li Bai | | <strong>Complexity</strong> | Low | | <strong>Required Skills</strong> | Knowledge of Chinese poetry, data retrieval, version validation | | <strong>Subtasks Needed?</strong> | Yes — 4-step verification process recommended | | <strong>Execution Path</strong> | 1. Call <code>search_my_dateset(query=&quot;静夜思 原文 李白&quot;)</code> 2. Extract and validate the returned poem 3. Format and return the canonical version 4. If ambiguous or missing: retry with synonyms (<code>&quot;静夜思 全文&quot;</code>, <code>&quot;李白 静夜思&quot;</code>) 5. If still unresolved: report failure with reason | | <strong>Success Criteria Met When</strong> | Accurate, complete, canonical version retrieved and presented | — ✅ <strong>Next Step Recommendation</strong>: ➡️ Execute: <code>json &#123; &quot;function&quot;: &quot;search_my_dateset&quot;, &quot;parameters&quot;: &#123; &quot;query&quot;: &quot;静夜思 原文 李白&quot; &#125; &#125; </code>“</p><p>analyse_task_system<br>ANALYZE_TASK_SYSTEM &#x3D; ‘Your responsibility is to execute assigned tasks to a high standard. Please:\n1. Carefully analyze the task requirements.\n2. Develop a reasonable execution plan.\n3. Execute step-by-step and document the reasoning process.\n4. Provide clear and accurate results.\n\nIf difficulties are encountered, clearly state the problem and explore alternative approaches.’,</p><p>context &#x3D; ‘Please analyze the following task:\n\nTask: 春晓原文\n\nContext: \n\n<strong>Agent Prompt</strong>\n\n<role>\n        你是\n\nnull，一位专注于的AI助手。\n</role>\n<instructions>\n        1. 理解用户请求。\n        2. 将其分解为逻辑子任务。\n        3. 逐步执行每个子任务，并清晰地进行推理。\n        4. 验证准确性和一致性。\n        5. 清晰地总结最终结果。\n</instructions>\n\n<strong>Analysis Requirements:</strong>\n1. Is it just a small talk? (If yes, no further plan or analysis is needed)\n2. What is the core objective of the task?\n3. What is the complexity level of the task?\n4. What types of specialized skills are required?\n5. Does the task need to be decomposed into subtasks? (If yes, propose the subtask structure)\n6. How to know the task or the subtasks are impossible to lead to the success after a few rounds of interaction?\n7. What are the expected success criteria?\n\n<strong>Available Sub-Agents and Their Specializations:</strong>\n\n## 1. search_my_dateset\n{\n    “type”: “function”,\n    “function”: {\n        “name”: “search_my_dateset”,\n        “description”: “”,\n        “parameters”: {\n            “type”: “object”,\n            “properties”: {\n                “query”: {\n                    “type”: “string”,\n                    “description”: “The keywords to search the dataset. The keywords should be the most important words&#x2F;terms(includes synonyms) from the original request.”\n                }\n            },\n            “required”: [\n                “query”\n            ]\n        }\n    }\n}\n\nProvide a detailed analysis of the task based on the above requirements.’</p><p>kwd<br><code>### **Task Analysis: “春晓原文”**\n\n---\n\n#### **1. Is it just a small talk?**  \n**No**, this is not small talk.\n\nThe query &quot;春晓原文&quot; (meaning *&quot;Original text of \&#39;Spring Dawn\&#39;&quot;*) is a factual, information-seeking request. It refers to a well-known classical Chinese poem titled *《春晓》* (*Chūn Xiǎo*, &quot;Spring Morning&quot;) by the Tang dynasty poet **Meng Haoran** (孟浩然). The user wants the original full text of this poem.\n\nThus, this is a **knowledge retrieval task** with cultural and literary context.\n\n---\n\n#### **2. What is the core objective of the task?**\n\n&gt; **Core Objective:**  \nTo provide the **original classical Chinese text** of the poem *《春晓》* by Meng Haoran, accurately and completely.\n\nOptional (but implied in many contexts):  \n- Provide the author’s name.\n- Optionally include pinyin or translation — but since the user only asked for 原文 (&quot;original text&quot;), these are secondary unless needed for verification.\n\n---\n\n#### **3. What is the complexity level of the task?**\n\n&gt; **Complexity Level: Low**\n\nThis is a **simple factual recall or retrieval task** involving:\n- Recognition of a famous Chinese poem from its title.\n- Accurate reproduction of a 20-character classical poem.\n\nNo reasoning, computation, or subjective interpretation is required.\n\nHowever, accuracy is critical — even one incorrect character changes the meaning.\n\n---\n\n#### **4. What types of specialized skills are required?**\n\n- **Knowledge of Chinese classical poetry**: Specifically familiarity with Tang poetry and major poets like Meng Haoran.\n- **Accuracy in classical Chinese characters**: Must reproduce the exact original text without modernization or error.\n- **Language understanding**: Ability to interpret &quot;春晓原文&quot; as requesting the source text of the poem *Chunxiao*.\n\nNo advanced analytical or creative skills are needed.\n\n---\n\n#### **5. Does the task need to be decomposed into subtasks? (If yes, propose the subtask structure)**\n\nYes, although simple, decomposition ensures systematic execution and verification.\n\n##### **Proposed Subtask Structure:**\n\n1. **Subtask 1: Interpret the Query**\n   - Confirm that “春晓” refers to the poem *Chunxiao* by Meng Haoran.\n   - Clarify that “原文” means the original classical Chinese text.\n\n2. **Subtask 2: Retrieve the Poem Text**\n   - Either:\n     - Recall from internal knowledge (if permitted), or\n     - Use </code>search_my_dateset<code>function to retrieve the correct version from a trusted dataset.\n\n3. **Subtask 3: Verify Accuracy**\n   - Cross-check the retrieved poem against authoritative sources (e.g., standard anthologies).\n   - Ensure correct characters, line breaks, punctuation (if any), and author attribution.\n\n4. **Subtask 4: Present Final Output**\n   - Deliver the original text clearly.\n   - Include minimal metadata (author) for clarity and completeness.\n\n---\n\n#### **6. How to know the task or the subtasks are impossible to lead to success after a few rounds of interaction?**\n\nFailure indicators:\n\n- **Repeated failed searches**: If multiple queries using</code>search_my_dateset<code>with variations (e.g., &quot;春晓&quot;, &quot;春晓 孟浩然&quot;, &quot;Spring Dawn poem original text&quot;) return no results or irrelevant data, then the dataset may lack coverage → **task likely impossible via search**.\n\n- **Ambiguous or conflicting results**: If different versions appear (e.g., variant characters), and no consensus can be reached, confidence drops.\n\n- **Lack of ground truth access**: If unable to verify correctness due to missing reference materials, we cannot guarantee accuracy — especially important for classical texts where small errors matter.\n\n&gt; **Decision Rule**: After **2–3 unsuccessful or inconsistent attempts**, conclude that:\n&gt; - The dataset does not contain the required information.\n&gt; - The agent cannot fulfill the request confidently.\n&gt; - Escalate or inform the user accordingly.\n\nBut note: This specific poem is extremely common; failure would suggest a serious limitation.\n\n---\n\n#### **7. What are the expected success criteria?**\n\n✅ **Success Criteria:**\n\n| Criterion | Description |\n|--------|-------------|\n| **Completeness** | All four lines of the poem are provided. |\n| **Accuracy** | Each character matches the canonical version. No typos or substitutions. |\n| **Correct Authorship** | Attributed to Meng Haoran (optional but recommended). |\n| **Original Language** | Provided in Classical Chinese (not translated or paraphrased). |\n| **Clarity** | Clearly formatted (preferably one line per verse). |\n\n🎯 Example of successful output:\n```\n春眠不觉晓，\n处处闻啼鸟。\n夜来风雨声，\n花落知多少。\n```\n— 孟浩然\n\n---\n\n### ✅ Summary &amp; Conclusion\n\n| Aspect | Assessment |\n|-------|------------|\n| **Small Talk?** | No |\n| **Core Objective** | Retrieve the original Chinese text of the poem *《春晓》* by Meng Haoran |\n| **Complexity Level** | Low |\n| **Required Skills** | Knowledge of Chinese poetry, accurate recall/retrieval |\n| **Needs Decomposition?** | Yes — 4 clear subtasks: Interpret → Retrieve → Verify → Output |\n| **Failure Detection** | After 2–3 failed/inconsistent search attempts, assume impossibility |\n| **Success Criteria** | Complete, accurate, original text with proper formatting |\n\n---\n\n### ✅ Recommended Action Plan\n\nUse the</code>search_my_dateset&#96; tool with an optimized query to retrieve the poem.\n\n&gt; 🔧 **Next Step (Execution)**:\n<code>json\n&#123;\n  &quot;tool&quot;: &quot;search_my_dateset&quot;,\n  &quot;input&quot;: &#123;\n    &quot;query&quot;: &quot;春晓 原文 孟浩然&quot;\n  &#125;\n&#125;\n</code>\n\nThis combines the poem title, request for original text, and author name to maximize precision.’</p><p>tools_desc<br>‘## 1. search_my_dateset\n{\n    “type”: “function”,\n    “function”: {\n        “name”: “search_my_dateset”,\n        “description”: “”,\n        “parameters”: {\n            “type”: “object”,\n            “properties”: {\n                “query”: {\n                    “type”: “string”,\n                    “description”: “The keywords to search the dataset. The keywords should be the most important words&#x2F;terms(includes synonyms) from the original request.”\n                }\n            },\n            “required”: [\n                “query”\n            ]\n        }\n    }\n}’</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p><strong>Observation</strong> [ { “name”: “search_my_dateset”, “result”: “\nID: 74\n├── Title: 唐诗三百首.pdf\n└── Content:\n夕殿萤飞思悄然，孤灯挑尽未成眠。迟迟钟鼓初长夜，耿耿星河欲曙天。鸳鸯瓦冷霜华重，翡翠衾寒谁与共？悠悠生死别经年，魂魄不曾来入梦。临邛道士鸿都客，能以精诚致魂魄。\n\nID: 64\n├── Title: 唐诗三百首.pdf\n└── Content:\n林表明霁色，城中增暮寒。孟浩然：宿建德江移舟泊烟渚，日暮客愁新。野旷天低树，江清月近人。孟浩然：春晓春眠不觉晓，处处闻啼鸟。夜来风雨声，花落知多少？李白：夜思床前明月光，疑是地上霜。\n\nID: 19\n├── Title: 唐诗三百首.pdf\n└── Content:\n司空曙：喜外弟卢纶见宿静夜四无邻，荒居旧业贫。雨中黄叶树，灯下白头人。以我独沉久，愧君相访频。平生自有分，况是蔡家亲！司空曙：贼平后送人北归世乱同南去，时清独北还。他乡生白发，旧国见青山。\n\nID: 79\n├── Title: 唐诗三百首.pdf\n└── Content:\n道寄人知，悯馀声之寂寞非谓文墨，取代幽忧云尔西路蝉声唱，南冠客思侵。那堪玄鬓影，来对白头吟！露重飞难进，风多响易沉。无人信高洁，谁为表予心？•纆(mò)：绳索。杜审言：和晋陵路丞早春游望\n\nID: 54\n├── Title: 唐诗三百首.pdf\n└── Content:\n•珰(dāng)：〔玉珰〕玉制的耳饰。唐李商隐《夜思》诗：“寄恨一尺素，含情双玉璫。”李商隐：无题二首之一凤尾香罗薄几重，碧文圆顶夜深缝。扇裁月魄羞难掩，车走雷声语未通。曾是寂寥金烬暗，断无消息石榴红。\n\nID: 94\n├── Title: 唐诗三百首.pdf\n└── Content:\n158李商隐：落花170ix159李商隐：凉思171160李商隐：北青萝172161温庭筠：送人东游173162马戴：灞上秋居174163马戴：楚江怀古175164张乔：书边事176165崔涂：巴山道中除夜有怀177166崔涂：孤雁178167杜荀鹤：春宫怨179168韦庄：章台夜思180169僧皎然：寻陆鸿渐不遇181\n\nID: 28\n├── Title: 唐诗三百首.pdf\n└── Content:\n弦弦掩抑声声思，似诉平生不得志。低眉信手续续弹，说尽心中无限事。轻拢慢捻抹复挑，初为霓裳后六么。大弦嘈嘈如急雨，小弦切切如私语。嘈嘈切切错杂弹，大珠小珠落玉盘。间关莺语花底滑，幽咽泉流水下滩。\n\nID: 98\n├── Title: 唐诗三百首.pdf\n└── Content:\n举头望明月，低头思故乡。” } ] <strong>Reflection</strong> ### <strong>1. Goal Achievement Status</strong> - <strong>Does the current outcome align with the original purpose of this task phase?</strong> <strong>Partially aligned</strong>, but <strong>not yet fully achieved</strong>. The goal is to retrieve the <strong>complete and correctly formatted original text of Li Bai’s <em>Jing Ye Si</em> (<em>静夜思</em>)</strong>. While fragments of the poem have been found across multiple search results (e.g., ID:64 has the first two lines, ID:98 has the last two), they are <strong>scattered</strong> and not presented as a unified, verified whole. - <strong>Critical gaps</strong>: - No single result provides the <strong>complete four-line poem</strong> in one coherent excerpt. - There is a risk of <strong>misattribution or fragmentation</strong>, especially since ID:64 mentions “Li Bai: 夜思” — which may be an alternate title or mislabeling — and other entries mix poems by different poets. - The word “床” (bed) appears in context, but there’s no full stanza confirmation from a reliable contiguous source passage. — ### <strong>2. Step Completion Check</strong> - ✅ <strong>Completed steps</strong>: - Query executed: search_my_dateset with “静夜思 原文”. - Relevant document segments retrieved that contain parts of the poem. - Identification of potential sources (ID:64 and ID:98) containing partial lines. - ❌ <strong>Pending&#x2F;incomplete steps</strong>: - <strong>Synthesize the complete poem</strong> from fragmented results. - <strong>Verify authenticity and order</strong> of the lines (i.e., confirm it matches the standard version of <em>静夜思</em>). - <strong>Confirm author attribution</strong> (Li Bai) and eliminate ambiguity caused by similar titles like “夜思”. — ### <strong>3. Information Adequacy</strong> - <strong>Is the collected data sufficient to proceed?</strong> <strong>Almost, but not quite.</strong> We have: - Lines 1–2: “床前明月光，疑是地上霜。” (from ID:64) - Lines 3–4: “举头望明月，低头思故乡。” (from ID:98) These match the <strong>standard version</strong> of <em>静夜思</em>, widely known and accepted. - <strong>Key information still needed</strong>: - A <strong>contiguous, authoritative citation</strong> confirming all four lines together. - Confirmation that this version is from a trusted collection (e.g., <em>唐诗三百首</em> PDF, page reference if possible). - Ruling out textual variants (e.g., some versions use “看月光” instead of “明月光”) — though the retrieved version is the most common. — ### <strong>4. Critical Observations</strong> - <strong>Unexpected outcomes</strong>: - The poem is split across two documents with no direct link between them. - ID:64 labels the poem as “李白：夜思”, not “静夜思” — could indicate metadata inconsistency. - Other poems about “thought” or “night” (e.g., Li Shangyin’s <em>Night Thoughts</em>) appear in results, increasing confusion. - <strong>Risks&#x2F;blockers</strong>: - Risk of presenting a <strong>reconstructed but unverified</strong> version if we assume correctness without full-source validation. - Dataset OCR or segmentation errors might have broken up the original poem. - <strong>Accuracy concerns</strong>: - No explicit mention of the title “静夜思” in any result — only inferred via content. - Need to ensure we’re not combining lines from <strong>different poems</strong>. — ### <strong>5. Next-Step Recommendations</strong> - <strong>Proposed immediate action</strong>: ➤ <strong>Combine and validate</strong>: Assemble the four lines into the standard form of <em>静夜思</em>, citing both IDs (64 and 98), and cross-check against external knowledge (internalized training data confirms this reconstruction is correct). - <strong>Alternative strategies if blocked</strong>: ➤ Use internal knowledge base: Since the model knows that the canonical <em>静夜思</em> by Li Bai is: &gt; 床前明月光， &gt; 疑是地上霜。 &gt; 举头望明月， &gt; 低头思故乡。 And the fragments match exactly, we can <strong>confidently reconstruct</strong> the poem with a disclaimer on sourcing limitations. - <strong>Tools&#x2F;inputs required for next phase</strong>: - Ability to call a more precise search tool: e.g., search_by_title_and_author(“静夜思”, “李白”) - Access to structured poetry database (preferred over PDF snippets). - Option to verify against a ground-truth corpus. — ### ✅ Final Decision Based on Evidence &amp; Knowledge: Despite fragmentation in retrieval, <strong>the combined evidence + internal validation confirms</strong> the original text of <em>静夜思</em>. #### 📜 Final Answer: <em>静夜思</em> – 李白 &gt; 床前明月光， &gt; 疑是地上霜。 &gt; 举头望明月， &gt; 低头思故乡</p>]]></content>
    
    
    <categories>
      
      <category>大模型框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ragflow0.20.4(agent_with_tools)</title>
    <link href="/2025/09/16/agent_with_tools/"/>
    <url>/2025/09/16/agent_with_tools/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_react_with_tools_streamly</span>(<span class="hljs-params">self, prompt, history: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">dict</span>], use_tools</span>):<br>        token_count = <span class="hljs-number">0</span>     <span class="hljs-comment">#累计本次交互消耗的 token（或近似值）       </span><br>        tool_metas = <span class="hljs-variable language_">self</span>.tool_meta<br>        hist = deepcopy(history)<br>        last_calling = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(hist) &gt; <span class="hljs-number">3</span>:<br>            st = timer()<br>            <span class="hljs-comment"># 把历史整合成一个“完整的问题/请求” user_request</span><br>            user_request = full_question(messages=history, chat_mdl=<span class="hljs-variable language_">self</span>.chat_mdl)<br>            <span class="hljs-variable language_">self</span>.callback(<span class="hljs-string">&quot;Multi-turn conversation optimization&quot;</span>, &#123;&#125;, user_request, elapsed_time=timer()-st)<br>        <span class="hljs-keyword">else</span>:<br>            user_request = history[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;content&quot;</span>]<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">use_tool</span>(<span class="hljs-params">name, args</span>):<br>            <span class="hljs-keyword">nonlocal</span> hist, use_tools, token_count,last_calling,user_request<br>            logging.info(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;last_calling=&#125;</span> == <span class="hljs-subst">&#123;name=&#125;</span>&quot;</span>)<br>            <span class="hljs-comment"># Summarize of function calling</span><br>            <span class="hljs-comment">#if all([</span><br>            <span class="hljs-comment">#    isinstance(self.toolcall_session.get_tool_obj(name), Agent),</span><br>            <span class="hljs-comment">#    last_calling,</span><br>            <span class="hljs-comment">#    last_calling != name</span><br>            <span class="hljs-comment">#]):</span><br>            <span class="hljs-comment">#    self.toolcall_session.get_tool_obj(name).add2system_prompt(f&quot;The chat history with other agents are as following: \n&quot; + self.get_useful_memory(user_request, str(args[&quot;user_prompt&quot;])))</span><br>            last_calling = name<br>            tool_response = <span class="hljs-variable language_">self</span>.toolcall_session.tool_call(name, args)<br>            use_tools.append(&#123;<br>                <span class="hljs-string">&quot;name&quot;</span>: name,<br>                <span class="hljs-string">&quot;arguments&quot;</span>: args,<br>                <span class="hljs-string">&quot;results&quot;</span>: tool_response<br>            &#125;)<br>            <span class="hljs-comment"># self.callback(&quot;add_memory&quot;, &#123;&#125;, &quot;...&quot;)</span><br>            <span class="hljs-comment">#self.add_memory(hist[-2][&quot;content&quot;], hist[-1][&quot;content&quot;], name, args, str(tool_response))</span><br><br>            <span class="hljs-keyword">return</span> name, tool_response<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">complete</span>():<span class="hljs-comment">#是一个生成器</span><br>            <span class="hljs-keyword">nonlocal</span> hist<br>            <span class="hljs-comment"># 判断是否需要生成引用</span><br>            need2cite = <span class="hljs-variable language_">self</span>._param.cite <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>._canvas.get_reference()[<span class="hljs-string">&quot;chunks&quot;</span>] <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>._<span class="hljs-built_in">id</span>.find(<span class="hljs-string">&quot;--&gt;&quot;</span>) &lt; <span class="hljs-number">0</span><br>            cited = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> hist[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;role&quot;</span>] == <span class="hljs-string">&quot;system&quot;</span> <span class="hljs-keyword">and</span> need2cite:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(hist) &lt; <span class="hljs-number">7</span>:<br>                    <span class="hljs-comment"># citation_prompt() 附加到 system 内容中，并把 cited=True 标记——目的在于让模型在生成时包含引用信息。</span><br>                    hist[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;content&quot;</span>] += citation_prompt()  <span class="hljs-comment"># 把 chunks 拼成一段段字符串，每段末尾追加出处信息，</span><br>                    <span class="hljs-comment"># 并控制总 token 不超过 max_tokens。</span><br>                    <span class="hljs-comment"># 返回: 字符串列表，每个元素是一段带引用的上下文。</span><br>                    cited = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;&quot;</span>, token_count<br><br>            _hist = hist<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(hist) &gt; <span class="hljs-number">12</span>:<br>                _hist = [hist[<span class="hljs-number">0</span>], hist[<span class="hljs-number">1</span>], *hist[-<span class="hljs-number">10</span>:]] <span class="hljs-comment"># “取 hist 的第 0 条、第 1 条，再加上最后 10 条，拼成新列表 _hist。”</span><br>            entire_txt = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-keyword">for</span> delta_ans <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._generate_streamly(_hist):<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> need2cite <span class="hljs-keyword">or</span> cited:<br>                    <span class="hljs-keyword">yield</span> delta_ans, <span class="hljs-number">0</span><br>                entire_txt += delta_ans<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> need2cite <span class="hljs-keyword">or</span> cited:<br>                <span class="hljs-keyword">return</span><br><br>            st = timer()<br>            txt = <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-comment"># 遍历一个生成器（或迭代器）_gen_citations，</span><br>            <span class="hljs-comment"># 它把 entire_txt 做切分，每次吐出一小段字符串（记为 delta_ans）。</span><br>            <span class="hljs-keyword">for</span> delta_ans <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._gen_citations(entire_txt):<br>                <span class="hljs-keyword">yield</span> delta_ans, <span class="hljs-number">0</span><br>                txt += delta_ans<br>            <span class="hljs-comment"># 流式输出：边生成边 yield，调用方可以立刻看到增量内容，而不用等全部拼接完。</span><br>            <span class="hljs-comment"># 本地累积：同时把每一段拼到 txt可供后续步骤使用</span><br><br>            <span class="hljs-variable language_">self</span>.callback(<span class="hljs-string">&quot;gen_citations&quot;</span>, &#123;&#125;, txt, elapsed_time=timer()-st)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">append_user_content</span>(<span class="hljs-params">hist, content</span>):<br>            <span class="hljs-keyword">if</span> hist[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;role&quot;</span>] == <span class="hljs-string">&quot;user&quot;</span>:<br>                hist[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;content&quot;</span>] += content<br>            <span class="hljs-keyword">else</span>:<br>                hist.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: content&#125;)<br><br>        st = timer()<br>        <span class="hljs-comment"># 把大模型、提示模板、用户原始请求、可用工具列表喂给它，</span><br>        <span class="hljs-comment"># 让它返回一条结构化任务描述（task_desc），供后续步骤决定该怎么调用工具、生成回答。</span><br>        task_desc = analyze_task(<span class="hljs-variable language_">self</span>.chat_mdl, prompt, user_request, tool_metas)<br>        <span class="hljs-variable language_">self</span>.callback(<span class="hljs-string">&quot;analyze_task&quot;</span>, &#123;&#125;, task_desc, elapsed_time=timer()-st)<br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>._param.max_rounds + <span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 把当前对话历史 hist 和工具列表喂给大模型，让它决定下一步：</span><br>            response, tk = next_step(<span class="hljs-variable language_">self</span>.chat_mdl, hist, tool_metas, task_desc)<br>            <span class="hljs-comment"># self.callback(&quot;next_step&quot;, &#123;&#125;, str(response)[:256]+&quot;...&quot;)</span><br>            token_count += tk<br>            hist.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: response&#125;)<br>            <span class="hljs-keyword">try</span>:<br>                <span class="hljs-comment"># 试图把 response（先去掉三重反引号内的内容）解析为 JSON 列表 functions（每个元素是一个工具调用对象）。</span><br>                functions = json_repair.loads(re.sub(<span class="hljs-string">r&quot;```.*&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, response))<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(functions, <span class="hljs-built_in">list</span>):<br>                    <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;List should be returned, but `<span class="hljs-subst">&#123;functions&#125;</span>`&quot;</span>)<br>                <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> functions:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(f, <span class="hljs-built_in">dict</span>):<br>                        <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;An object type should be returned, but `<span class="hljs-subst">&#123;f&#125;</span>`&quot;</span>)<br>                <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> executor:<br>                    thr = []<br>                    <span class="hljs-keyword">for</span> func <span class="hljs-keyword">in</span> functions:<br>                        name = func[<span class="hljs-string">&quot;name&quot;</span>]<br>                        args = func[<span class="hljs-string">&quot;arguments&quot;</span>]<br>                        <span class="hljs-keyword">if</span> name == COMPLETE_TASK:   <span class="hljs-comment">#   模型要求直接完成任务</span><br>                            append_user_content(hist, <span class="hljs-string">f&quot;Respond with a formal answer. FORGET(DO NOT mention) about `<span class="hljs-subst">&#123;COMPLETE_TASK&#125;</span>`. The language for the response MUST be as the same as the first user request.\n&quot;</span>)<br>                            <span class="hljs-keyword">for</span> txt, tkcnt <span class="hljs-keyword">in</span> complete():<br>                                <span class="hljs-keyword">yield</span> txt, tkcnt<br>                            <span class="hljs-keyword">return</span><br><br>                        thr.append(executor.submit(use_tool, name, args))<br><br>                    st = timer()<br>                    reflection = reflect(<span class="hljs-variable language_">self</span>.chat_mdl, hist, [th.result() <span class="hljs-keyword">for</span> th <span class="hljs-keyword">in</span> thr])<span class="hljs-comment">#等待所有并发工具调用完成并收集它们的返回值（阻塞直到完成）。</span><br>                    append_user_content(hist, reflection)<br>                    <span class="hljs-variable language_">self</span>.callback(<span class="hljs-string">&quot;reflection&quot;</span>, &#123;&#125;, <span class="hljs-built_in">str</span>(reflection), elapsed_time=timer()-st)<br><br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                logging.exception(msg=<span class="hljs-string">f&quot;Wrong JSON argument format in LLM ReAct response: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>                e = <span class="hljs-string">f&quot;\nTool call error, please correct the input parameter of response format and call it again.\n *** Exception ***\n<span class="hljs-subst">&#123;e&#125;</span>&quot;</span><br>                append_user_content(hist, <span class="hljs-built_in">str</span>(e))<br><br>        logging.warning( <span class="hljs-string">f&quot;Exceed max rounds: <span class="hljs-subst">&#123;self._param.max_rounds&#125;</span>&quot;</span>)<br>        final_instruction = <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string"><span class="hljs-subst">&#123;user_request&#125;</span></span><br><span class="hljs-string">IMPORTANT: You have reached the conversation limit. Based on ALL the information and research you have gathered so far, please provide a DIRECT and COMPREHENSIVE final answer to the original request.</span><br><span class="hljs-string">Instructions:</span><br><span class="hljs-string">1. SYNTHESIZE all information collected during this conversation</span><br><span class="hljs-string">2. Provide a COMPLETE response using existing data - do not suggest additional research</span><br><span class="hljs-string">3. Structure your response as a FINAL DELIVERABLE, not a plan</span><br><span class="hljs-string">4. If information is incomplete, state what you found and provide the best analysis possible with available data</span><br><span class="hljs-string">5. DO NOT mention conversation limits or suggest further steps</span><br><span class="hljs-string">6. Focus on delivering VALUE with the information already gathered</span><br><span class="hljs-string">Respond immediately with your final comprehensive answer.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        append_user_content(hist, final_instruction)<br><br>        <span class="hljs-keyword">for</span> txt, tkcnt <span class="hljs-keyword">in</span> complete():<br>            <span class="hljs-keyword">yield</span> txt, tkcnt<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_useful_memory</span>(<span class="hljs-params">self, goal: <span class="hljs-built_in">str</span>, sub_goal:<span class="hljs-built_in">str</span>, topn=<span class="hljs-number">3</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-comment"># self.callback(&quot;get_useful_memory&quot;, &#123;&quot;topn&quot;: 3&#125;, &quot;...&quot;)</span><br>        mems = <span class="hljs-variable language_">self</span>._canvas.get_memory()<br>        rank = rank_memories(<span class="hljs-variable language_">self</span>.chat_mdl, goal, sub_goal, [summ <span class="hljs-keyword">for</span> (user, assist, summ) <span class="hljs-keyword">in</span> mems])<br>        <span class="hljs-keyword">try</span>:<br>            rank = json_repair.loads(re.sub(<span class="hljs-string">r&quot;```.*&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, rank))[:topn]<br>            mems = [mems[r] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> rank]<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n\n&quot;</span>.join([<span class="hljs-string">f&quot;User: <span class="hljs-subst">&#123;u&#125;</span>\nAgent: <span class="hljs-subst">&#123;a&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> u, a,_ <span class="hljs-keyword">in</span> mems])<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            logging.exception(e)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error occurred.&quot;</span><br><br><br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">stream_output_with_tools</span>(<span class="hljs-params">self, prompt, msg</span>):<br>        <span class="hljs-comment"># 把系统提示 + 用户历史消息拼在一起，调用 message_fit_in 做截断，确保总长度不超过模型最大长度的 97 %</span><br>        <span class="hljs-comment"># ；返回截断后的新历史 msg（第一个返回值是 token 数，这里用 _ 忽略）。</span><br>        _, msg = message_fit_in([&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt&#125;, *msg], <span class="hljs-built_in">int</span>(<span class="hljs-variable language_">self</span>.chat_mdl.max_length * <span class="hljs-number">0.97</span>))<br>        answer_without_toolcall = <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-comment">#累积“纯文本回答”</span><br>        use_tools = []<br>        <span class="hljs-keyword">for</span> delta_ans,_ <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._react_with_tools_streamly(prompt, msg, use_tools):<br>            <span class="hljs-keyword">if</span> delta_ans.find(<span class="hljs-string">&quot;**ERROR**&quot;</span>) &gt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.get_exception_default_value():<br>                    <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-variable language_">self</span>.get_exception_default_value())<br>                    <span class="hljs-keyword">yield</span> <span class="hljs-variable language_">self</span>.get_exception_default_value()<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;_ERROR&quot;</span>, delta_ans)<br>            answer_without_toolcall += delta_ans<br>            <span class="hljs-keyword">yield</span> delta_ans<br><br>        <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;content&quot;</span>, answer_without_toolcall)<br>        <span class="hljs-keyword">if</span> use_tools:<br>            <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;use_tools&quot;</span>, use_tools)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_gen_citations</span>(<span class="hljs-params">self, text</span>):<br>        retrievals = <span class="hljs-variable language_">self</span>._canvas.get_reference()<br>        retrievals = &#123;<span class="hljs-string">&quot;chunks&quot;</span>: <span class="hljs-built_in">list</span>(retrievals[<span class="hljs-string">&quot;chunks&quot;</span>].values()), <span class="hljs-string">&quot;doc_aggs&quot;</span>: <span class="hljs-built_in">list</span>(retrievals[<span class="hljs-string">&quot;doc_aggs&quot;</span>].values())&#125;<br>        formated_refer = kb_prompt(retrievals, <span class="hljs-variable language_">self</span>.chat_mdl.max_length, <span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">for</span> delta_ans <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._generate_streamly([&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: citation_plus(<span class="hljs-string">&quot;\n\n&quot;</span>.join(formated_refer))&#125;,<br>                                                  &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: text&#125;<br>                                                  ]):<br>            <span class="hljs-keyword">yield</span> delta_ans<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大模型框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ragflow0.20.4(prompts)</title>
    <link href="/2025/09/12/prompts/"/>
    <url>/2025/09/12/prompts/</url>
    
    <content type="html"><![CDATA[<h2 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h2><p><code>Jinja2 是一个 Python 的模板引擎，用于动态生成文本（如 HTML、JSON 或其他格式的字符串）。它允许开发者将数据动态插入到预定义的模板中，生成定制化的输出</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">reflect</span>(<span class="hljs-params">chat_mdl, history: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">dict</span>], tool_call_res: <span class="hljs-built_in">list</span>[<span class="hljs-type">Tuple</span>]</span>):<br>    tool_calls = [&#123;<span class="hljs-string">&quot;name&quot;</span>: p[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;result&quot;</span>: p[<span class="hljs-number">1</span>]&#125; <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> tool_call_res]<br>    goal = history[<span class="hljs-number">1</span>][<span class="hljs-string">&quot;content&quot;</span>]    <span class="hljs-comment">#从对话历史 history 的第二个元素（索引为 1）中提取 &quot;content&quot; 字段，赋值给 goal</span><br>    template = PROMPT_JINJA_ENV.from_string(REFLECT)    <span class="hljs-comment">#使用 Jinja2 模板引擎（PROMPT_JINJA_ENV）从字符串 REFLECT 创建一个模板对象。</span><br>    user_prompt = template.render(goal=goal, tool_calls=tool_calls)<br>    hist = deepcopy(history)<br>    <span class="hljs-keyword">if</span> hist[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;role&quot;</span>] == <span class="hljs-string">&quot;user&quot;</span>:<br>        hist[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;content&quot;</span>] += user_prompt<br>    <span class="hljs-keyword">else</span>:<br>        hist.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: user_prompt&#125;)<br>    _, msg = message_fit_in(hist, chat_mdl.max_length)  <span class="hljs-comment">#_ 表示忽略第一个返回值，msg 是一个处理后的消息列表，可能是截断后的对话历史。</span><br>    ans = chat_mdl.chat(msg[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;content&quot;</span>], msg[<span class="hljs-number">1</span>:]) <span class="hljs-comment">#第一个参数 msg[0][&quot;content&quot;] 是调整后的消息列表的第一个消息内容（可能是用户提示）。第二个参数 msg[1:] 是剩余的对话历史（列表切片）。</span><br>    ans = re.sub(<span class="hljs-string">r&quot;^.*&lt;/think&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, ans, flags=re.DOTALL)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">**Observation**</span><br><span class="hljs-string">&#123;&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">**Reflection**</span><br><span class="hljs-string">&#123;&#125;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.<span class="hljs-built_in">format</span>(json.dumps(tool_calls, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>), ans)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">next_step</span>(<span class="hljs-params">chat_mdl, history:<span class="hljs-built_in">list</span>, tools_description: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">dict</span>], task_desc</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> tools_description:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    desc = tool_schema(tools_description)   <br>    template = PROMPT_JINJA_ENV.from_string(NEXT_STEP)<span class="hljs-comment">#是可以渲染的 Jinja2 模板对象，用于生成用户提示。</span><br>    user_prompt = <span class="hljs-string">&quot;\nWhat&#x27;s the next tool to call? If ready OR IMPOSSIBLE TO BE READY, then call `complete_task`.&quot;</span><br>    hist = deepcopy(history)<br>    <span class="hljs-keyword">if</span> hist[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;role&quot;</span>] == <span class="hljs-string">&quot;user&quot;</span>:<br>        hist[-<span class="hljs-number">1</span>][<span class="hljs-string">&quot;content&quot;</span>] += user_prompt<br>    <span class="hljs-keyword">else</span>:<br>        hist.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: user_prompt&#125;)<br><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    hist[1:]：传入对话历史从第二个元素开始（忽略第一个元素，可能是系统提示）。</span><br><span class="hljs-string">    stop=[&quot;&lt;|stop|&gt;&quot;]：指定停止标志，当模型生成 &lt;|stop|&gt; 时停止输出。</span><br><span class="hljs-string">    json_str 是聊天模型生成的回复，预计是一个 JSON 格式的字符串，表示下一步要调用的工具。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    json_str = chat_mdl.chat(template.render(task_analisys=task_desc, desc=desc, today=datetime.datetime.now().strftime(<span class="hljs-string">&quot;%Y-%m-%d&quot;</span>)),<br>                             hist[<span class="hljs-number">1</span>:], stop=[<span class="hljs-string">&quot;&lt;|stop|&gt;&quot;</span>])<br>    tk_cnt = num_tokens_from_string(json_str)<br>    json_str = re.sub(<span class="hljs-string">r&quot;^.*&lt;/think&gt;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, json_str, flags=re.DOTALL)<br>    <span class="hljs-keyword">return</span> json_str, tk_cnt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大模型框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2025/09/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/Redis/"/>
    <url>/2025/09/10/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="一、Redis-的物理结构"><a href="#一、Redis-的物理结构" class="headerlink" title="一、Redis 的物理结构"></a>一、Redis 的物理结构</h2><p><code>Redis 的物理结构是：Redis 由一个或多个 Redis 服务器（指运行 Redis 服务器程序的机器）组成，每个 Redis 服务器由一个或多个 Redis 数据库组成，而每个 Redis 数据库由多个 key-value 组成。</code><br>┌—————-Redis 进程—————-┐<br>│  默认 16 个逻辑库（DB0 ~ DB15）          │<br>│  彼此隔离，用 SELECT 0&#x2F;1&#x2F;2… 切换      │<br>└—————————————–┘</p><ul><li>端口同是 6379，DB 之间数据不互通</li></ul><h2 id="二、每个-DB-里只有一层结构：键→值"><a href="#二、每个-DB-里只有一层结构：键→值" class="headerlink" title="二、每个 DB 里只有一层结构：键→值"></a>二、每个 DB 里只有一层结构：键→值</h2><h2 id="DB1-本质就是一个大-Map：key-value"><a href="#DB1-本质就是一个大-Map：key-value" class="headerlink" title="DB1 本质就是一个大 Map：key               value"></a>DB1 本质就是一个大 Map：<br>key               value</h2><p>celery            list [“task1”, “task2” …]   ← 队列<br>celery.metadata   hash  {task1: {…}}         ← 任务元数据<br>user:123          hash  {name: “tom”}           ← 你自己存的业务数据<br>ragflow::lock::xx string 1                      ← 分布式锁</p><p><code>“队列”只是值类型为 list 的一个普通 key，名字随便取（默认叫 celery）。</code></p><h2 id="三、Redis-的数据类型三、Celery-的“队列”究竟怎么放"><a href="#三、Redis-的数据类型三、Celery-的“队列”究竟怎么放" class="headerlink" title="三、Redis 的数据类型三、Celery 的“队列”究竟怎么放"></a>三、Redis 的数据类型三、Celery 的“队列”究竟怎么放</h2><p>1.派单时<br>celery.send_task(…, queue&#x3D;’celery’)<br>内部执行：<br>LPUSH celery  {“id”:”123”, “task”:”ragflow.tasks.parse_document”}</p><p>2.Worker 启动时<br>BRPOP celery   ← 阻塞式弹出，谁先到谁先干</p><p>3.结论</p><!-- 队列 = 一个 list 类型的键生产者是 Web 进程，消费者是 Celery Worker不同队列就是不同 key 名，如 parse、ocr、index... --><h2 id="celery-是什么？"><a href="#celery-是什么？" class="headerlink" title="celery 是什么？"></a>celery 是什么？</h2><p><code>Celery 是一个分布式任务队列，它负责在后台运行一系列任务，比如：派单、OCR、索引、翻译...</code><br>celery 就是“分布式任务调度库”——帮你把“任务”从 Web 端丢到 Redis 队列，再让远程&#x2F;本地的 Worker 把任务捞起来执行。</p><p>Web 进程（生产者） →  Redis（broker 队列） →  Worker（消费者）</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ragflow0.20.4(Cavans)</title>
    <link href="/2025/09/10/ragflow0.20.4Canvas/"/>
    <url>/2025/09/10/ragflow0.20.4Canvas/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self, **kwargs</span>):<br>        st = time.perf_counter()<br>        <span class="hljs-variable language_">self</span>.message_id = get_uuid()<br>        created_at = <span class="hljs-built_in">int</span>(time.time())<br>        <span class="hljs-variable language_">self</span>.add_user_input(kwargs.get(<span class="hljs-string">&quot;query&quot;</span>))<br><br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> kwargs.keys():<br>            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;query&quot;</span>, <span class="hljs-string">&quot;user_id&quot;</span>, <span class="hljs-string">&quot;files&quot;</span>] <span class="hljs-keyword">and</span> kwargs[k]:<br>                <span class="hljs-keyword">if</span> k == <span class="hljs-string">&quot;files&quot;</span>:<br>                    <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">globals</span>[<span class="hljs-string">f&quot;sys.<span class="hljs-subst">&#123;k&#125;</span>&quot;</span>] = <span class="hljs-variable language_">self</span>.get_files(kwargs[k])<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">globals</span>[<span class="hljs-string">f&quot;sys.<span class="hljs-subst">&#123;k&#125;</span>&quot;</span>] = kwargs[k]<br><br>                    <span class="hljs-comment"># 未初始化，则设为0，然后加1，表示对话轮数+1。</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&quot;sys.conversation_turns&quot;</span>] :<br>            <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&quot;sys.conversation_turns&quot;</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">globals</span>[<span class="hljs-string">&quot;sys.conversation_turns&quot;</span>] += <span class="hljs-number">1</span><br><br>      <span class="hljs-comment"># 生成标准化的事件字典，包含事件类型、消息ID、时间戳、任务ID和数据内容。</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">event, dt</span>):<br>            <span class="hljs-keyword">nonlocal</span> created_at<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-string">&quot;event&quot;</span>: event,<br>                <span class="hljs-comment">#&quot;conversation_id&quot;: &quot;f3cc152b-24b0-4258-a1a1-7d5e9fc8a115&quot;,</span><br>                <span class="hljs-string">&quot;message_id&quot;</span>: <span class="hljs-variable language_">self</span>.message_id,<br>                <span class="hljs-string">&quot;created_at&quot;</span>: created_at,<br>                <span class="hljs-string">&quot;task_id&quot;</span>: <span class="hljs-variable language_">self</span>.task_id,<br>                <span class="hljs-string">&quot;data&quot;</span>: dt<br>            &#125;<br><br>        <span class="hljs-comment"># 如果 self.path 为空或末尾不是 userfillup，把 &quot;begin&quot; 插入路径，同时向 self.retrieval 添加空条目。</span><br>        <span class="hljs-comment"># 注意：.find(...) &lt; 0 是判断字符串不包含子串，等价于 not &quot;userfillup&quot; in</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.path <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.path[-<span class="hljs-number">1</span>].lower().find(<span class="hljs-string">&quot;userfillup&quot;</span>) &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.path.append(<span class="hljs-string">&quot;begin&quot;</span>)<br>            <span class="hljs-variable language_">self</span>.retrieval.append(&#123;<span class="hljs-string">&quot;chunks&quot;</span>: [], <span class="hljs-string">&quot;doc_aggs&quot;</span>: []&#125;)<br><br>        <span class="hljs-comment"># 广播工作流开始事件。</span><br>        <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;workflow_started&quot;</span>, &#123;<span class="hljs-string">&quot;inputs&quot;</span>: kwargs.get(<span class="hljs-string">&quot;inputs&quot;</span>)&#125;)<br>        <span class="hljs-variable language_">self</span>.retrieval.append(&#123;<span class="hljs-string">&quot;chunks&quot;</span>: &#123;&#125;, <span class="hljs-string">&quot;doc_aggs&quot;</span>: &#123;&#125;&#125;)<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_run_batch</span>(<span class="hljs-params">f, t</span>):<br>            <span class="hljs-comment"># 并发调用路径 self.path[f:t] 上的组件的 invoke 方法。</span><br>            <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> executor:<br>                thr = []<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(f, t):<br>                    cpn = <span class="hljs-variable language_">self</span>.get_component_obj(<span class="hljs-variable language_">self</span>.path[i])<br>                    <span class="hljs-keyword">if</span> cpn.component_name.lower() <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;begin&quot;</span>, <span class="hljs-string">&quot;userfillup&quot;</span>]:<br>                        <span class="hljs-comment"># executor.submit(...) 会返回一个 Future（异步任务对象），表示该任务已经排队等待执行。</span><br>                        thr.append(executor.submit(cpn.invoke, inputs=kwargs.get(<span class="hljs-string">&quot;inputs&quot;</span>, &#123;&#125;)))<br>                    <span class="hljs-keyword">else</span>:<br>                        thr.append(executor.submit(cpn.invoke, **cpn.get_input()))<br>                <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> thr:<br>                    t.result()<br><br>        <span class="hljs-comment"># 格式化单个节点完成事件。</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">_node_finished</span>(<span class="hljs-params">cpn_obj</span>):<br>            <span class="hljs-keyword">return</span> decorate(<span class="hljs-string">&quot;node_finished&quot;</span>,&#123;<br>                           <span class="hljs-string">&quot;inputs&quot;</span>: cpn_obj.get_input_values(),<br>                           <span class="hljs-string">&quot;outputs&quot;</span>: cpn_obj.output(),<br>                           <span class="hljs-string">&quot;component_id&quot;</span>: cpn_obj._<span class="hljs-built_in">id</span>,<br>                           <span class="hljs-string">&quot;component_name&quot;</span>: <span class="hljs-variable language_">self</span>.get_component_name(cpn_obj._<span class="hljs-built_in">id</span>),<br>                           <span class="hljs-string">&quot;component_type&quot;</span>: <span class="hljs-variable language_">self</span>.get_component_type(cpn_obj._<span class="hljs-built_in">id</span>),<br>                           <span class="hljs-string">&quot;error&quot;</span>: cpn_obj.error(),<br>                           <span class="hljs-string">&quot;elapsed_time&quot;</span>: time.perf_counter() - cpn_obj.output(<span class="hljs-string">&quot;_created_time&quot;</span>),<br>                           <span class="hljs-string">&quot;created_at&quot;</span>: cpn_obj.output(<span class="hljs-string">&quot;_created_time&quot;</span>),<br>                       &#125;)<br><br>        <span class="hljs-variable language_">self</span>.error = <span class="hljs-string">&quot;&quot;</span><br>        idx = <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.path) - <span class="hljs-number">1</span><br>        partials = []<br>        <span class="hljs-comment"># 主循环和节点启动</span><br>        <span class="hljs-keyword">while</span> idx &lt; <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.path):<br>            to = <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.path)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(idx, to):<br>                <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;node_started&quot;</span>, &#123;<br>                    <span class="hljs-string">&quot;inputs&quot;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&quot;created_at&quot;</span>: <span class="hljs-built_in">int</span>(time.time()),<br>                    <span class="hljs-string">&quot;component_id&quot;</span>: <span class="hljs-variable language_">self</span>.path[i],<br>                    <span class="hljs-string">&quot;component_name&quot;</span>: <span class="hljs-variable language_">self</span>.get_component_name(<span class="hljs-variable language_">self</span>.path[i]),<br>                    <span class="hljs-string">&quot;component_type&quot;</span>: <span class="hljs-variable language_">self</span>.get_component_type(<span class="hljs-variable language_">self</span>.path[i]),<br>                    <span class="hljs-string">&quot;thoughts&quot;</span>: <span class="hljs-variable language_">self</span>.get_component_thoughts(<span class="hljs-variable language_">self</span>.path[i])<br>                &#125;)<br>            _run_batch(idx, to)<br><br>            <span class="hljs-comment"># 节点后处理：message 类型与 partial 流式处理</span><br>            <span class="hljs-comment"># post processing of components invocation</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(idx, to):<br>                cpn = <span class="hljs-variable language_">self</span>.get_component(<span class="hljs-variable language_">self</span>.path[i])<br>                cpn_obj = <span class="hljs-variable language_">self</span>.get_component_obj(<span class="hljs-variable language_">self</span>.path[i])<br>                <span class="hljs-keyword">if</span> cpn_obj.component_name.lower() == <span class="hljs-string">&quot;message&quot;</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(cpn_obj.output(<span class="hljs-string">&quot;content&quot;</span>), partial):<br>                        _m = <span class="hljs-string">&quot;&quot;</span><br>                        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> cpn_obj.output(<span class="hljs-string">&quot;content&quot;</span>)():<br>                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> m:<br>                                <span class="hljs-keyword">continue</span><br>                            <span class="hljs-keyword">if</span> m == <span class="hljs-string">&quot;&lt;think&gt;&quot;</span>:<br>                                <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;message&quot;</span>, &#123;<span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;start_to_think&quot;</span>: <span class="hljs-literal">True</span>&#125;)<br>                            <span class="hljs-keyword">elif</span> m == <span class="hljs-string">&quot;&lt;/think&gt;&quot;</span>:<br>                                <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;message&quot;</span>, &#123;<span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;end_to_think&quot;</span>: <span class="hljs-literal">True</span>&#125;)<br>                            <span class="hljs-keyword">else</span>:<br>                                <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;message&quot;</span>, &#123;<span class="hljs-string">&quot;content&quot;</span>: m&#125;)<br>                                _m += m<br>                        cpn_obj.set_output(<span class="hljs-string">&quot;content&quot;</span>, _m)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;message&quot;</span>, &#123;<span class="hljs-string">&quot;content&quot;</span>: cpn_obj.output(<span class="hljs-string">&quot;content&quot;</span>)&#125;)<br>                    <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;message_end&quot;</span>, &#123;<span class="hljs-string">&quot;reference&quot;</span>: <span class="hljs-variable language_">self</span>.get_reference()&#125;)<br><br>                    <span class="hljs-keyword">while</span> partials:<br>                        _cpn_obj = <span class="hljs-variable language_">self</span>.get_component_obj(partials[<span class="hljs-number">0</span>])<br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(_cpn_obj.output(<span class="hljs-string">&quot;content&quot;</span>), partial):<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">yield</span> _node_finished(_cpn_obj)<br>                        partials.pop(<span class="hljs-number">0</span>)<br><br>                <span class="hljs-comment"># 组件错误/跳转/路径扩展逻辑</span><br>                <span class="hljs-comment"># 如果节点出错，尝试处理异常。可以 goto 指定下一分支，或使用 default_value，否则把错误写到 self.error。</span><br>                other_branch = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> cpn_obj.error():<br>                    ex = cpn_obj.exception_handler()<span class="hljs-comment">#返回一个**“异常信息对象”**</span><br>                    <span class="hljs-keyword">if</span> ex <span class="hljs-keyword">and</span> ex[<span class="hljs-string">&quot;goto&quot;</span>]:<br>                        <span class="hljs-variable language_">self</span>.path.extend(ex[<span class="hljs-string">&quot;goto&quot;</span>])<br>                        other_branch = <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">elif</span> ex <span class="hljs-keyword">and</span> ex[<span class="hljs-string">&quot;default_value&quot;</span>]:<br>                        <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;message&quot;</span>, &#123;<span class="hljs-string">&quot;content&quot;</span>: ex[<span class="hljs-string">&quot;default_value&quot;</span>]&#125;)<br>                        <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;message_end&quot;</span>, &#123;&#125;)<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-variable language_">self</span>.error = cpn_obj.error()<br><br>                <span class="hljs-keyword">if</span> cpn_obj.component_name.lower() != <span class="hljs-string">&quot;iteration&quot;</span>:<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(cpn_obj.output(<span class="hljs-string">&quot;content&quot;</span>), partial):<br>                        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.error:<br>                            cpn_obj.set_output(<span class="hljs-string">&quot;content&quot;</span>, <span class="hljs-literal">None</span>)<br>                            <span class="hljs-keyword">yield</span> _node_finished(cpn_obj)<br>                        <span class="hljs-keyword">else</span>:<br>                            partials.append(<span class="hljs-variable language_">self</span>.path[i])<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">yield</span> _node_finished(cpn_obj)<br><br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">_append_path</span>(<span class="hljs-params">cpn_id</span>):<br>                    <span class="hljs-keyword">nonlocal</span> other_branch<br>                    <span class="hljs-keyword">if</span> other_branch:<br>                        <span class="hljs-keyword">return</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.path[-<span class="hljs-number">1</span>] == cpn_id:<br>                        <span class="hljs-keyword">return</span><br>                    <span class="hljs-variable language_">self</span>.path.append(cpn_id)<br><br>                <span class="hljs-keyword">def</span> <span class="hljs-title function_">_extend_path</span>(<span class="hljs-params">cpn_ids</span>):<br>                    <span class="hljs-keyword">nonlocal</span> other_branch<br>                    <span class="hljs-keyword">if</span> other_branch:<br>                        <span class="hljs-keyword">return</span><br>                    <span class="hljs-keyword">for</span> cpn_id <span class="hljs-keyword">in</span> cpn_ids:<br>                        _append_path(cpn_id)<br><br>                <span class="hljs-comment"># 如果当前节点是 iterationItem（迭代中的单个元素节点），并且已经 结束了迭代：</span><br>                <span class="hljs-keyword">if</span> cpn_obj.component_name.lower() == <span class="hljs-string">&quot;iterationitem&quot;</span> <span class="hljs-keyword">and</span> cpn_obj.end():<br>                    <span class="hljs-comment"># 找到它的父节点（即外层的 iteration 节点），发出 node_finished 事件，表示整个迭代结束。</span><br>                    <span class="hljs-built_in">iter</span> = cpn_obj.get_parent()<br>                    <span class="hljs-keyword">yield</span> _node_finished(<span class="hljs-built_in">iter</span>)<br>                    <span class="hljs-comment"># 然后把 父节点的 downstream（下游节点） 加到执行路径里，继续执行迭代后的流程。</span><br>                    _extend_path(<span class="hljs-variable language_">self</span>.get_component(cpn[<span class="hljs-string">&quot;parent_id&quot;</span>])[<span class="hljs-string">&quot;downstream&quot;</span>])<br>                <span class="hljs-comment"># 如果当前节点是 categorize（分类）或者 switch（条件分支）：</span><br>                <span class="hljs-keyword">elif</span> cpn_obj.component_name.lower() <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;categorize&quot;</span>, <span class="hljs-string">&quot;switch&quot;</span>]:<br>                    <span class="hljs-comment"># 从该节点的输出 _next 里取下一步的节点 ID，然后加到路径里。</span><br>                    <span class="hljs-comment"># 相当于：根据条件/分类结果，跳转到某个特定分支继续执行。</span><br>                    _extend_path(cpn_obj.output(<span class="hljs-string">&quot;_next&quot;</span>))<br>                <span class="hljs-keyword">elif</span> cpn_obj.component_name.lower() == <span class="hljs-string">&quot;iteration&quot;</span>:<br>                    <span class="hljs-comment"># 取到这个迭代的第一个子节点（get_start()），把它加入路径，开始循环的第一次迭代。</span><br>                    _append_path(cpn_obj.get_start())<br>                <span class="hljs-comment"># 如果当前节点 没有下游节点，但是它有一个父节点：</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> cpn[<span class="hljs-string">&quot;downstream&quot;</span>] <span class="hljs-keyword">and</span> cpn_obj.get_parent():<br>                    <span class="hljs-comment"># 那么跳回到父节点的 get_start()，也就是重新回到父节点的循环开始处。</span><br>                    <span class="hljs-comment"># 用在 迭代还没结束，需要继续下一个元素 的情况。</span><br>                    _append_path(cpn_obj.get_parent().get_start())<br>                <span class="hljs-keyword">else</span>:<br>                    _extend_path(cpn[<span class="hljs-string">&quot;downstream&quot;</span>])<br><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.error:<br>                logging.error(<span class="hljs-string">f&quot;Runtime Error: <span class="hljs-subst">&#123;self.error&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">break</span><br>            idx = to<br><br>            <span class="hljs-comment"># 检查从当前位置 idx 开始的执行路径里，是否还有 userfillup 节点。</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>([<span class="hljs-variable language_">self</span>.get_component_obj(c).component_name.lower() == <span class="hljs-string">&quot;userfillup&quot;</span> <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.path[idx:]]):<br>                <span class="hljs-comment"># 如果有，那么把 userfillup 之前的节点都执行完，然后把 userfillup 加入路径，继续执行,这个就进入这个分支。</span><br>                <span class="hljs-comment"># 把 userfillup 节点 提前到路径的最前面，后面跟着其它节点。</span><br>                <span class="hljs-comment"># 也就是说：优先处理所有用户输入的节点。</span><br>                path = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.path[idx:] <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.get_component(c)[<span class="hljs-string">&quot;obj&quot;</span>].component_name.lower() == <span class="hljs-string">&quot;userfillup&quot;</span>]<br>                path.extend([c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.path[idx:] <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.get_component(c)[<span class="hljs-string">&quot;obj&quot;</span>].component_name.lower() != <span class="hljs-string">&quot;userfillup&quot;</span>])<br>                another_inputs = &#123;&#125;<br>                tips = <span class="hljs-string">&quot;&quot;</span><br><br>                <span class="hljs-comment">#遍历路径，找到所有 userfillup 节点：</span><br>                <span class="hljs-comment"># 收集它们的 输入元素（get_input_elements()，可能是表单字段、参数等），放到 another_inputs 里。</span><br>                <span class="hljs-comment"># 如果该节点设置了提示信息（enable_tips），就取出 tips。</span><br>                <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> path:<br>                    o = <span class="hljs-variable language_">self</span>.get_component_obj(c)<br>                    <span class="hljs-keyword">if</span> o.component_name.lower() == <span class="hljs-string">&quot;userfillup&quot;</span>:<br>                        another_inputs.update(o.get_input_elements())<br>                        <span class="hljs-keyword">if</span> o.get_param(<span class="hljs-string">&quot;enable_tips&quot;</span>):<br>                            tips = o.get_param(<span class="hljs-string">&quot;tips&quot;</span>)<br>                <span class="hljs-variable language_">self</span>.path = path<br>                <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;user_inputs&quot;</span>, &#123;<span class="hljs-string">&quot;inputs&quot;</span>: another_inputs, <span class="hljs-string">&quot;tips&quot;</span>: tips&#125;)<br>                <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># 把 self.path 截断到已经执行过的部分（idx 之前的）</span><br>        <span class="hljs-variable language_">self</span>.path = <span class="hljs-variable language_">self</span>.path[:idx]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.error:<br>            <span class="hljs-keyword">yield</span> decorate(<span class="hljs-string">&quot;workflow_finished&quot;</span>,<br>                       &#123;<br>                           <span class="hljs-string">&quot;inputs&quot;</span>: kwargs.get(<span class="hljs-string">&quot;inputs&quot;</span>),<br>                           <span class="hljs-string">&quot;outputs&quot;</span>: <span class="hljs-variable language_">self</span>.get_component_obj(<span class="hljs-variable language_">self</span>.path[-<span class="hljs-number">1</span>]).output(),<br>                           <span class="hljs-string">&quot;elapsed_time&quot;</span>: time.perf_counter() - st,<br>                           <span class="hljs-string">&quot;created_at&quot;</span>: st,<br>                       &#125;)<br>            <span class="hljs-variable language_">self</span>.history.append((<span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-variable language_">self</span>.get_component_obj(<span class="hljs-variable language_">self</span>.path[-<span class="hljs-number">1</span>]).output()))<br><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invoke</span>(<span class="hljs-params">self, **kwargs</span>) -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:<br>        <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;_created_time&quot;</span>, time.perf_counter())<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-variable language_">self</span>._invoke(**kwargs)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.get_exception_default_value():<br>                <span class="hljs-variable language_">self</span>.set_exception_default_value()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;_ERROR&quot;</span>, <span class="hljs-built_in">str</span>(e))<br>            logging.exception(e)<br>        <span class="hljs-variable language_">self</span>._param.debug_inputs = &#123;&#125;<br>        <span class="hljs-variable language_">self</span>.set_output(<span class="hljs-string">&quot;_elapsed_time&quot;</span>, time.perf_counter() - <span class="hljs-variable language_">self</span>.output(<span class="hljs-string">&quot;_created_time&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.output()<br><br><span class="hljs-meta">    @timeout(<span class="hljs-params">os.environ.get(<span class="hljs-params"><span class="hljs-string">&quot;COMPONENT_EXEC_TIMEOUT&quot;</span>, <span class="hljs-number">10</span>*<span class="hljs-number">60</span></span>)</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_invoke</span>(<span class="hljs-params">self, **kwargs</span>):<br>        <span class="hljs-keyword">raise</span> NotImplementedError()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大模型框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ragflow0.20.4</title>
    <link href="/2025/09/06/Ragflow0.20.4%E9%83%A8%E7%BD%B2/"/>
    <url>/2025/09/06/Ragflow0.20.4%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><code>uv sync --python 3.10 --all-extras # install RAGFlow dependent python modules</code></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>uv sync<br><span class="hljs-code">    uv 的「同步」子命令：</span><br><span class="hljs-code">    读取项目根目录下的 pyproject.toml（或 uv.lock）</span><br><span class="hljs-code">    自动创建/复用虚拟环境</span><br><span class="hljs-code">    把声明的依赖一次性装进去，并保证版本完全锁死</span><br><span class="hljs-code">    如果环境里有多余的包，还会自动卸载，保持“干净”</span><br></code></pre></td></tr></table></figure><ul><li>–all-extras</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">把 pyproject.toml 里所有 [<span class="hljs-keyword">project</span>.optional-<span class="hljs-keyword">dependencies</span>] 定义的可选依赖组全部装上。<br>RAGFlow 把这些可选包用来支持不同嵌入模型、PDF 解析器、向量库等，所以必须一次性装全，否则运行时会缺模块。<br></code></pre></td></tr></table></figure><h3 id="部署错误"><a href="#部署错误" class="headerlink" title="部署错误"></a>部署错误</h3><p><code>RAGFlow 依赖的 pyicu 在 Windows 上编译失败，因为找不到 ICU 开发库。</code></p><ul><li>先装预编译的 pyicu wheel，避开编译;装完后重新同步<br><code>conda install -c conda-forge icu pyicu</code><br>从 conda-forge 频道安装 ICU 和 PyICU 两个包。</li></ul><h1 id="解析字"><a href="#解析字" class="headerlink" title="解析字"></a>解析字</h1><p><strong>WSL</strong> 是 Windows Subsystem for Linux（适用于 Linux 的 Windows 子系统）。 允许用户在 不安装虚拟机或双系统 的情况下，直接在 Windows 上运行 原生 Linux 二进制可执行文件（ELF 格式）。</p><p><strong>文件挂载</strong>：“挂载”就是把某个外部存储或文件夹，‘嫁接’到当前系统的目录树上，让你随时随地在 Linux 环境里像本地文件一样使用它。</p><h3 id="ubuntu-linux关系"><a href="#ubuntu-linux关系" class="headerlink" title="ubuntu linux关系"></a>ubuntu linux关系</h3><table><thead><tr><th>类比对象</th><th>对应关系</th></tr></thead><tbody><tr><td>汽车引擎</td><td>Linux 内核</td></tr><tr><td>整车（引擎+车身+轮子+方向盘）</td><td>Ubuntu 操作系统</td></tr><tr><td>不同品牌的车（宝马、丰田）</td><td>不同发行版（Ubuntu、Fedora、Debian）</td></tr></tbody></table><h1 id="WSL2-Windows-Subsystem-for-Linux-Ubuntu-部署-RAGFlow"><a href="#WSL2-Windows-Subsystem-for-Linux-Ubuntu-部署-RAGFlow" class="headerlink" title="WSL2 (Windows Subsystem for Linux) + Ubuntu 部署 RAGFlow"></a>WSL2 (Windows Subsystem for Linux) + Ubuntu 部署 RAGFlow</h1><h3 id="wsl安装ubuntu错误"><a href="#wsl安装ubuntu错误" class="headerlink" title="wsl安装ubuntu错误"></a>wsl安装ubuntu错误</h3><p><code>/set hypervisorlaunchtype Auto</code></p><h3 id="检查python版本"><a href="#检查python版本" class="headerlink" title="检查python版本"></a>检查python版本</h3><p>✅python3 –version</p><h3 id="uv写入环境变量"><a href="#uv写入环境变量" class="headerlink" title="uv写入环境变量"></a>uv写入环境变量</h3><p><code>echo &#39;export PATH=$HOME/.local/bin:$PATH&#39; &gt;&gt; ~/.bashrc</code><br><code>source ~/.bashrc</code></p><h3 id="Downloading-huggingface-repo-BAAI-bge-large-zh-v1-5-下载失败"><a href="#Downloading-huggingface-repo-BAAI-bge-large-zh-v1-5-下载失败" class="headerlink" title="Downloading huggingface repo BAAI&#x2F;bge-large-zh-v1.5.下载失败"></a>Downloading huggingface repo BAAI&#x2F;bge-large-zh-v1.5.下载失败</h3><p><code>修改的环境变量不生效，因为代码用的是 huggingface_hub.snapshot_download它默认是去 https://huggingface.co拉模型，不会自动走你上面设置的镜像。所以即使你在系统里设置了 HF_ENDPOINT，它也可能不生效（因为这里写死了 repo_id 但没传 endpoint 参数）</code><br>✅ 解决方法一：强制指定镜像 endpoint </p><ul><li>改 download_model 函数，加一个 endpoint 参数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> snapshot_download<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download_model</span>(<span class="hljs-params">repo_id</span>):<br>    local_dir = os.path.abspath(os.path.join(<span class="hljs-string">&quot;huggingface.co&quot;</span>, repo_id))<br>    os.makedirs(local_dir, exist_ok=<span class="hljs-literal">True</span>)<br>    snapshot_download(<br>        repo_id=repo_id,<br>        local_dir=local_dir,<br>        endpoint=os.environ.get(<span class="hljs-string">&quot;HF_ENDPOINT&quot;</span>, <span class="hljs-string">&quot;https://huggingface.co&quot;</span>)  <span class="hljs-comment"># 强制使用镜像</span><br>    )<br><br></code></pre></td></tr></table></figure><h3 id="wsl-检测到-localhost-代理配置，但未镜像到-WSL。NAT-模式下的-WSL-不支持-localhost-代理。"><a href="#wsl-检测到-localhost-代理配置，但未镜像到-WSL。NAT-模式下的-WSL-不支持-localhost-代理。" class="headerlink" title="wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。"></a>wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。</h3><p>✅在你的windows的C:\Users&lt;your_username&gt;目录下面创建一个.wslconfig文件，往里面写入下面代码</p><p>[experimental]<br>autoMemoryReclaim&#x3D;gradual<br>networkingMode&#x3D;mirrored<br>dnsTunneling&#x3D;true<br>firewall&#x3D;true<br>autoProxy&#x3D;true</p><h3 id="malloc-是一个-内存分配器（memory-allocator）"><a href="#malloc-是一个-内存分配器（memory-allocator）" class="headerlink" title="malloc 是一个 内存分配器（memory allocator）"></a>malloc 是一个 内存分配器（memory allocator）</h3><p>✅ jemalloc 是高性能、低碎片、支持多线程的内存分配器，常用于高并发、大内存应用。</p><h3 id="项目进入虚拟环境"><a href="#项目进入虚拟环境" class="headerlink" title="项目进入虚拟环境"></a>项目进入虚拟环境</h3><p>source .venv&#x2F;bin&#x2F;activate</p><h3 id="npm-install下载慢"><a href="#npm-install下载慢" class="headerlink" title="npm install下载慢"></a>npm install下载慢</h3><ul><li>1.换镜像源</li><li>2.npm install –no-audit –prefer-offline<table><thead><tr><th>flag</th><th>作用</th></tr></thead><tbody><tr><td><code>--no-audit</code></td><td><strong>跳过 <code>npm audit</code> 安全检测</strong>。不扫描漏洞、不下载漏洞库，省 3-10 秒，也避免公司代理&#x2F;网络差时 audit 请求卡死。</td></tr><tr><td><code>--prefer-offline</code></td><td><strong>优先用本地缓存</strong>。只要机器里曾经下过某个包，就直接从 <code>~/.npm/_cacache</code> 拿，不再去网络校验，省流量、省时间，离线也能装。</td></tr></tbody></table></li></ul><h3 id="wsl无法解析镜像源"><a href="#wsl无法解析镜像源" class="headerlink" title="wsl无法解析镜像源"></a>wsl无法解析镜像源</h3><p>立刻锁掉 WSL 自动生成，防止重启被覆盖<br>wsl –shutdown<br>notepad “$env:USERPROFILE.wslconfig”<br>写入：<br>[network]<br>generateResolvConf &#x3D; false<br>保存后启动 WSL：<br>wsl</p><h1 id="尝试在WSL-Ubuntu-终端（项目根目录）里直接运行："><a href="#尝试在WSL-Ubuntu-终端（项目根目录）里直接运行：" class="headerlink" title="尝试在WSL Ubuntu 终端（项目根目录）里直接运行："></a>尝试在WSL Ubuntu 终端（项目根目录）里直接运行：</h1><h2 id="docker-compose-f-docker-docker-compose-base-yml-up-d"><a href="#docker-compose-f-docker-docker-compose-base-yml-up-d" class="headerlink" title="docker compose -f docker&#x2F;docker-compose-base.yml up -d\"></a>docker compose -f docker&#x2F;docker-compose-base.yml up -d\</h2><p><strong>按照指定的 YAML 文件，把一整套 Docker 容器在后台跑起来</strong></p><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><ul><li>source .venv&#x2F;bin&#x2F;activate</li><li>export PYTHONPATH&#x3D;$(pwd)</li><li>bash docker&#x2F;launch_backend_service.sh</li></ul><h1 id="bash-docker-launch-backend-service-sh-进入虚拟环境后其实只需执行这条命令"><a href="#bash-docker-launch-backend-service-sh-进入虚拟环境后其实只需执行这条命令" class="headerlink" title="bash docker&#x2F;launch_backend_service.sh     进入虚拟环境后其实只需执行这条命令"></a>bash docker&#x2F;launch_backend_service.sh     进入虚拟环境后其实只需执行这条命令</h1><p><em><strong>bash docker&#x2F;launch_backend_service.sh &#x3D; 运行项目提供的“一键起后端”脚本；大概率帮你 build + up 所有后端容器，并等它们就绪。</strong></em></p><h3 id="8-Killed-PY-api-ragflow-server-py-启动被杀进程"><a href="#8-Killed-PY-api-ragflow-server-py-启动被杀进程" class="headerlink" title="8 Killed  $PY api&#x2F;ragflow_server.py    启动被杀进程"></a>8 Killed  $PY api&#x2F;ragflow_server.py    启动被杀进程</h3><p> ✅ 解决方案（4G 机器可行的做法）</p><ol><li>降低 Elasticsearch 的 JVM Heap<br>在 docker-compose.yml（或者 launch_backend_service.sh 里对应的 compose 文件）里，给 ES 加上：</li></ol><p>  elasticsearch:<br>    environment:<br>      - discovery.type&#x3D;single-node<br>      - ES_JAVA_OPTS&#x3D;-Xms256m -Xmx512m</p><h2 id="开发完成后期RAGFlow-前端和支架服务："><a href="#开发完成后期RAGFlow-前端和支架服务：" class="headerlink" title="开发完成后期RAGFlow 前端和支架服务："></a>开发完成后期RAGFlow 前端和支架服务：</h2><p><code>pkill -f -9 &#39;ragflow_server.py|task_executor.py&#39;</code></p><h1 id="前端启动失败-tailwindcss-generate-failed-after-5-seconds-please-check-your-tailwind-css-and-tailwind-config-js"><a href="#前端启动失败-tailwindcss-generate-failed-after-5-seconds-please-check-your-tailwind-css-and-tailwind-config-js" class="headerlink" title="前端启动失败 tailwindcss generate failed after 5 seconds, please check your tailwind.css and tailwind.config.js"></a><strong>前端启动失败</strong> tailwindcss generate failed after 5 seconds, please check your tailwind.css and tailwind.config.js</h1><ul><li>方法 1：临时设置环境变量（只在当前命令有效）<br>在项目根目录下执行：<br>export CHECK_TIMEOUT&#x3D;20<br>npm run dev<br>export CHECK_TIMEOUT&#x3D;20：把超时时间设置为 20 秒。<br>npm run dev：启动你的开发服务器（或者 Tailwind 编译命令）。<br>这个方式只在当前终端有效，关闭终端就失效。</li></ul><p>-方法 2：在项目 .env 文件里永久生效<br>在项目根目录创建或编辑 .env 文件：<br>nano .env<br>在文件里添加：<br>CHECK_TIMEOUT&#x3D;20<br>保并退出（在 nano 里按 Ctrl+O → Enter → Ctrl+X）。<br>安装 dotenv（如果你的项目还没安装）：<br>npm install dotenv –save<br>在项目入口文件最上面添加：<br>require(‘dotenv’).config();<br>启动项目：<br>npm run dev<br>✅ 这样每次启动，CHECK_TIMEOUT 都是 20 秒，无需手动 export。</p><h2 id="前端启动-BABEL-Note-The-code-generator-has-deoptimised-the-styling-of-home-wzn-ragflow-web-src-assets-svg-login-avatars-svg-as-it-exceeds-the-max-of-500KB"><a href="#前端启动-BABEL-Note-The-code-generator-has-deoptimised-the-styling-of-home-wzn-ragflow-web-src-assets-svg-login-avatars-svg-as-it-exceeds-the-max-of-500KB" class="headerlink" title="前端启动[BABEL] Note: The code generator has deoptimised the styling of &#x2F;home&#x2F;wzn&#x2F;ragflow&#x2F;web&#x2F;src&#x2F;assets&#x2F;svg&#x2F;login-avatars.svg as it exceeds the max of 500KB."></a>前端启动[BABEL] Note: The code generator has deoptimised the styling of &#x2F;home&#x2F;wzn&#x2F;ragflow&#x2F;web&#x2F;src&#x2F;assets&#x2F;svg&#x2F;login-avatars.svg as it exceeds the max of 500KB.</h2><p>暂停使用jemalloc<br>看对话<a href="https://chatgpt.com/c/68f97eed-e79c-832d-8e20-c35600eb4483">https://chatgpt.com/c/68f97eed-e79c-832d-8e20-c35600eb4483</a></p><h3 id="✘-sandbox-executor-manager-Error-Get-“https-r…-15-4s"><a href="#✘-sandbox-executor-manager-Error-Get-“https-r…-15-4s" class="headerlink" title="✘ sandbox-executor-manager Error Get “https://r…                                15.4s"></a>✘ sandbox-executor-manager Error Get “<a href="https://r/">https://r</a>…                                15.4s</h3><!-- Error response from daemon: Get "https://registry-1.docker.io/v2/": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) --><h2 id="文档解析失败"><a href="#文档解析失败" class="headerlink" title="文档解析失败"></a>文档解析失败</h2><p>要分配内存给wsl，解释失败可能是OOM 杀死进程</p><p>改改成轻量模型 rag&#x2F;llm&#x2F;embedding_model.py<br>repo_id&#x3D;”BAAI&#x2F;bge-large-zh-v1.5”, -》repo_id&#x3D;”moka-ai&#x2F;m3e-small”,</p><h1 id="创建v0-20-5分支"><a href="#创建v0-20-5分支" class="headerlink" title="创建v0.20.5分支"></a><strong>创建v0.20.5分支</strong></h1><h2 id="创建分支前保存v0-20-4状态"><a href="#创建分支前保存v0-20-4状态" class="headerlink" title="创建分支前保存v0.20.4状态"></a>创建分支前保存v0.20.4状态</h2><p>先把0.20.4的修改文件放在（stash 区）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure><p>现在：    你分支：v0.20.4     文件状态：<code>干净（没有修改）</code>    改动：被存放在一个 stash 快照里</p><p>可以通过：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash list<br></code></pre></td></tr></table></figure><h3 id="🧩创建并切换到新分支-v0-20-5"><a href="#🧩创建并切换到新分支-v0-20-5" class="headerlink" title="🧩创建并切换到新分支 v0.20.5"></a>🧩创建并切换到新分支 v0.20.5</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b v0.20.5 v0.20.5<br></code></pre></td></tr></table></figure><p>你在 v0.20.5；<br>文件内容是 tag 对应的版本；<br>stash 区还在（跟分支无关，是全局的）。</p><h2 id="🧩-切回-v0-20-4"><a href="#🧩-切回-v0-20-4" class="headerlink" title="🧩 切回 v0.20.4"></a>🧩 切回 v0.20.4</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout v0.20.4<br></code></pre></td></tr></table></figure><p>结果是： 你的工作区依然干净；  你之前改过的文件不会自动恢复； 但你的 stash 还在！</p><h2 id="恢复原来的改动"><a href="#恢复原来的改动" class="headerlink" title="恢复原来的改动"></a>恢复原来的改动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash pop<br></code></pre></td></tr></table></figure><h2 id="1️⃣-获取-0-20-5-最新版本"><a href="#1️⃣-获取-0-20-5-最新版本" class="headerlink" title="1️⃣ 获取 0.20.5 最新版本"></a>1️⃣ 获取 0.20.5 最新版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch upstream --tags<br>git checkout -b upgrade-0.20.5 tags/v0.20.5<br><br>upgrade-0.20.5 是你新建的分支名字<br>基于官方 0.20.5 标签，不会破坏你本地 main 分支<br></code></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>宿主机<br>├─ 源码部署：代码裸奔，依赖自己装<br>└─ 容器部署：代码在镜像里，想看见就 exec 进去或挂出来</p><h3 id="容器查看内容"><a href="#容器查看内容" class="headerlink" title="容器查看内容"></a>容器查看内容</h3><p>查看 MySQL 数据（结构化部分）</p><ul><li>1.进入 MySQL 容器：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it ragflow-mysql mysql -u root -p<br></code></pre></td></tr></table></figure><ul><li>2.查看数据库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">SHOW DATABASES;<br>USE rag_flow;<br>SHOW TABLES;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>大模型框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大模型框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy</title>
    <link href="/2025/09/02/requests%E5%BA%93/"/>
    <url>/2025/09/02/requests%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests   <span class="hljs-comment">#加载requests模块</span><br>r = requests.get(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>) <span class="hljs-comment">#爬取url的网址信息</span><br><span class="hljs-built_in">print</span>(r.status_code)   <span class="hljs-comment">#查看状态200为正常，404为错误</span><br>r.headers                <span class="hljs-comment">#获得头部信息</span><br></code></pre></td></tr></table></figure><h2 id="response对象的属性"><a href="#response对象的属性" class="headerlink" title="response对象的属性"></a>response对象的属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>r.status_code</code></td><td>HTTP 请求的返回状态</td></tr><tr><td><code>r.text</code></td><td>HTTP 响应内容的字符串形式，即 URL 对应页面的文本内容</td></tr><tr><td><code>r.encoding</code></td><td>从 HTTP header 中推测的响应内容编码方式</td></tr><tr><td><code>r.apparent_encoding</code></td><td>从内容中分析出的响应内容编码方式（备选编码方式）</td></tr><tr><td><code>r.content</code></td><td>HTTP 响应内容的二进制形式</td></tr></tbody></table><h2 id="使用-re-模块匹配字符串"><a href="#使用-re-模块匹配字符串" class="headerlink" title="使用 re 模块匹配字符串"></a>使用 re 模块匹配字符串</h2><ul><li>使用 match() 方法进行匹配<br>  match() 方法用于从字符串的开始处进行匹配，如果在起始位置匹配成功，则返回 Match 对象，否则返回 None。其语法格式如下：(一旦当第一个字母不符合条件时，则不再进行匹配)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.<span class="hljs-keyword">match</span>(pattern, string, [flags])<br></code></pre></td></tr></table></figure><p><code>pattern：表示模式字符串，由要匹配的正则表达式转换而来。string：表示要匹配的字符串。</code></p><ul><li>使用 search() 方法进行匹配<br>  search() 方法用于在整个字符串中搜索第一个匹配的值，如果匹配成功，则返回 Match 对象，否则返回 None。search() 方法的语法格式如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.search(pattern, string, [flags])<br></code></pre></td></tr></table></figure><ul><li>使用 findall() 方法进行匹配<br>  在整个字符串中搜索所有符合正则表达式的字符串，并以列表的形式返回所有符合条件的结果。如果匹配不成功，返回空列表。findall() 方法的语法格式如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.findall(pattern, string, [flags])<br></code></pre></td></tr></table></figure><h2 id="使用-re-模块替换字符串"><a href="#使用-re-模块替换字符串" class="headerlink" title="使用 re 模块替换字符串"></a>使用 re 模块替换字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">re.sub(pattern, repl, string, count, flags)<br></code></pre></td></tr></table></figure><p><code>pattern：表示模式字符串，要被替换的。repl：用来替换的字符串。string：表示要被查找替换的原始字符串。count：可选参数，表示模式匹配后替换的最大次数，默认值为 0，表示替换所有的匹配。flags：可选参数，表示标志位，用于控制匹配方式，如是否区分字母大小写、是否包括换行等等。</code></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><code>“^” 表示行的开始，“$” 表示行的结尾</code></p><table><thead><tr><th>元字符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配除换行符以外的任意字符</td><td><code>a.c</code> 可匹配“acdin8Rit”中的 <code>a、c、d、8、R、it</code></td></tr><tr><td><code>\w</code></td><td>匹配字母、数字、下划线或汉字</td><td><code>\w</code> 可匹配“miO次9inqw”中的 <code>m、i、O、次、9、q、w</code>，不能匹配空格</td></tr><tr><td><code>\W</code></td><td>匹配除 <code>\w</code> 以外的字符</td><td><code>\W</code> 可匹配“92dinsc”中的 <code>in</code>，不能匹配 <code>9、2、d、s、c</code></td></tr><tr><td><code>\s</code></td><td>匹配单个空白符（包括 Tab 和换行）</td><td><code>\s</code> 可匹配“c\t8B”中的 <code>\t</code></td></tr><tr><td><code>\S</code></td><td>匹配除空白符以外的所有字符</td><td><code>\S</code> 可匹配“字we2it90”中的 <code>字、w、e、2、9、0</code></td></tr><tr><td><code>\b</code></td><td>匹配单词边界（开始或结束）</td><td>在“there were deserts where”中，<code>\bw</code> 匹配 <code>were</code> 的 <code>w</code>，不匹配 <code>where</code> 的 <code>w</code></td></tr><tr><td><code>\d</code></td><td>匹配数字</td><td><code>\d</code> 可匹配“dg34&amp;”中的 <code>3、4</code></td></tr></tbody></table><p>常用元字符<br>字符描述实例试一试<br>[]一组字符“[a-m]”<br>\示意特殊序列（也可用于转义特殊字符）“\d”<br>.任何字符（换行符除外）“he..o”<br>^起始于“^hello”<br>$结束于“world$”<br>*零次或多次出现“aix*”<br>+一次或多次出现“aix+”<br>{}确切地指定的出现次数“al{2}”<br><code></code>两者任一<code>&quot;fallsstays&quot;</code><br>特殊序列<br>字符描述实例<br>\A如果指定的字符位于字符串的开头，则返回匹配项“\AThe”<br>\b返回指定字符位于单词的开头或末尾的匹配项r”\bain”, r”ain\b”<br>\B返回指定字符存在的匹配项，但不在单词的开头（或结尾处）r”\Bain”, r”ain\B”<br>\d返回字符串包含数字的匹配项（数字 0-9）“\d”<br>\D返回字符串不包含数字的匹配项“\D”<br>\s返回字符串包含空白字符的匹配项“\s”<br>\S返回字符串不包含空白字符的匹配项“\S”<br>\w返回一个匹配项，其中字符串包含任何单词字符（a-z, A-Z, 0-9, _）“\w”<br>\W返回一个匹配项，其中字符串不包含任何单词字符“\W”<br>\Z如果指定的字符位于字符串的末尾，则返回匹配项“Spain\Z”<br>集合<br>表达式描述<br>[arn]返回一个匹配项，其中存在指定字符（a, r 或 n）之一<br>[a-n]返回字母顺序 a 和 n 之间的任意小写字符匹配项<br>[^arn]返回除 a、r 和 n 之外的任意字符的匹配项<br>[0123]返回存在任何指定数字（0、1、2 或 3）的匹配项<br>[0-9]返回 0 与 9 之间任意数字的匹配<br>[0-5][0-9]返回介于 0 到 9 之间的任何数字的匹配项<br>[a-zA-Z]返回字母顺序 a 和 z 之间的任何字符的匹配，小写或大写<br>[+]在集合中，+, *, ., <code>, (), $, &#123;&#125;没有特殊含义，因此[+]表示返回字符串中任何+</code> 字符的匹配项<br>正则函数<br>findall() 函数返回包含所有匹配项的列表。</p><p>search() 函数搜索字符串中的匹配项，如果存在匹配则返回 Match 对象。如果有多个匹配，则仅返回首个匹配项。</p><p>sub() 函数把匹配替换为您选择的文本。</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>study</title>
    <link href="/2025/08/21/study/"/>
    <url>/2025/08/21/study/</url>
    
    <content type="html"><![CDATA[<h1 id="RAGFLOW"><a href="#RAGFLOW" class="headerlink" title="RAGFLOW"></a>RAGFLOW</h1><h2 id="什么是RAGFLOW"><a href="#什么是RAGFLOW" class="headerlink" title="什么是RAGFLOW"></a>什么是RAGFLOW</h2><p><a href="https://ragflow.io/">RAGFlow</a> 是一个基于深度文档理解的开源 RAG（检索增强生成）引擎。它为任何规模的企业提供了简化的 RAG 工作流程，结合了 LLM（大型语言模型）提供真实的问答功能，并以来自各种复杂格式的有根据的引文为后盾。</p><p><strong>SDK</strong> 是 <strong>Software Development Kit</strong>（<strong>软件开发工具包</strong>）的缩写，中文通常称“开发工具包”，用于开发特定平台或软件应用的工具集合。</p><h3 id="Integrations"><a href="#Integrations" class="headerlink" title="Integrations"></a>Integrations</h3><blockquote><p><code>integrations</code> 目录中 RAGFlow 与 ChatGPT-on-WeChat 对接。</p></blockquote><h3 id="NLTK"><a href="#NLTK" class="headerlink" title="NLTK"></a>NLTK</h3><blockquote><p>NLTK 是 Natural Language Toolkit（自然语言处理工具包）</p></blockquote><ul><li><strong>文本分词</strong>（tokenization）</li><li><strong>词性标注</strong>（POS tagging）</li><li><strong>命名实体识别</strong>（NER）</li><li><strong>句法分析</strong>（parsing）</li></ul><h3 id="uv-lock-Python项目的依赖组件"><a href="#uv-lock-Python项目的依赖组件" class="headerlink" title="uv.lock Python项目的依赖组件"></a>uv.lock Python项目的依赖组件</h3><p><a href="https://zhuanlan.zhihu.com/p/1893299536002261393%20%20ragFlow">https://zhuanlan.zhihu.com/p/1893299536002261393 RAGFlow</a> 项目结构</p><p><strong>Werkzeug</strong>：Werkzeug 是一个纯 Python 编写的 WSGI 工具库，由 Flask 的核心开发者（Pallets 团队）维护。它的定位是：“HTTP 和 WSGI 的瑞士军刀”，提供构建 Web 框架&#x2F;服务器所需的各种底层功能，但本身不是一个完整的 Web 框架。</p><p>SIGINT：信息获取，SIGTERM：关闭。</p><p>WSGI：的全称是 <strong>Web Server Gateway Interface</strong>（Web 服务器网关接口）。一句话概括：<strong>它是 Python Web 应用（或框架）与 Web 服务器之间的“通用翻译官”</strong>。</p><p><strong>Node.js（简称 node）</strong> 是让你在浏览器之外也能运行 JavaScript 的“发动机”。运行 JavaScript 代码不用浏览器，直接在命令行。</p><p><strong>JavaScript</strong> 是让网页从“静态海报”变成“交互应用”的魔法语言，现在更是前后端通吃的万能胶水。</p><p><strong>构造函数</strong>：在 Python 中，构造函数的名字总是 <code>__init__</code>，是<strong>在创建对象时自动调用的特殊方法</strong>，用于初始化对象的状态（属性）。</p><p><code>dir()</code> 是 Python 的一个内置函数，作用是<strong>列出对象的属性和方法名称</strong>。</p><p><code>setattr</code> 是 Python 内置函数，用于<strong>给对象动态地设置属性值</strong>。<code>setattr(object, name, value)</code></p><p><code>__dict__</code>：实例属性，你创建一个类的实例后，实例的属性就会被存放在 <code>__dict__</code> 中。</p><p><strong>双下划线</strong>（dunder，double underscore）的函数，在 Python 里统称为**“魔术方法 &#x2F; 特殊方法”**。它们不让你直接调用，而是由 <strong>Python 解释器在特定场景下自动触发</strong>，用来定义对象的核心行为。</p><p><strong>三引号</strong>：就是“多行字符串”，至于拿来干什么，取决于它放在哪里。</p><ul><li><strong>当放在模块、类、函数或方法的第一行</strong> —— 它就是文档字符串（docstring），通过 <code>help(func)</code> 或 <code>func.__doc__</code> 能拿到这段说明。</li><li><strong>当放在赋值语句右边</strong> —— 它就是普通字符串，只是跨行写起来更方便。</li><li><strong>当放在代码里但既不赋值也不当 docstring</strong> —— 它就只是被忽略的字符串常量。</li></ul><hr><h2 id="JSON-处理"><a href="#JSON-处理" class="headerlink" title="JSON 处理"></a>JSON 处理</h2><p>✅ <code>json.dumps(obj)</code>：<strong>Python → JSON 字符串</strong><br>✅ <code>json.loads(json_str)</code>：<strong>JSON 字符串 → Python 对象（通常是字典）</strong>。</p><hr><h2 id="Python-命名约定"><a href="#Python-命名约定" class="headerlink" title="Python 命名约定"></a>Python 命名约定</h2><p>在 Python 中，变量名前加下划线（例如 <code>_param</code>）<strong>是一种约定，表示这是一个“内部变量”或“私有属性”</strong>。</p><p>Python 函数在调用时必须已经先定义在调用上方，函数内调用不分先后。</p><hr><h2 id="集合与生成器"><a href="#集合与生成器" class="headerlink" title="集合与生成器"></a>集合与生成器</h2><p>🟢 <code>set([])</code> 是什么意思？创建空集合。</p><p><code>yield</code> 是一个用于**生成器函数（generator function）**的关键字，可以让函数一次返回一个值，同时记住上次执行的位置。边执行边产出。“暂停一下，先给你一条消息，等你处理完了我再继续往下走。”</p><h3 id="🧠-yield-与-return-的区别"><a href="#🧠-yield-与-return-的区别" class="headerlink" title="🧠 yield 与 return 的区别"></a>🧠 yield 与 return 的区别</h3><table><thead><tr><th><strong>比较项</strong></th><th><strong>return</strong></th><th><strong>yield</strong></th></tr></thead><tbody><tr><td>函数类型</td><td>普通函数</td><td>生成器函数（返回生成器对象）</td></tr><tr><td>返回行为</td><td>一次性返回，函数结束</td><td>暂停函数，保留状态，下次继续</td></tr><tr><td>可多次输出？</td><td>否，一次</td><td>是，多次（使用 for 或 next()）</td></tr><tr><td>内存效率</td><td>不高（返回整个列表等）</td><td>高效（按需生成，每次一个值）</td></tr></tbody></table><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>✅ 一句话解释：<code>try-except-raise</code> 用于：</p><ul><li><strong>捕获异常</strong>（<code>try</code>）：可能出错的代码</li><li><strong>做出处理</strong>（<code>except</code>）：先处理一下，比如打印日志</li><li><strong>重新抛出异常</strong>（<code>raise</code>），让它传给外部或中止程序</li></ul><hr><h2 id="切片与装饰器"><a href="#切片与装饰器" class="headerlink" title="切片与装饰器"></a>切片与装饰器</h2><ul><li><code>[::-1]</code> 是 Python 的切片语法，用于反转序列：<ul><li>第一个 <code>:</code> 表示从开始到结束</li><li>第二个 <code>:</code> 后是步长（step），<code>-1</code> 表示从后向前遍历</li></ul></li></ul><p><code>@property</code> 装饰器将方法伪装成属性。用户像操作属性一样使用（无需显式调用方法）。</p><p><code>@</code> 是<strong>装饰器（Decorator）语法</strong>的标志，用于<strong>包装函数、方法或类</strong>，在不改变其原始定义的前提下，增强或修改其行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">pass</span><br>等价于：<br><br>python<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">pass</span><br>func = decorator(func)<br></code></pre></td></tr></table></figure><p>装饰器（Decorator）就是一个“包装函数”，在不修改原函数代码的前提下，给它加功能。</p><p>✅ 举个生活例子：<br>你点了一杯奶茶，店员在封口前又给你加了层奶盖 —— 这就是“装饰”：奶茶（原函数）没变，但多了奶盖（新功能）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">login_required</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> session.get(<span class="hljs-string">&#x27;username&#x27;</span>):<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)  <span class="hljs-comment"># 用户已登录，正常执行原函数</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;请先登录！&#x27;</span>  <span class="hljs-comment"># 未登录，拦截请求</span><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/profile&#x27;</span></span>)</span><br><span class="hljs-meta">@login_required  </span><span class="hljs-comment"># 👈 装饰器：给 /profile 加“登录检查”功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">profile</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;个人中心页面&#x27;</span><br></code></pre></td></tr></table></figure><p>req &#x3D; request.json 是 Flask 中获取请求体中的 JSON 数据的一种方式。</p><p>nonlocal 是 Python 中的一个关键字，用于在嵌套函数中声明一个变量不是局部变量，而是来自外层（非全局）作用域的变量。</p><p>后端路由定位<br>根据 URL 定位后端路由：</p><p>框架搜索关键词示例路由定义示例<br>Spring Boot@PostMapping(“&#x2F;v1&#x2F;chunk&#x2F;list”) 或 @RequestMapping@PostMapping(“&#x2F;v1&#x2F;chunk&#x2F;list”)<br>数据库索引<br>KEY devparamtemplate_create_time (create_time)：这些语句是给表里的字段加普通索引（KEY），作用是为了提高查询速度，但不会限制字段值唯一。</p><p>类型作用是否防重复<br>KEY 或 INDEX提升查询性能❌ 不限制重复<br>UNIQUE KEY防重复值 + 提升查询性能✅ 限制重复<br>ORM 模型示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DevParamTemplate</span>(<span class="hljs-title class_ inherited__">DataBaseModel</span>):<br>    <span class="hljs-built_in">id</span> = CharField(max_length=<span class="hljs-number">32</span>, primary_key=<span class="hljs-literal">True</span>)<br>    name = CharField(max_length=<span class="hljs-number">100</span>, null=<span class="hljs-literal">False</span>, help_text=<span class="hljs-string">&quot;模板名称&quot;</span>, index=<span class="hljs-literal">True</span>)<br>    agent_id = CharField(max_length=<span class="hljs-number">64</span>, null=<span class="hljs-literal">True</span>, help_text=<span class="hljs-string">&quot;关联的agentID&quot;</span>, index=<span class="hljs-literal">True</span>)<br>    auth = CharField(max_length=<span class="hljs-number">255</span>, null=<span class="hljs-literal">True</span>, help_text=<span class="hljs-string">&quot;授权信息&quot;</span>)<br>    template = TextField(null=<span class="hljs-literal">True</span>, help_text=<span class="hljs-string">&quot;参数模板内容&quot;</span>, default=<span class="hljs-built_in">list</span>)<br>    status = CharField(max_length=<span class="hljs-number">1</span>, null=<span class="hljs-literal">True</span>, default=<span class="hljs-string">&quot;1&quot;</span>, help_text=<span class="hljs-string">&quot;状态 1是开启 0是关闭&quot;</span>, index=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>        db_table = <span class="hljs-string">&quot;dev_param_template&quot;</span><br></code></pre></td></tr></table></figure><p>Index&#x3D;True 表示为这个字段创建普通索引（提高查询速度，但不会防止重复值）。</p><p>场景HTTP 状态码业务返回码（示例）<br>请求成功200code&#x3D;0<br>参数错误400code&#x3D;100<br>权限不足200（或 403）code&#x3D;401<br>服务器异常500code&#x3D;500</p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>Controller（控制器）层</p><ul><li>像前台接待员：只负责“收快递”（接收 HTTP 请求参数）把快递交给后台仓库（Service 层）再把仓库返回的结果打包发回给客人（返回 JSON 给前端）<br><code>一句话：不处理业务逻辑，只做“收、转、返”。</code><br>Service（业务）层</li><li>像后台仓库：真正拆包裹、检查货物（参数校验、业务规则）决定能不能入库（判断名称是否重复）把最终入库单交给工人（DAO &#x2F; ORM）去落库<br><code>一句话：所有“能不能做、该怎么做”的判断都在这里。</code></li></ul><h2 id="MVC-分层结构"><a href="#MVC-分层结构" class="headerlink" title="MVC &#x2F; 分层结构"></a>MVC &#x2F; 分层结构</h2><p>就是把代码按职责切成三层（或更多层）：</p><ul><li>M Model（数据模型，对应数据库表）</li><li>V View（前端页面 &#x2F; JSON 视图）</li><li>C Controller（上面说的前台接待员）</li><li>S Service（后台仓库）<br>好处：各层互不干扰，代码好维护、好测试、好复用。</li></ul><p>Jenkins 与 CI&#x2F;CD<br>Jenkins 是一个开源的、提供友好操作界面的持续集成（CI）工具，起源于 Hudson，主要用于持续、自动的构建&#x2F;测试软件项目。</p><h3 id="CI-CD-是什么？"><a href="#CI-CD-是什么？" class="headerlink" title="CI&#x2F;CD 是什么？"></a>CI&#x2F;CD 是什么？</h3><ul><li>CI（Continuous Integration，持续集成）：一种软件开发实践。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。</li><li>CD（Continuous Delivery，持续交付）：是在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境（类生产环境）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境。</li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>功能说明<br>接收浏览器请求别人输入网址，Tomcat 听见“有人敲门”<br>把你的代码跑起来它帮你把 Java 代码变成网页，回给浏览器<br>管理“网站生命”网站启动、关闭、重启，都由 Tomcat 管</p><h3 id="npm-命令"><a href="#npm-命令" class="headerlink" title="npm 命令"></a>npm 命令</h3><p>npm run build &#x3D; 把“开发时的源代码”变成“用户真正看到的网页”，就像把厨房半成品变成端上桌的硬菜。<br>npm run dev &#x3D; 开发专用“实时预览 + 调试”模式，菜还没正式上桌，但厨师可以随时尝咸淡。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>🧠 基本概念<br>概念含义<br>线程池（ThreadPool）提前准备好的几个“工作线程”<br>任务（Task）你要执行的函数，比如 get_data()<br>Future表示“将来”会返回结果的对象，你可以等待它完成<br>submit()提交一个任务给线程池<br>map()批量处理多个任务，像 map() 函数一样<br>with … as自动关闭线程池资源的推荐写法<br>🧪 示例代码（带中文注释）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<br></code></pre></td></tr></table></figure><h3 id="假设这是你要并行执行的函数"><a href="#假设这是你要并行执行的函数" class="headerlink" title="假设这是你要并行执行的函数"></a>假设这是你要并行执行的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_data</span>(<span class="hljs-params">name, wait=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;name&#125;</span>] 开始执行任务，预计耗时 <span class="hljs-subst">&#123;wait&#125;</span> 秒&quot;</span>)<br>    time.sleep(wait)  <span class="hljs-comment"># 模拟 I/O 操作（比如请求网页）</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[<span class="hljs-subst">&#123;name&#125;</span>] 完成任务&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> 的数据&quot;</span><br></code></pre></td></tr></table></figure><h3 id="主程序开始"><a href="#主程序开始" class="headerlink" title="主程序开始"></a>主程序开始</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 创建一个线程池，最多同时执行 3 个任务</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> executor:<br>        <span class="hljs-comment"># 提交多个任务给线程池执行</span><br>        futures = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>            <span class="hljs-comment"># submit(函数, 参数1, 参数2, ...)</span><br>            future = executor.submit(fetch_data, <span class="hljs-string">f&quot;任务<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>&quot;</span>, wait=i % <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)<br>            futures.append(future)<br><br>        <span class="hljs-comment"># 等待所有任务完成（异步）</span><br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(futures):<br>            result = future.result()  <span class="hljs-comment"># 获取返回值（阻塞直到完成）</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[主程序] 收到结果：<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>🧠 学习小笔记（建议记下来）<br>✅ ThreadPoolExecutor(max_workers&#x3D;N)N 是最多同时运行几个任务（线程数）<br>✅ submit(func, *args)异步执行函数，立即返回 Future<br>✅ as_completed(futures)按任务完成顺序返回结果<br>✅ .result()获取函数运行完后的返回值<br>❗ 适合 I&#x2F;O 密集型任务比如网络请求、数据库查询、文件操作<br>❌ 不适合 CPU 密集型如训练模型、数学计算 → 请用多进程</p><h2 id="模块与脚本"><a href="#模块与脚本" class="headerlink" title="模块与脚本"></a>模块与脚本</h2><p>✅ 模块（module）和脚本（script）的区别<br>特性模块（Module）脚本（Script）<br>定义一个可以被导入和复用的 Python 文件一个可以直接运行的 Python 文件<br>用途提供功能、函数、类供其他代码调用执行某个特定任务或程序流程<br>入口点没有主入口，供其他文件使用通常有 if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘<br>导入方式import mymodule不能被别的脚本导入（如果它只是用来执行）<br>重复使用性高，可复用通常低，更专注执行任务<br>举例math.py, utils.py（定义函数供别人用）<br>Peewee ORM 示例<br>模型转字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseModel</span>(<span class="hljs-title class_ inherited__">Model</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_dict</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__dict__[<span class="hljs-string">&#x27;__data__&#x27;</span>]  <span class="hljs-comment"># 直接访问对象内部字典属性</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">to_human_model_dict</span>(<span class="hljs-params">self, only_primary_with: <span class="hljs-built_in">list</span> = <span class="hljs-literal">None</span></span>):<br>        model_dict = <span class="hljs-variable language_">self</span>.__dict__[<span class="hljs-string">&#x27;__data__&#x27;</span>]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> only_primary_with:<br>            <span class="hljs-keyword">return</span> &#123;remove_field_name_prefix(k): v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> model_dict.items()&#125;<br>        human_model_dict = &#123;&#125;<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._meta.primary_key.field_names:<br>            human_model_dict[remove_field_name_prefix(k)] = model_dict[k]<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> only_primary_with:<br>            human_model_dict[k] = model_dict[<span class="hljs-string">f&#x27;f_<span class="hljs-subst">&#123;k&#125;</span>&#x27;</span>]<br>        <span class="hljs-keyword">return</span> human_model_dict<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">meta</span>(<span class="hljs-params">self</span>) -&gt; Metadata:<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._meta<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_primary_keys_name</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-keyword">return</span> cls._meta.primary_key.field_names <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(cls._meta.primary_key, CompositeKey) <span class="hljs-keyword">else</span> [cls._meta.primary_key.name]<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getter_by</span>(<span class="hljs-params">cls, attr</span>):<br>        <span class="hljs-keyword">return</span> operator.attrgetter(attr)(cls)<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">cls, reverse=<span class="hljs-literal">None</span>, order_by=<span class="hljs-literal">None</span>, **kwargs</span>):<br>        filters = []<br>        <span class="hljs-keyword">for</span> f_n, f_v <span class="hljs-keyword">in</span> kwargs.items():<br>            attr_name = <span class="hljs-string">&#x27;%s&#x27;</span> % f_n<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, attr_name) <span class="hljs-keyword">or</span> f_v <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(f_v) <span class="hljs-keyword">in</span> &#123;<span class="hljs-built_in">list</span>, <span class="hljs-built_in">set</span>&#125;:<br>                f_v = <span class="hljs-built_in">list</span>(f_v)<br>                <span class="hljs-keyword">if</span> is_continuous_field(<span class="hljs-built_in">type</span>(<span class="hljs-built_in">getattr</span>(cls, attr_name))):<br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(f_v) == <span class="hljs-number">2</span>:<br>                        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(f_v):<br>                            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(v, <span class="hljs-built_in">str</span>) <span class="hljs-keyword">and</span> f_n <span class="hljs-keyword">in</span> auto_date_timestamp_field():<br>                                f_v[i] = utils.date_string_to_timestamp(v)<br>                        lt_value = f_v[<span class="hljs-number">0</span>]<br>                        gt_value = f_v[<span class="hljs-number">1</span>]<br>                        <span class="hljs-keyword">if</span> lt_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> gt_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                            filters.append(cls.getter_by(attr_name).between(lt_value, gt_value))<br>                        <span class="hljs-keyword">elif</span> lt_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                            filters.append(operator.attrgetter(attr_name)(cls) &gt;= lt_value)<br>                        <span class="hljs-keyword">elif</span> gt_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                            filters.append(operator.attrgetter(attr_name)(cls) &lt;= gt_value)<br>                <span class="hljs-keyword">else</span>:<br>                    filters.append(operator.attrgetter(attr_name)(cls) &lt;&lt; f_v)<br>            <span class="hljs-keyword">else</span>:<br>                filters.append(operator.attrgetter(attr_name)(cls) == f_v)<br>        <span class="hljs-keyword">if</span> filters:<br>            query_records = cls.select().where(*filters)<br>            <span class="hljs-keyword">if</span> reverse <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> order_by <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;order_by&#125;</span>&quot;</span>):<br>                    order_by = <span class="hljs-string">&quot;create_time&quot;</span><br>                <span class="hljs-keyword">if</span> reverse <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>                    query_records = query_records.order_by(cls.getter_by(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;order_by&#125;</span>&quot;</span>).desc())<br>                <span class="hljs-keyword">elif</span> reverse <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                    query_records = query_records.order_by(cls.getter_by(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;order_by&#125;</span>&quot;</span>).asc())<br>            <span class="hljs-keyword">return</span> [query_record <span class="hljs-keyword">for</span> query_record <span class="hljs-keyword">in</span> query_records]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h2 id="Peewee-基础"><a href="#Peewee-基础" class="headerlink" title="Peewee 基础"></a>Peewee 基础</h2><ul><li>Peewee 是一个轻量级的 ORM（对象关系映射）框架，ORM 的核心思想就是用 Python 类来表示数据库表。在定义模型类时，Meta 就是 Peewee 提供的一种机制，告诉 ORM 框架这个类在数据库中应该怎么表现。</li></ul><p>过滤器<br>.startswith(prefix)：搜索以前缀开头的值</p><p>.endswith(suffix)：搜索以后缀结尾的值</p><p>.regexp(exp)：正则表达式匹配（区分大小写）</p><p>.iregexp(exp)：正则表达式匹配（不区分大小写）</p><p>.cast(type)：将列的值转换为给定类型</p><p>Utils 工具目录<br>在一个项目里，utils（utilities） 文件或目录并不是官方规范，而是约定俗成的“工具箱”。它的核心定位是：放置那些与业务逻辑解耦、可在多处复用、与框架&#x2F;库无关的通用代码。</p><h2 id="logger"><a href="#logger" class="headerlink" title="&#x2F;logger&#x2F;"></a>&#x2F;<em>logger</em>&#x2F;</h2><p><code>只有当「Logger 设置的级别」≤「日志级别」时，才会输出。</code></p><table><thead><tr><th>Logger 设置的级别</th><th>会打印的级别</th><th>不会打印的级别</th></tr></thead><tbody><tr><td>DEBUG</td><td>DEBUG、INFO、WARNING、ERROR、CRITICAL</td><td>无</td></tr><tr><td>INFO</td><td>INFO、WARNING、ERROR、CRITICAL</td><td>DEBUG</td></tr><tr><td>WARNING</td><td>WARNING、ERROR、CRITICAL</td><td>DEBUG、INFO</td></tr><tr><td>ERROR</td><td>ERROR、CRITICAL</td><td>DEBUG、INFO、WARNING</td></tr><tr><td>CRITICAL</td><td>CRITICAL</td><td>DEBUG、INFO、WARNING、ERROR</td></tr></tbody></table><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>&#x2F;<em>Python 解释器（python.exe）和第三方包（site-packages）理解成“两个独立文件夹”：</em>&#x2F;</p><ul><li>解释器：只负责把 .py 文件翻译成机器指令并执行。</li><li>第三方包：被 pip install 下来的库（requests、torch、ragflow 依赖等）默认放在<br>…Python310\Lib\site-packages<br><code>解释器启动时，会把 当前虚拟环境的 site-packages 加到 sys.path，于是就能 import 到它们。</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成器</title>
    <link href="/2025/08/13/%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2025/08/13/%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="生成器函数和生成器对象的区别"><a href="#生成器函数和生成器对象的区别" class="headerlink" title="生成器函数和生成器对象的区别"></a>生成器函数和生成器对象的区别</h2><p>生成器函数被调用时，并不会立即执行函数体，而是返回一个生成器对象。只有在<strong>迭代生成器对象</strong>时，代码才会一步步执行。</p><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator started&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yielded 1, continue...&quot;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yielded 2, finish&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling gen()...&quot;</span>)<br>g = gen()  <span class="hljs-comment"># 创建生成器对象，不执行函数体</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator object created:&quot;</span>, g)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g)...&quot;</span>)<br>val1 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行到第一个 yield</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received:&quot;</span>, val1)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g) again...&quot;</span>)<br>val2 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行到第二个 yield</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Received:&quot;</span>, val2)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Calling next(g) final time...&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    val3 = <span class="hljs-built_in">next</span>(g)  <span class="hljs-comment"># 执行剩余代码，结束</span><br><span class="hljs-keyword">except</span> StopIteration:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Generator exhausted&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done.&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行结果<br>Calling gen()…<br>Generator object created: &lt;generator object gen at 0x…&gt;<br>Calling next(g)…<br>Generator started<br>Received: 1<br>Calling next(g) again…<br>Yielded 1, continue…<br>Received: 2<br>Calling next(g) final time…<br>Yielded 2, finish<br>Generator exhausted<br>Done.</p><p>术语解释<br>迭代器驱动<br>迭代器不会自己执行，需要外部调用 next() 或使用 for 循环来“驱动”它。</p><p>每次调用 next()，代码会从上一次 yield 后的位置继续运行，直到遇到下一个 yield 或结束。</p><p>next()<br>Python 内置函数，等价于调用迭代器的 <strong>next</strong>() 方法。</p><p>功能：运行生成器到下一个 yield，返回其后的值。</p><p>当没有更多值时，会抛出 StopIteration 异常。</p><p>callable(obj)<br>Python 内置函数，用于判断对象 obj 是否可调用。</p><p>可调用对象包括：函数、方法，或者实现了 <strong>call</strong>() 方法的类实例。</p><p>callable(res) 的应用场景<br>在某些代码（如 res &#x3D; self._run()）中：<br>场景res 类型callable(res)处理方式<br>普通组件字符串、字典、DataFrame…False直接记录耗时<br>流式组件生成器函数、functools.partialTrue再调用一次获取生成器，开始迭代</p><p>为什么不能立即记录耗时？<br>如果 res 是生成器函数，还没开始迭代就记录结束时间，会导致耗时被严重低估，无法反映真实执行时间。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><img src="/./%E5%A3%81%E7%BA%B8.jpg" alt="壁纸"></p><img src="/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E5%A3%81%E7%BA%B8.jpg" class="">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/01/hello-world/"/>
    <url>/2025/08/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>bs4</title>
    <link href="/2025/08/01/bs4/"/>
    <url>/2025/08/01/bs4/</url>
    
    <content type="html"><![CDATA[<p><em><strong>爬虫</strong></em>*</p><ul><li>发送 HTTP 请求：爬虫通过 HTTP 请求从目标网站获取 HTML 页面，常用的库包括 requests。</li><li>解析 HTML 内容：获取 HTML 页面后，爬虫需要解析内容并提取数据，常用的库有 BeautifulSoup、lxml、Scrapy 等。</li><li>提取数据：通过定位 HTML 元素（如标签、属性、类名等）来提取所需的数据。</li><li>存储数据：将提取的数据存储到数据库、CSV 文件、JSON 文件等格式中，以便后续使用或分析。</li></ul><p><code>页面里的一个标签，就是一个元素。</code></p><table><thead><tr><th>你在 HTML 里写的</th><th>浏览器里的称呼</th><th>举例</th></tr></thead><tbody><tr><td><code>&lt;div&gt;</code></td><td>div 元素</td><td>一个容器块</td></tr><tr><td><code>&lt;img src=&quot;…&quot;&gt;</code></td><td>img 元素</td><td>一张图片</td></tr><tr><td><code>&lt;button&gt;</code></td><td>button 元素</td><td>按钮</td></tr><tr><td><code>&lt;a href=&quot;…&quot;&gt;</code></td><td>a 元素</td><td>超链接</td></tr><tr><td><code>&lt;span&gt;</code></td><td>span 元素</td><td>行内文本</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>    <span class="hljs-comment"># 读取示例 HTML 文件</span><br>html = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;html&gt;</span><br><span class="hljs-string">    &lt;head&gt;</span><br><span class="hljs-string">        &lt;title&gt;Example Page&lt;/title&gt;</span><br><span class="hljs-string">    &lt;/head&gt;</span><br><span class="hljs-string">    &lt;body&gt;</span><br><span class="hljs-string">        &lt;h1&gt;Hello, World!&lt;/h1&gt;</span><br><span class="hljs-string">    &lt;/body&gt;</span><br><span class="hljs-string">&lt;/html&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 创建 BeautifulSoup 对象，并指定解析器为 lxml</span><br>soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>    <span class="hljs-comment"># 找到第一个 h1 标签，并输出其文本内容</span><br>h1 = soup.find(<span class="hljs-string">&#x27;h1&#x27;</span>)<br><span class="hljs-built_in">print</span>(h1.text)<br></code></pre></td></tr></table></figure><h3 id="可以使用-BeautifulSoup-对象-soup-来提取其中的数据。例如，要获取文档标题，可以使用-title-属性"><a href="#可以使用-BeautifulSoup-对象-soup-来提取其中的数据。例如，要获取文档标题，可以使用-title-属性" class="headerlink" title="可以使用 BeautifulSoup 对象 soup 来提取其中的数据。例如，要获取文档标题，可以使用 title 属性"></a>可以使用 BeautifulSoup 对象 soup 来提取其中的数据。例如，要获取文档标题，可以使用 title 属性</h3><p>print(soup.title)<br>    # <title>Example Page</title>   </p><h3 id="要获取标签的文本内容，可以使用-text-属性或-string-属性："><a href="#要获取标签的文本内容，可以使用-text-属性或-string-属性：" class="headerlink" title="要获取标签的文本内容，可以使用 text 属性或 string 属性："></a>要获取标签的文本内容，可以使用 text 属性或 string 属性：</h3><p>print(soup.h1.text)</p><h3 id="要获取标签的属性，可以使用-attrs-属性："><a href="#要获取标签的属性，可以使用-attrs-属性：" class="headerlink" title="要获取标签的属性，可以使用 attrs 属性："></a>要获取标签的属性，可以使用 attrs 属性：</h3><p>1.Tag(标签)<br>print(soup.a.attrs[‘href’])<br>(1)每个tag都有自己的名字，通过.name来获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;a&gt;recall&lt;/a&gt;&#x27;</span>, features=<span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.a)<br><span class="hljs-comment">#&lt;a&gt;liyuhong&lt;/a&gt;</span><br><span class="hljs-built_in">print</span>(soup.a.name)<br><span class="hljs-comment">#a</span><br></code></pre></td></tr></table></figure><p>(2)一个tag可能有多个属性，操作与字典相同，通过.attrs来获取。</p><p>2.NavigableString(标签的值)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;a class=&quot;celebrity liyuhong&quot;&gt;li&lt;/a&gt;&#x27;</span>, features=<span class="hljs-string">&#x27;lxml&#x27;</span>)<br><span class="hljs-built_in">print</span>(soup.a.string)<br><span class="hljs-comment">#li</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(soup.a.string))<br><span class="hljs-comment">#&lt;class &#x27;bs4.element.NavigableString&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h3 id="要获取所有符合条件的标签，可以使用-find-all-方法："><a href="#要获取所有符合条件的标签，可以使用-find-all-方法：" class="headerlink" title="要获取所有符合条件的标签，可以使用 find_all 方法："></a>要获取所有符合条件的标签，可以使用 find_all 方法：</h3><h1 id="获取所有-p-标签"><a href="#获取所有-p-标签" class="headerlink" title="获取所有 p 标签"></a>获取所有 p 标签</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">ps = soup.find_all(<span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps:<br>    <span class="hljs-built_in">print</span>(p.text)<br>    <span class="hljs-comment">#    This is the first paragraph.</span><br>    <span class="hljs-comment"># This is the second paragraph.</span><br>    <span class="hljs-comment"># 获取 class 为 &quot;second&quot; 的 p 标签</span><br>    p = soup.find(<span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;second&#x27;</span>&#125;)<br><span class="hljs-built_in">print</span>(p.text)<br>    <span class="hljs-comment"># This is the second paragraph.</span><br></code></pre></td></tr></table></figure><h3 id="BeautifulSoup-支持使用-CSS-选择器来查找标签，可以使用-select-方法"><a href="#BeautifulSoup-支持使用-CSS-选择器来查找标签，可以使用-select-方法" class="headerlink" title="BeautifulSoup 支持使用 CSS 选择器来查找标签，可以使用 select 方法"></a>BeautifulSoup 支持使用 CSS 选择器来查找标签，可以使用 select 方法</h3><p><code>返回列表。类似CSS写法来筛选元素，标签名不加任何修饰，类名加点，id名加#</code></p><ol><li>通过标签名查找</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">soup.select(<span class="hljs-string">&#x27;a&#x27;</span>)<br>soup.select(<span class="hljs-string">&#x27;a, span&#x27;</span>) <span class="hljs-comment"># 注意引号的位置</span><br></code></pre></td></tr></table></figure><p>2.通过类名查找<br>soup.select(‘.class’)</p><p>3.通过id名查找<br>soup.select(‘#id’)</p><ol start="4"><li>通过子标签查找</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pthon"># 直接子元素(必须相邻)<br>soup.select(&#x27;body &gt; div &gt;a&#x27;)<br># 间接子元素(不需相邻)<br>soup.select(&#x27;body a&#x27;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy</title>
    <link href="/2025/08/01/Scrapy/"/>
    <url>/2025/08/01/Scrapy/</url>
    
    <content type="html"><![CDATA[<h2 id="scrapy简介"><a href="#scrapy简介" class="headerlink" title="scrapy简介"></a>scrapy简介</h2><ul><li>Engine：引擎，处理整个系统的数据流和事件，是整个框架的核心，</li><li>Item： 它是一个抽象的数据结构，它定义了爬取结果的数据结构，爬取的数据会被赋值成 Item 对象。每个 Item 就是一个类，类里面定义了爬取结果的数据字段</li><li>Scheduler： 调度器，它用来接受 Engine 发过来的 Request 并将其加入队列中，同时也可以将 Request 发回给 Engine 供 Downloader 执行，它主要维护 Request 的调度逻辑，比如先进先出、先进后出、优先级进出等等。</li><li>Spiders： 每个 Spider 里面定义了站点的爬取逻辑和页面的解析规则，它主要负责解析响应并生成 Item 和新的请求然后发给 Engine 进行处理。</li><li>Downloader： 下载器，即完成 向服务器发送请求，然后拿到响应 的过程，得到的响应会再发送给 Engine 处理。</li><li>Item Pipelines： 项目管道，这也是一个复数统称，可以对应多个 Item Pipeline。Item Pipeline 主要负责处理由 Spider 从页面中抽取的 Item，做一些数据清洗、验证和存储等工作，比如将 Item 的某些字段进行规整，将 Item 存储到数据库等操作都可以由 Item Pipeline 来完成。</li><li>Downloader Middlewares： 图中 Engine 和 Downloader 之间的方块部分，中文可以称为下载器中间件，同样也是复数统称，其包含多个 Downloader Middleware，它是位于 Engine 和 Downloader 之间的 Hook 框架，负责实现 Downloader 和 Engine 之间的请求和响应的处理过程。</li><li>Spider Middlewares： 图中 Engine 和 Spiders 之间的方块部分，中文可以称为蜘蛛中间件，它是位于 Engine 和 Spiders 之间的 Hook 框架，负责实现 Spiders 和 Engine 之间的 Item，请求和响应的处理过程</li></ul><h2 id="项目运行过程"><a href="#项目运行过程" class="headerlink" title="项目运行过程"></a>项目运行过程</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><code>scrapy startproject tutorial</code><br>这将创建一个名为 tutorial 的目录，其内容如下<br>tutorial&#x2F;<br>    scrapy.cfg            # deploy configuration file</p><pre><code class="hljs">tutorial/             # project&#39;s Python module, you&#39;ll import your code from here    __init__.py    items.py          # project items definition file    middlewares.py    # project middlewares file    pipelines.py      # project pipelines file    settings.py       # project settings file    spiders/          # a directory where you&#39;ll later put your spiders        __init__.py</code></pre><h3 id="我们的第一个-Spider"><a href="#我们的第一个-Spider" class="headerlink" title="我们的第一个 Spider"></a>我们的第一个 Spider</h3><p>Spider 是您定义的类，Scrapy 使用它们从网站（或一组网站）抓取信息。它们必须继承自Spider，并定义初始请求，以及（可选地）如何跟踪页面中的链接和解析下载的页面内容以提取数据。</p><p>这是我们第一个 Spider 的代码。将其保存在项目目录 tutorial&#x2F;spiders 下名为 quotes_spider.py 的文件中</p><p><code>scrapy genspider sina news.sina.com.cn</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuotesSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;quotes&quot;</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        urls = [<br>            <span class="hljs-string">&quot;https://quotes.toscrape.com/page/1/&quot;</span>,<br>            <span class="hljs-string">&quot;https://quotes.toscrape.com/page/2/&quot;</span>,<br>        ]<br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls:<br>            <span class="hljs-keyword">yield</span> scrapy.Request(url=url, callback=<span class="hljs-variable language_">self</span>.parse)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        page = response.url.split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">2</span>]<br>        filename = <span class="hljs-string">f&quot;quotes-<span class="hljs-subst">&#123;page&#125;</span>.html&quot;</span><br>        Path(filename).write_bytes(response.body)<br>        <span class="hljs-variable language_">self</span>.log(<span class="hljs-string">f&quot;Saved file <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>name：用于标识 Spider。它在项目内必须是唯一的，也就是说，您不能为不同的 Spider 设置相同的名称。<br>start()：必须是一个异步生成器，用于产生供 spider 开始抓取的请求（以及可选的 item）。后续请求将从这些初始请求中连续生成。<br>parse()：一个将被调用的方法，用于处理每个请求下载的响应。response 参数是TextResponse 的一个实例，它包含页面内容并具有其他有用的方法来处理它。</p><h3 id="如何运行我们的-spider"><a href="#如何运行我们的-spider" class="headerlink" title="如何运行我们的 spider"></a>如何运行我们的 spider</h3><p>要运行我们的 spider，请进入项目的顶层目录并运行<br><code>scrapy crawl quotes</code></p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bs4</title>
    <link href="/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/FastApi/"/>
    <url>/2025/08/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/FastApi/</url>
    
    <content type="html"><![CDATA[<h1 id="FastAPI"><a href="#FastAPI" class="headerlink" title="FastAPI"></a>FastAPI</h1><p><code>FastAPI 是一个用 Python 写 RESTful API 的“现代化、飞快的框架”，帮你几行代码就搭好一个高性能的 Web 接口。</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br>app = FastAPI()<br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">root</span>():<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h1 id="并发-async-await"><a href="#并发-async-await" class="headerlink" title="并发 async &#x2F; await"></a>并发 async &#x2F; await</h1><ul><li>如果你正在使用第三方库，它们会告诉你使用 await 关键字来调用它们，就像这样：<br><code>results = await some_library()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_results</span>():<br>    results = <span class="hljs-keyword">await</span> some_library()<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><p><strong>你只能在被 async def 创建的函数内使用 await</strong></p>]]></content>
    
    
    <categories>
      
      <category>Python框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Playwright</title>
    <link href="/2025/08/01/playwright/"/>
    <url>/2025/08/01/playwright/</url>
    
    <content type="html"><![CDATA[<h1 id="Playwright"><a href="#Playwright" class="headerlink" title="Playwright"></a>Playwright</h1><p>*** 框架对比***</p><table><thead><tr><th>需求维度</th><th>推荐工具</th></tr></thead><tbody><tr><td>纯静态&#x2F;海量列表</td><td>Scrapy</td></tr><tr><td>少量动态页面</td><td>Playwright 直接脚本</td></tr><tr><td>大规模+少量 JS</td><td>Scrapy + scrapy-playwright</td></tr><tr><td>复杂人机交互</td><td>Playwright&#x2F;Selenium</td></tr><tr><td>必须 IE 兼容</td><td>Selenium</td></tr></tbody></table><ul><li>两者如何混合——“Scrapy 管调度，Playwright 管渲染”<br>• scrapy-playwright：官方插件，把 Playwright 作为 Scrapy 的下载器。</li><li>优点：<br>– 继续享受 Scrapy 的调度&#x2F;去重&#x2F;管道；<br>– 只有真正需要 JS 的请求才走 Playwright，其他仍走高速 HTTP。</li></ul><p><code>Playwright = 一个可以“自动化任何现代浏览器”（Chromium、Firefox、WebKit）的跨语言库，用它写出来的脚本能像真人一样打开网页、点击、输入、滚动、截图、下文件、抓接口、跑单测、生成 PDF/视频——速度快、稳定性高、反爬绕过能力强。</code></p><p>1️⃣ <code>inner_text</code>基本用法: 获取某个元素「可见文本」的API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ptthon">text = await page.inner_text(selector) #selector：CSS/XPath 选择器，定位目标元素。<br></code></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>是否只取可见文本</th><th>是否包含隐藏元素文本</th></tr></thead><tbody><tr><td><code>inner_text()</code></td><td>✅ 只取可见</td><td>❌ 不包含</td></tr><tr><td><code>text_content()</code></td><td>❌ 取所有（包括 <code>display:none</code>）</td><td>✅ 包含</td></tr></tbody></table><p>2️⃣ <code>query_selector </code> 根据 CSS&#x2F;XPath 选择器，返回第一个匹配的元素句柄（ElementHandle），找不到就返回 None。</p><table><thead><tr><th>方法</th><th>返回</th></tr></thead><tbody><tr><td><code>query_selector</code></td><td>第一个匹配元素（ElementHandle 或 None）</td></tr><tr><td><code>query_selector_all</code></td><td><strong>列表</strong> <code>[ElementHandle, …]</code>，空列表 <code>[]</code></td></tr></tbody></table><p>3️⃣ <code>get_attribute</code> 把 HTML 标签里的 属性&#x3D;”值” 取出来。</p><table><thead><tr><th>方法</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>get_attribute</code></td><td>取 <strong>标签属性值</strong></td><td><code>&lt;a href=&quot;x&quot;&gt;</code> → <code>&quot;x&quot;</code></td></tr><tr><td><code>inner_text</code> &#x2F; <code>text_content</code></td><td>取 <strong>元素内部可见文本</strong></td><td><code>&lt;a href=&quot;x&quot;&gt;点我&lt;/a&gt;</code> → <code>&quot;点我&quot;</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> async_playwright() <span class="hljs-keyword">as</span> p: <span class="hljs-comment">#Playwright 的“启动写法</span><br>    browser = <span class="hljs-keyword">await</span> p.chromium.launch(<br>                            headless=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 无界面运行，省资源。</span><br>                            args=[<br>                                <span class="hljs-string">&#x27;--disable-gpu&#x27;</span>,<br>                                <span class="hljs-string">&#x27;--disable-dev-shm-usage&#x27;</span>,<br>                                <span class="hljs-string">&#x27;--no-sandbox&#x27;</span>,<br>                                <span class="hljs-string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>,    <span class="hljs-comment">#去掉 navigator.webdriver=true 等自动化特征，降低被反爬识别概率。</span><br>                                <span class="hljs-string">&#x27;--disable-features=IsolateOrigins,site-per-process&#x27;</span>,<br>                                <span class="hljs-string">&#x27;--disable-site-isolation-trials&#x27;</span><br>                            ],<br>                            proxy=playwright_proxy<br>                        )<br>    iphone = p.devices[<span class="hljs-string">&quot;iPhone 12&quot;</span>] <span class="hljs-comment"># Playwright 自带的「iPhone 12」设备配置（含视口、UA、触控等）。</span><br>                    <span class="hljs-comment">#创建一个新的浏览器上下文（Context），相当于一个独立的浏览器环境（类似于一个新的窗口或用户）。</span><br>                    context = <span class="hljs-keyword">await</span> browser.new_context(<br>                        **iphone,<br>                        extra_http_headers=&#123;<br>                            <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://mp.weixin.qq.com/&quot;</span>,<br>                            <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.42(0x18002a2e) NetType/WIFI Language/zh_CN&quot;</span>,<br>                            <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;</span>,<br>                            <span class="hljs-string">&quot;Accept-Language&quot;</span>: <span class="hljs-string">&quot;zh-CN,zh;q=0.9,en;q=0.8&quot;</span>,<br>                            <span class="hljs-string">&quot;Accept-Encoding&quot;</span>: <span class="hljs-string">&quot;gzip, deflate, br&quot;</span>,<br>                            <span class="hljs-string">&quot;Connection&quot;</span>: <span class="hljs-string">&quot;keep-alive&quot;</span>,<br>                            <span class="hljs-string">&quot;Upgrade-Insecure-Requests&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>                            <span class="hljs-string">&quot;Sec-Fetch-Dest&quot;</span>: <span class="hljs-string">&quot;document&quot;</span>,<br>                            <span class="hljs-string">&quot;Sec-Fetch-Mode&quot;</span>: <span class="hljs-string">&quot;navigate&quot;</span>,<br>                            <span class="hljs-string">&quot;Sec-Fetch-Site&quot;</span>: <span class="hljs-string">&quot;same-origin&quot;</span>,<br>                            <span class="hljs-string">&quot;Sec-Fetch-User&quot;</span>: <span class="hljs-string">&quot;?1&quot;</span>,<br>                            <span class="hljs-string">&quot;Cache-Control&quot;</span>: <span class="hljs-string">&quot;max-age=0&quot;</span><br>                        &#125;<br>                    )<br>                    <span class="hljs-comment"># 每个新页面加载前注入自定义 JavaScript 脚本。</span><br>                    <span class="hljs-keyword">await</span> context.add_init_script(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                        Object.defineProperty(navigator, &#x27;webdriver&#x27;, &#123;</span><br><span class="hljs-string">                            get: () =&gt; undefined</span><br><span class="hljs-string">                        &#125;);</span><br><span class="hljs-string">                        Object.defineProperty(navigator, &#x27;plugins&#x27;, &#123;</span><br><span class="hljs-string">                            get: () =&gt; [1, 2, 3, 4, 5]</span><br><span class="hljs-string">                        &#125;);</span><br><span class="hljs-string">                        Object.defineProperty(navigator, &#x27;languages&#x27;, &#123;</span><br><span class="hljs-string">                            get: () =&gt; [&#x27;zh-CN&#x27;, &#x27;zh&#x27;]</span><br><span class="hljs-string">                        &#125;);</span><br><span class="hljs-string">                    &quot;&quot;&quot;</span>)<br>                    <span class="hljs-comment"># 创建页面并访问 同一个上下文下的页面共享 Cookie、存储等环境</span><br>                    page = <span class="hljs-keyword">await</span> context.new_page()<br>                     <span class="hljs-keyword">try</span>:<br>                        logger.info(<span class="hljs-string">f&quot;[PDF] 开始访问URL: <span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>                        <span class="hljs-comment"># wait_until=等待页面网络空闲（即没有新的网络请求），通常表示页面和资源加载完成。</span><br>                        <span class="hljs-keyword">await</span> page.goto(url, wait_until=<span class="hljs-string">&quot;networkidle&quot;</span>, timeout=<span class="hljs-number">10000</span>)<br>                        logger.info(<span class="hljs-string">&quot;[PDF] 页面加载完成&quot;</span>)<br>                        <span class="hljs-keyword">try</span>:<br>                            body_text = <span class="hljs-keyword">await</span> page.inner_text(<span class="hljs-string">&#x27;body&#x27;</span>)<br>                        <span class="hljs-keyword">except</span> Exception:<br>                            body_text = <span class="hljs-string">&quot;&quot;</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;安全验证&quot;</span> <span class="hljs-keyword">in</span> body_text <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;网络超时&quot;</span> <span class="hljs-keyword">in</span> body_text <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;网络不给力&quot;</span> <span class="hljs-keyword">in</span> body_text:<br>                            logger.warning(<span class="hljs-string">&quot;[PDF] 检测到安全验证或网络超时提示，移除当前代理并重试&quot;</span>)<br>                            <span class="hljs-keyword">if</span> proxy:<br>                                proxy_pool.remove_proxy(proxy)<br>                            <span class="hljs-keyword">continue</span><br>                        error_text = <span class="hljs-keyword">await</span> page.query_selector(<span class="hljs-string">&quot;div.weui-msg__title&quot;</span>)<br>                        <span class="hljs-keyword">if</span> error_text:<br>                            error_content = <span class="hljs-keyword">await</span> error_text.inner_text()<br>                            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;环境异常&quot;</span> <span class="hljs-keyword">in</span> error_content:<br>                                <span class="hljs-keyword">if</span> proxy:<br>                                    logger.warning(<span class="hljs-string">f&quot;[PDF] 检测到环境异常，移除代理: <span class="hljs-subst">&#123;proxy&#125;</span>&quot;</span>)<br>                                    proxy_pool.remove_proxy(proxy)<br>                                <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;微信环境检测异常，已移除当前代理，请稍后重试&quot;</span>)<br>                        title = <span class="hljs-keyword">await</span> page.title()<br>                        meta_img = <span class="hljs-keyword">await</span> page.query_selector(<span class="hljs-string">&quot;meta[property=&#x27;og:image&#x27;]&quot;</span>)<br>                        <span class="hljs-keyword">if</span> meta_img:<br>                            cover_image_url = <span class="hljs-keyword">await</span> meta_img.get_attribute(<span class="hljs-string">&quot;content&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XPath</title>
    <link href="/2025/08/01/XPath/"/>
    <url>/2025/08/01/XPath/</url>
    
    <content type="html"><![CDATA[<h2 id="Xpath解析"><a href="#Xpath解析" class="headerlink" title="Xpath解析"></a>Xpath解析</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点。</td></tr><tr><td>&#x2F;</td><td>从根节点选取（取子节点）。</td></tr><tr><td>&#x2F;&#x2F;</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置（取子孙节点）。</td></tr><tr><td>.</td><td>选取当前节点。</td></tr><tr><td>..</td><td>选取当前节点的父节点。</td></tr><tr><td>@</td><td>选取属性。</td></tr></tbody></table><ul><li>1️⃣选择所有节点：<br><code>使用双斜杠//选择文档中的所有节点，例如：//node()</code></li><li>2️⃣按标签名选择节点：<br><code>使用标签名选择节点，例如：//book</code></li><li>3️⃣按属性选择节点：<br><code>使用方括号[]和@符号选择具有特定属性值的节点，例如：//book[@category=&quot;children&quot;]</code></li><li>4️⃣选择父节点、子节点和兄弟节点：<br><code>使用父节点(…)、子节点(/)和兄弟节点(//)选择节点</code></li><li>5️⃣  8️⃣ 9️⃣ 🔟使用通配符选择节点：<br><code>使用星号*选择任何节点，例如：//book/*选择所有book节点的子节点</code></li><li>6️⃣使用逻辑运算符选择节点：<br><code>使用and、or、not等逻辑运算符选择节点，例如：//book[price&lt;10 and @category=&quot;children&quot;]</code></li><li>7️⃣使用内置函数处理节点：<br><code>使用内置函数处理节点的文本和数值，例如：//book[substring(title,1,3)=&quot;The&quot;]选择标题以&quot;The&quot;开头的书籍</code></li></ul><h2 id="路径表达式"><a href="#路径表达式" class="headerlink" title="路径表达式"></a>路径表达式</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>bookstore</td><td>选取 bookstore 元素的所有子节点。</td></tr><tr><td>&#x2F;bookstore</td><td>选取根元素 bookstore。</td></tr><tr><td>bookstore&#x2F;book</td><td>选取属于 bookstore 的子元素的所有 book 元素。</td></tr><tr><td>&#x2F;&#x2F;book</td><td>选取所有 book 子元素，而不管它们在文档中的位置。</td></tr><tr><td>bookstore&#x2F;&#x2F;book</td><td>选取属于 bookstore 元素的后代的所有 book 元素，而不管它们的位置。</td></tr><tr><td>@lang</td><td>选取名为 lang 的所有属性。</td></tr></tbody></table><p><code>XPath路径表达式的基本语法如下：</code><br>&#x2F;                 : 定位到根节点<br>&#x2F;bookstore        : 定位到根节点下的bookstore节点<br>&#x2F;bookstore&#x2F;book   : 定位到bookstore节点下的所有book节点<br>&#x2F;&#x2F;book            : 递归查找所有book节点<br>&#x2F;&#x2F;book[@category&#x3D;’web’] : 查找所有category属性值为web的book节点</p><table><thead><tr><th>路径表达式</th><th>描述</th></tr></thead><tbody><tr><td>&#x2F;bookstore&#x2F;book[1]</td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[last()]</td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[last()-1]</td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[position()&lt;3]</td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td>&#x2F;&#x2F;title[@lang$]</td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td>&#x2F;&#x2F;title[@lang&#x3D;’eng’]</td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[price&gt;35.00]</td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。</td></tr><tr><td>&#x2F;bookstore&#x2F;book[price&gt;35.00]&#x2F;&#x2F;title</td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。</td></tr></tbody></table><h2 id="未知节点"><a href="#未知节点" class="headerlink" title="未知节点"></a>未知节点</h2><table><thead><tr><th>通配符&#x2F;路径表达式</th><th>描述</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配任何元素节点。</td></tr><tr><td><code>@*</code></td><td>匹配任何属性节点。</td></tr><tr><td><code>/bookstore/*</code></td><td>选取 bookstore 元素的所有子元素。</td></tr><tr><td><code>//*</code></td><td>选取文档中的所有元素。</td></tr><tr><td><code>//title[@*]</code></td><td>选取所有带有属性的 title 元素。</td></tr></tbody></table><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a><em>实战</em></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;https://www.douguo.com/&#x27;</span><br>res = requests.get(url)<br><span class="hljs-built_in">print</span>(res.text)<br>html = etree.HTML(res.text)<br><span class="hljs-comment"># /从根节点选取（取子节点）。</span><br>rest = html.xpath(<span class="hljs-string">&#x27;/html/head/title/text()&#x27;</span>)  <span class="hljs-comment"># 返回Element对象</span><br><span class="hljs-built_in">print</span>(rest)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># // 获取任何位置的数据，不从根路径出发</span><br>title_text = html.xpath(<span class="hljs-string">&#x27;//title/text()&#x27;</span>)  <span class="hljs-comment"># 一般会获取多个数据</span><br><span class="hljs-built_in">print</span>(title_text)<br></code></pre></td></tr></table></figure><p>html &#x3D; etree.HTML(res.text)<br>这行代码的作用是将 HTTP 响应中的 HTML 文本解析为一个 Element 对象，以便后续对其进行操作，例如提取数据、修改内容、查找元素等等。其中，etree 是 Python 的一个第三方库，可以用来解析 XML 和 HTML 文本。HTML 是一种标记语言，用于构建网页和 Web 应用程序的用户界面。<br>我们在使用的时候，需要导入，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">from</span> tabulate <span class="hljs-keyword">import</span> tabulate<br>url = <span class="hljs-string">&#x27;https://www.douguo.com/&#x27;</span><br>res = requests.get(url)<br><span class="hljs-built_in">print</span>(res.text)<br><span class="hljs-comment"># html = etree.HTML(res.text)</span><br>html = etree.HTML(res.text)<br>name = html.xpath(<span class="hljs-string">f&#x27;//*[@id=&quot;content&quot;]/ul[1]/li[1]/div/a/text()&#x27;</span>)<br><span class="hljs-built_in">print</span>(name)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask</title>
    <link href="/2025/08/01/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_hexo_cleaned/"/>
    <url>/2025/08/01/Flask%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_hexo_cleaned/</url>
    
    <content type="html"><![CDATA[<p><strong>Flask</strong></p><h1 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、 简介"></a>一、 简介</h1><p>Flask是一个非常小的PythonWeb框架，被称为微型框架；只提供了一个稳健的核心，其他功能全部是通过扩展实现的</p><h1 id="二、-概要"><a href="#二、-概要" class="headerlink" title="二、 概要"></a>二、 概要</h1><p>1）安装： pip install flask<br>2）组成：WSGI系统、调试、路由<br>3）模板引擎：Jinja2（由Flask核心开发者人员开发）<br>4）使用到装饰器：以@开头的代码方法</p><h1 id="三、-知识点（附代码）"><a href="#三、-知识点（附代码）" class="headerlink" title="三、 知识点（附代码）"></a>三、 知识点（附代码）</h1><h2 id="1-Flask基础入门"><a href="#1-Flask基础入门" class="headerlink" title="1. Flask基础入门"></a>1. Flask基础入门</h2><h3 id="1）路由route的创建："><a href="#1）路由route的创建：" class="headerlink" title="1）路由route的创建："></a>1）路由route的创建：</h3><p>methods&#x3D;[]支持的请求方式参数设置，不设置默认为GET<br>  @app.route(‘&#x2F;login’, methods&#x3D;[‘GET’, ‘PoSt’])  # 请求参数设置不区分大小写，源码中自动进行了upper<br>  def login():  ✅ 访问 &#x2F;login 这个地址时：<br>🔹 如果是 GET 请求（比如你在浏览器地址栏输入 &#x2F;login）就返回一个 login.html 页面（登录表单页面）<br>      if request.method &#x3D;&#x3D; ‘GET’:<br>          return render_template(‘login.html’)<br>    🔹 如果是 POST 请求（比如你在表单里点“登录”按钮提交）：从表单里取出两个字段：<br>      elif request.method &#x3D;&#x3D; ‘POST’:<br>          username &#x3D; request.form.get(‘username’)<br>          pwd &#x3D; request.form.get(‘pwd’)<br>          🔹如果用户名是 yang 且密码是 123456：<br>          if username &#x3D;&#x3D; ‘yang’ and pwd &#x3D;&#x3D; ‘123456’:<br>          🔹把用户名存到 session（表示用户已登录）<br>              session[‘username’] &#x3D; username<br>              return ‘login successed 200  ok!’<br>          else:<br>             return ‘login failed!!!’</p><p>🔹视图函数：✅ 一句话解释<br>视图函数（view function）就是 Flask 中“处理某个 URL 请求并返回响应”的 Python 函数。它相当于 MVC 里的 C（Controller）+V（View） 的结合体：接收请求 → 做业务逻辑 → 把结果（HTML&#x2F;JSON&#x2F;文本）返回</p><p>url_map.convertersFlask 的转换器注册表，把自己的转换器“挂”进去<br>&lt;re(…)&gt;路由里的尖括号表达式，用来捕获并转换 URL 片段<br>✅ 第 2 步：我们想干啥？让路由支持正则表达式匹配！<br>✅ 第 3 步：写个“手机验证”转换器<br>class RegexConverter(BaseConverter):<br>    def <strong>init</strong>(self, url_map, regex):<br>        super().<strong>init</strong>(url_map)   # 先让父类干活<br>        self.regex &#x3D; regex          # 把我们传的正则保存起来<br>    def to_python(self, value):<br>        print(‘to_python被调用，拿到值：’, value)<br>        return value                # 原样返回即可<br><strong>init</strong>：Flask 会把路由里写的正则自动塞给你（regex 参数）。<br>to_python：Flask 每捕获一次，就调用它，你可以做额外处理（这里只是打印）。<br>✅ 第 4 步：把转换器“挂”到 Flask 上<br>app.url_map.converters[‘re’] &#x3D; RegexConverter    app你创建的 Flask 应用<br>现在可以用 &lt;re(…)&gt; 这种语法了！<br>✅ 第 5 步：用转换器写路由<br>@app.route(“&#x2F;index&#x2F;&lt;re(‘1\d{10}’):value&gt;”)<br>def index(value):<br>    print(‘视图函数收到的 value：’, value)<br>    return “Hello World!<br>‘1\d{10}’ 是正则：以 1 开头、后面 10 位数字 → 11 位手机号。<br>&lt;re(…)&gt; 里的 re 就是刚才注册的转换器。<br>捕获到的字符串会经 to_python 处理后，传给 index(value)。</p><h3 id="2）endpoint的作用"><a href="#2）endpoint的作用" class="headerlink" title="2）endpoint的作用"></a>2）endpoint的作用</h3><p>🔹说明：每个app中都存在一个url_map，这个url_map中包含了url到endpoint的映射；<br>🔹作用：当request请求传来一个url的时候，会在url_map中先通过rule找到endpoint，然后再在view_functions中根据endpoint再找到对应的视图函数view_func</p><p>自定义装饰器装饰多个视图函数时，如果在路由中没有指定唯一的endpoint,<br> 则所有装饰的视图函数返回的都是装饰器中的inner函数，同名因此会报错<br> def decorator(f):<br>    def inner(*args, **kwargs):<br>        return f(*args, **kwargs)<br>    return inner          # ← 所有被装饰的函数最终都叫 inner</p><p>@app.route(‘&#x2F;a’)<br>@decorator<br>def a():                  # 实际注册的是 inner<br>    return ‘a’</p><p>@app.route(‘&#x2F;b’)<br>@decorator<br>def b():                  # 又注册一个 inner → 同名冲突！<br>    return ‘b’</p><h3 id="3）request对象的使用"><a href="#3）request对象的使用" class="headerlink" title="3）request对象的使用"></a>3）request对象的使用</h3><p>render_template()：可以用于呈现一个我们编写的html文件模板</p><h3 id="4）请求钩子before-after-request"><a href="#4）请求钩子before-after-request" class="headerlink" title="4）请求钩子before&#x2F;after_request"></a>4）请求钩子before&#x2F;after_request</h3><p>🔹想要在正常执行的代码的前、中、后时期，强行执行一段我们想要执行的功能代码，便要用到钩子函数——用特定装饰器装饰的函数。<br>1.before_request：在每一次请求之前调用；执行顺序是先绑定的先执行；<br>2.after_request：每一次请求之后都会调用；执行的顺序是先绑定的后执行；</p><h3 id="5）redirect重定向"><a href="#5）redirect重定向" class="headerlink" title="5）redirect重定向"></a>5）redirect重定向</h3><p>🔹在flask 中，重定向是通过flask.redirect(location, code&#x3D;302)这个函数来实现的，location表示需要重定向的url, 应该配合url_for函数来使用， code表示采用哪个重定向，默认是302，即临时性重定向, 可以修改为301来实现永性重定向；</p><h3 id="6）返回json数据给前端"><a href="#6）返回json数据给前端" class="headerlink" title="6）返回json数据给前端"></a>6）返回json数据给前端</h3><p>1.使用：make_response方法和json库共同完成<br>response &#x3D; make_response(json.dumps(data,ensure_ascii&#x3D;False))<br>   response.mimetype &#x3D; ‘application&#x2F;json’<br>   return response<br>2.使用：jsonify库实现，减少代码行数</p><h3 id="7）abort函数的使用"><a href="#7）abort函数的使用" class="headerlink" title="7）abort函数的使用"></a>7）abort函数的使用</h3><p>🔹使用类似于python中的raise函数，可以在需要退出请求的地方抛出错误，并结束该请求；可以使用errorhandler()装饰器来进行异常的捕获与自定义：</p><h3 id="8）url-for实现反转"><a href="#8）url-for实现反转" class="headerlink" title="8）url_for实现反转"></a>8）url_for实现反转</h3><p>🔹视图函数 → \rightarrow →url；</p><h2 id="2-Flask高级视图"><a href="#2-Flask高级视图" class="headerlink" title="2. Flask高级视图"></a>2. Flask高级视图</h2><h3 id="1）add-url-rule的初登场"><a href="#1）add-url-rule的初登场" class="headerlink" title="1）add_url_rule的初登场"></a>1）add_url_rule的初登场</h3><p>实现url与视图函数的绑定，除了使用路由装饰器@app.route,  add_url_rule(rule,endpoint&#x3D;None,view_func&#x3D;None)</p><h3 id="2）类视图的引入"><a href="#2）类视图的引入" class="headerlink" title="2）类视图的引入"></a>2）类视图的引入</h3><p>🔹 定义的视图都是通过函数来实现的,所以称之为视图函数,但其实视图还可以由类来实现，即类视图；<br>🔹标准类视图：<br>        定义时需要继承flask的views.View这一基类;<br>        每个类视图内必须包含一个dispatch_request方法，每当类视图接收到请求时都会执行该方法，返回值的设定和视图函数相同；<br>        视图函数可以通过@app.route和app.add_url_rule来进行注册（映射到url），但类视图只能通过app.add_url_rule来注册，注册时view_func不能直接使用类名，需要调用基类中的as_view方法来为自己取一个“视图函数名”<br>from flask import Flask,render_template,views<br>app &#x3D; Flask(<strong>name</strong>)</p><h1 id="定义父视图类继承基类View"><a href="#定义父视图类继承基类View" class="headerlink" title="定义父视图类继承基类View"></a>定义父视图类继承基类View</h1><p>class Ads(views.View):<br>    def <strong>init</strong>(self):<br>        super(Ads, self).<strong>init</strong>()<br>        # 实例属性<br>        self.context&#x3D;{<br>            ‘ads’:’这是对联广告！’<br>        }</p><h1 id="定义子视图类继承父类并实现工程"><a href="#定义子视图类继承父类并实现工程" class="headerlink" title="定义子视图类继承父类并实现工程"></a>定义子视图类继承父类并实现工程</h1><p>class Index(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;index.html’,**self.context)<br>class Login(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;login.html’,**self.context)<br>class Register(Ads):<br>    def dispatch_request(self):<br>        # 字典传参方式&#x3D;&#x3D;不定长的关键字传参<br>        return render_template(‘class_mould&#x2F;register.html’,**self.context)</p><h1 id="注册我们创建的类视图-as-view给类视图起名"><a href="#注册我们创建的类视图-as-view给类视图起名" class="headerlink" title="注册我们创建的类视图,as_view给类视图起名"></a>注册我们创建的类视图,as_view给类视图起名</h1><p>app.add_url_rule(rule&#x3D;’&#x2F;‘,endpoint&#x3D;’index’,view_func&#x3D;Index.as_view(‘index’))<br>app.add_url_rule(rule&#x3D;’&#x2F;login&#x2F;‘,endpoint&#x3D;’login’,view_func&#x3D;Login.as_view(‘login’))<br>app.add_url_rule(rule&#x3D;’&#x2F;register&#x2F;‘,endpoint&#x3D;’register’,view_func&#x3D;Register.as_view(‘register’))</p><p>if <strong>name</strong>&#x3D;&#x3D;’<strong>main</strong>‘:<br>    print(app.view_functions)<br>    app.run(debug&#x3D;True)</p><h3 id="3）装饰器的自定义与使用"><a href="#3）装饰器的自定义与使用" class="headerlink" title="3）装饰器的自定义与使用"></a>3）装饰器的自定义与使用</h3><h3 id="4）蓝图的使用"><a href="#4）蓝图的使用" class="headerlink" title="4）蓝图的使用"></a>4）蓝图的使用</h3><p>当接收到请求时，Flask会遍历Flask对象下（已注册）的各蓝图对象，比对蓝图对象中记录的url，比对成功则映射到该url绑定的视图函数并返回响应<br>📌 举个例子（不用蓝图 vs 用蓝图）<br>❌ 不用蓝图：所有代码写在一个文件<br>from flask import Flask<br>app &#x3D; Flask(<strong>name</strong>)<br>@app.route(‘&#x2F;‘)<br>def home():<br>    return ‘Home’<br>@app.route(‘&#x2F;admin’)<br>def admin():<br>    return ‘Admin’<br>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    app.run()<br>✅ 用蓝图：按模块拆分</p><h1 id="文件：admin-routes-py"><a href="#文件：admin-routes-py" class="headerlink" title="文件：admin&#x2F;routes.py"></a>文件：admin&#x2F;routes.py</h1><p>from flask import Blueprint<br>admin_bp &#x3D; Blueprint(‘admin’, <strong>name</strong>, url_prefix&#x3D;’&#x2F;admin’)</p><p>@admin_bp.route(‘&#x2F;‘)<br>def admin_home():<br>    return ‘Admin Home’</p><h1 id="文件：main-py"><a href="#文件：main-py" class="headerlink" title="文件：main.py"></a>文件：main.py</h1><p>from flask import Flask<br>from admin.routes import admin_bp</p><p>app &#x3D; Flask(<strong>name</strong>)<br>app.register_blueprint(admin_bp)</p><p>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    app.run()</p><h3 id="5）url-prefix设置蓝图前缀"><a href="#5）url-prefix设置蓝图前缀" class="headerlink" title="5）url_prefix设置蓝图前缀"></a>5）url_prefix设置蓝图前缀</h3><p>蓝图对象定义时添加，为当前蓝图下的所有视图函数添加统一的前缀<br>new_list &#x3D; Blueprint(‘news’,<strong>name</strong>,url_prefix&#x3D;’&#x2F;index’)<br>@new_list.route(‘&#x2F;news’)<br>def new():<br>    return ‘这是新闻模块！’<br>此外，在主路由中注册蓝图时也可以为蓝图添加前缀，并且此次添加会覆写蓝图对象创建时添加的前缀；<br>如下例中，注册后的新闻模块的url又变为了”&#x2F;test&#x2F;news”：<br>app.register_blueprint(news.new_list,url_prefix&#x3D;’&#x2F;test’)</p><h3 id="6）subdomain设置蓝图子域名"><a href="#6）subdomain设置蓝图子域名" class="headerlink" title="6）subdomain设置蓝图子域名"></a>6）subdomain设置蓝图子域名</h3><p>通过修改Flask对象的配置,为我们的网站设置域名,用字段为’SERVER_NAME’,为该域名指定端口号：</p><h1 id="当前网站域名设置为example-com，端口号为5000"><a href="#当前网站域名设置为example-com，端口号为5000" class="headerlink" title="当前网站域名设置为example.com，端口号为5000"></a>当前网站域名设置为example.com，端口号为5000</h1><pre><code class="hljs">app.config[&#39;SERVER_NAME&#39;] = &#39;example.com:5000&#39;</code></pre><p>修改位于 C:\Windows\System32\drivers\etc 下的域名重定向文件 hosts<br>📌设置子域名:在蓝图文件admin.py中注册蓝图对象，添加subdomain&#x3D;’admin’即为该蓝图设置子域名admin；<br>再在hosts文件中添加记录：10.240.142.216 admin.example<br>📌再在hosts文件中添加记录：10.240.142.216 admin.example.com后，我们便可以通过域名：<a href="http://admin.example.com:5000/ad%E6%9D%A5%E8%AE%BF%E9%97%AE%E8%AF%A5%E8%93%9D%E5%9B%BE%EF%BC%88%E4%B8%8B%E4%B8%80%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%9C%A8%E4%B8%8A%E4%B8%80%E7%BA%A7%E5%B7%A6%E4%BE%A7%EF%BC%89%EF%BC%9B">http://admin.example.com:5000/ad来访问该蓝图（下一级域名在上一级左侧）；</a><br>        from flask import Blueprint<br>        bp &#x3D; Blueprint(‘admin’,<strong>name</strong>,subdomain &#x3D; ‘admin’)<br>        @bp.route(‘&#x2F;ad’)<br>        def admin():<br>            return ‘Admin Page’</p><h2 id="3-jinja2模板引擎"><a href="#3-jinja2模板引擎" class="headerlink" title="3.jinja2模板引擎"></a>3.jinja2模板引擎</h2><h3 id="1）模板的导入与使用"><a href="#1）模板的导入与使用" class="headerlink" title="1）模板的导入与使用"></a>1）模板的导入与使用</h3><pre><code class="hljs">Flask通过render_template来实现模板的渲染。要导入from flask     import rander_template，模板中注释需放在中</code></pre><h3 id="2）模板中的控制语句"><a href="#2）模板中的控制语句" class="headerlink" title="2）模板中的控制语句"></a>2）模板中的控制语句</h3><pre><code class="hljs">jinja2模板引擎中也可使用if和for控制语句，但是语句需要放置在&#123;% %&#125;中；if条件判断语句必须包含结束标签&#123;% endif %&#125;，其他部分与python中类似，可以与比较运算符&gt; &gt;= &lt; &lt;= == !=结合使用，或与逻辑运算符and,or,not,()结合使用；</code></pre><h3 id="3）过滤器的使用与自定义"><a href="#3）过滤器的使用与自定义" class="headerlink" title="3）过滤器的使用与自定义"></a>3）过滤器的使用与自定义</h3><p>&lt;— 自定义过滤器 —&gt;<br>def list_step(li):<br>    # 返回列表，步长为2<br>    return li[::2]</p><pre><code class="hljs"># 注册模板过滤器（filter）# 参数1为该过滤器调用的函数参数2为在前端中调用该过滤器使用的名称</code></pre><p>app.add_template_filter(list_step,’li2’)</p><p>可以在前端模板内  <!-- 原为 Jinja2 过滤器语法，已移除过滤器部分 -->的” | “后使用；</p><h2 id="4-Flask数据交互"><a href="#4-Flask数据交互" class="headerlink" title="4.Flask数据交互"></a>4.Flask数据交互</h2><h3 id="4）Cookie的使用"><a href="#4）Cookie的使用" class="headerlink" title="4）Cookie的使用"></a>4）Cookie的使用</h3><p>📌 在网站中，http请求是呈无序状态的<br>无序状态是指协议对于事务处理没有记忆能力，同一个服务器上你新打开的网页和之前打开的网页之间没有任何联系，你的当前请求和上一次请求究竟是不是一个用户发出的，服务器也无从得知；</p><p>Cookie一般通过Response对象的set_cookie()方法来设置<br>    # 前两个参数必须设置，后续参数则为可选参数<br>set_cookie(key,value[,max_age,expires,path,domain,secure,httponly,samesite])<br>key(或name)必需项，规定cookie的名称，字符串<br>value必需项，规定cookie的内容，字符串</p><p>除此之外，我们也可以通过修改响应对象Response的表单头headers来设置cookie：<br>@app.route(‘&#x2F;h’)<br>def set_cookie_h():<br>    resp &#x3D; Response(“设置Cookie！”)<br>    # 通过添加表头的键值对来实现cookie设置<br>    # 第一项为key&#x3D;value，需要同时设置这两个参数，后续项则用分号分隔<br>    resp.headers[‘Set-Cookie’] &#x3D; “ testname &#x3D; lisi; Expires &#x3D; SUN,01-Nov-2021 05:10:12 GMT; Max-Age&#x3D;3600; path&#x3D;&#x2F; “<br>    return resp</p>]]></content>
    
    
    <categories>
      
      <category>Flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
